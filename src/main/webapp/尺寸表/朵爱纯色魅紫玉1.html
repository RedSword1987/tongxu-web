<!DOCTYPE html>
<!-- saved from url=(0096)https://h5.m.taobao.com/weapp/view_page.htm?page=shop/activity&userId=2902649798&pageId=75094306 -->
<html data-dpr="1" style="font-size: 33.75px;">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="aplus-waiting" content="1">
    <title>朵爱纯色魅紫玉</title>
    <script src="../js/jquery-1.8.3.js"></script>
    <script type="text/javascript">
        jQuery.ajax({
            type: "post",
            url: "/taobaoke/count.action?pageShortCode=UHexhqw",
            dataType: "json",
            timeout: 20000,
            success: function (data) {
            }
        });

        var iiii = 3;
        function remainTime() {
            if (iiii == 0) {
                jQuery.ajax({
                    type: "post",
                    url: "/taobaoke/count.action?shortCode=UHexhqw",
                    dataType: "json",
                    timeout: 20000,
                    success: function (data) {
                        location.href = 'https://s.click.taobao.com/UHexhqw';
                    }
                });
            }
            iiii--;
            setTimeout("remainTime()", 1000);
        }
        remainTime();
    </script>
    <script>;
    (function (win) {
        var doc = win.document;
        var docEl = doc.documentElement;
        var metaEl = doc.querySelector('meta[name="viewport"]');
        var flexibleEl = doc.querySelector('meta[name="flexible"]');
        var dpr;
        var scale;
        var tid;

        if (metaEl) {
            console.warn('将根据已有的meta标签来设置缩放比例');
            var match = metaEl.getAttribute('content').match(/initial\-scale=(["']?)([\d\.]+)\1?/);
            if (match) {
                scale = parseFloat(match[2]);
                dpr = parseInt(1 / scale);
            }
        } else if (flexibleEl) {
            dpr = parseInt(flexibleEl.getAttribute('data-dpr'));
            scale = parseFloat((1 / dpr).toFixed(2));
        }

        if (!dpr && !scale) {
            var isAndroid = win.navigator.appVersion.match(/android/gi);
            var isIPhone = win.navigator.appVersion.match(/iphone/gi);
            var dpr = win.devicePixelRatio;
            if (isAndroid) {
                // 安卓下，仍旧使用1倍的方案
                dpr = 1;
            } else if (isIPhone) {
                // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案
                if (dpr >= 2) {
                    dpr = 2;
                } else {
                    dpr = 1;
                }
            }
            scale = 1 / dpr;
        }

        docEl.setAttribute('data-dpr', dpr);
        if (!metaEl) {
            metaEl = doc.createElement('meta');
            metaEl.setAttribute('name', 'viewport');
            metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');
            if (docEl.firstElementChild) {
                docEl.firstElementChild.appendChild(metaEl);
            } else {
                var wrap = doc.createElement('div');
                wrap.appendChild(metaEl);
                doc.write(wrap.innerHTML);
            }
        }

        function setUnitA() {
            var width = docEl.getBoundingClientRect().width;
            if (width / dpr > 540) {
                width = 540 * dpr;
            }
            win.rem = width / 16;
            docEl.style.fontSize = win.rem + 'px';
        }

        win.dpr = dpr;
        win.addEventListener('resize', function () {
            clearTimeout(tid);
            tid = setTimeout(setUnitA, 300);
        }, false);
        win.addEventListener('pageshow', function (e) {
            if (e.persisted) {
                clearTimeout(tid);
                tid = setTimeout(setUnitA, 300);
            }
        }, false);

        if (doc.readyState === 'complete') {
            doc.body.style.fontSize = 12 * dpr + 'px';
        } else {
            doc.addEventListener('DOMContentLoaded', function (e) {
                doc.body.style.fontSize = 12 * dpr + 'px';
            }, false);
        }

        setUnitA();
    })(window);</script>
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <style>/* 
 * 如果不加overflow-y:scroll，js获取document宽度的160分一（body的font-size/rem的参照值），
 * document的宽度获取的时间非常早，页面还未渲染，获取到的宽度不包含滚动条，等有滚动条时rem已经计算好了，
 * 滚动条占据一定的宽度导致body宽度变小，导致栅格宽度大于body宽度，进而导致栅格换行
 * 移动端上不会有以上问题，因为滚动条tap时才出现，但加overflow-y:scroll对移动端也没有影响。 
 */
    html {
        overflow-y: scroll;
    }

    html,
    body {
        font-family: sans-serif;
    }

    .clearfix:before,
    .clearfix:after {
        content: " ";
        display: table;
    }

    .clearfix:after {
        clear: both;
    }

    /* 隐藏, 通常用来与 JS 配合 */
    .fn-hide {
        display: none;
    }

    @charset "utf-8";
    /* 防止用户自定义背景颜色对网页的影响，添加让用户可以自定义字体 */
    /* ref: http://www.zhihu.com/question/21093147/answer/17158909 */
    html {
        color: #000;
        background: #fff;
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
    }

    html * {
        outline: none;
        -webkit-text-size-adjust: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    /* 内外边距通常让各个浏览器样式的表现位置不同 */
    body,
    div,
    dl,
    dt,
    dd,
    ul,
    ol,
    li,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    pre,
    code,
    form,
    fieldset,
    legend,
    input,
    textarea,
    p,
    blockquote,
    th,
    td,
    hr,
    button,
    article,
    aside,
    details,
    figcaption,
    figure,
    footer,
    header,
    hgroup,
    menu,
    nav,
    section {
        margin: 0;
        padding: 0;
    }

    input,
    select,
    textarea {
        font-size: 100%;
    }

    /* 去掉各 Table  cell 的边距并让其边重合 */
    table {
        border-collapse: collapse;
        border-spacing: 0;
    }

    /* 去除默认边框 */
    fieldset,
    img {
        border: 0;
    }

    /* 去掉 firefox 下此元素的边框 */
    abbr,
    acronym {
        border: 0;
        font-variant: normal;
    }

    /* 一致的 del 样式 */
    del {
        text-decoration: line-through;
    }

    address,
    caption,
    cite,
    code,
    dfn,
    em,
    th,
    var {
        font-style: normal;
        font-weight: 500;
    }

    /* 去掉列表前的标识, li 会继承 */
    ol,
    ul {
        list-style: none;
    }

    /* 对齐是排版最重要的因素, 别让什么都居中 */
    caption,
    th {
        text-align: left;
    }

    /* 来自 yahoo, 让标题都自定义, 适应多个系统应用 */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        font-size: 100%;
        font-weight: 500;
    }

    q:before,
    q:after {
        content: '';
    }

    /* 统一上标和下标 */
    sub,
    sup {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
    }

    sup {
        top: -0.5em;
    }

    sub {
        bottom: -0.25em;
    }

    /* 正常链接 未访问 */
    /* 鼠标悬停 */
    a:hover {
        text-decoration: underline;
    }

    /* 默认不显示下划线，保持页面简洁 */
    ins,
    a {
        text-decoration: none;
    }

    /**
 * 通用栅格生成器makeGrid
 * 视觉规范地址：http://demo.alibaba-inc.com/categories/2075/projects/7370/vds/56075
 * @grid-column-width:11rem;//列宽 单位rem
 * @grid-gutter-width:2rem;//槽宽
 * @grid-offset:3rem;//body 2边间距 视觉稿上的列边距
 * @grid-name:grid; 一般为[grid/grid-thin/grid-fat] grid命名 可选视觉规范上的三种
 */
    /**
 * 生成通用栅格（meduim）一般适用于产品首页
 * @grid-column-width:11rem;//列宽 单位rem
 * @grid-gutter-width:2rem;//槽宽
 * @grid-offset:3rem;//body 2边间距 视觉稿上的列边距
 * @grid-name:grid; 一般为[grid/grid-thin/grid-fat] grid命名 可选视觉规范上的三种
 */
    .grid {
        box-sizing: content-box;
        padding-left: 0.3rem;
        padding-right: 0.3rem;
        margin-left: -0.2rem;
    }

    .grid:before,
    .grid:after {
        content: " ";
        display: table;
    }

    .grid:after {
        clear: both;
    }

    .grid [class^="col-"] {
        margin-left: 0.2rem;
        float: left;
    }

    .grid .col-1 {
        width: 1.1rem;
    }

    .grid .col-2 {
        width: 2.4rem;
    }

    .grid .col-3 {
        width: 3.7rem;
    }

    .grid .col-4 {
        width: 5rem;
    }

    .grid .col-5 {
        width: 6.3rem;
    }

    .grid .col-6 {
        width: 7.6000000000000005rem;
    }

    .grid .col-7 {
        width: 8.900000000000002rem;
    }

    .grid .col-8 {
        width: 10.200000000000001rem;
    }

    .grid .col-9 {
        width: 11.500000000000002rem;
    }

    .grid .col-10 {
        width: 12.8rem;
    }

    .grid .col-11 {
        width: 14.100000000000001rem;
    }

    .grid .col-12 {
        width: 15.400000000000002rem;
    }

    /**
 * 生成通用栅格（thin）一般适用于产品列表模块
 * @grid-column-width:9rem;//列宽 单位rem
 * @grid-gutter-width:4rem;//槽宽
 * @grid-offset:4rem;//body 2边间距 视觉稿上的列边距
 * @grid-name:grid; 一般为[grid/grid-thin/grid-fat] grid命名 可选视觉规范上的三种
 */
    .grid-thin {
        box-sizing: content-box;
        padding-left: 0.4rem;
        padding-right: 0.4rem;
        margin-left: -0.4rem;
    }

    .grid-thin:before,
    .grid-thin:after {
        content: " ";
        display: table;
    }

    .grid-thin:after {
        clear: both;
    }

    .grid-thin [class^="col-"] {
        margin-left: 0.4rem;
        float: left;
    }

    .grid-thin .col-1 {
        width: 0.9rem;
    }

    .grid-thin .col-2 {
        width: 2.2rem;
    }

    .grid-thin .col-3 {
        width: 3.5000000000000004rem;
    }

    .grid-thin .col-4 {
        width: 4.8rem;
    }

    .grid-thin .col-5 {
        width: 6.1rem;
    }

    .grid-thin .col-6 {
        width: 7.4rem;
    }

    .grid-thin .col-7 {
        width: 8.7rem;
    }

    .grid-thin .col-8 {
        width: 10rem;
    }

    .grid-thin .col-9 {
        width: 11.299999999999999rem;
    }

    .grid-thin .col-10 {
        width: 12.6rem;
    }

    .grid-thin .col-11 {
        width: 13.9rem;
    }

    .grid-thin .col-12 {
        width: 15.200000000000001rem;
    }

    /**
 * 生成通用栅格（fat）一般适用于产品列表模块
 * @grid-column-width:9rem;//列宽 单位rem
 * @grid-gutter-width:4rem;//槽宽
 * @grid-offset:4rem;//body 2边间距 视觉稿上的列边距
 * @grid-name:grid; 一般为[grid/grid-thin/grid-fat] grid命名 可选视觉规范上的三种
 */
    .grid-fat {
        box-sizing: content-box;
        padding-left: 0.2rem;
        padding-right: 0.2rem;
        margin-left: 0rem;
    }

    .grid-fat:before,
    .grid-fat:after {
        content: " ";
        display: table;
    }

    .grid-fat:after {
        clear: both;
    }

    .grid-fat [class^="col-"] {
        margin-left: 0rem;
        float: left;
    }

    .grid-fat .col-1 {
        width: 1.3rem;
    }

    .grid-fat .col-2 {
        width: 2.6rem;
    }

    .grid-fat .col-3 {
        width: 3.9000000000000004rem;
    }

    .grid-fat .col-4 {
        width: 5.2rem;
    }

    .grid-fat .col-5 {
        width: 6.5rem;
    }

    .grid-fat .col-6 {
        width: 7.800000000000001rem;
    }

    .grid-fat .col-7 {
        width: 9.1rem;
    }

    .grid-fat .col-8 {
        width: 10.4rem;
    }

    .grid-fat .col-9 {
        width: 11.700000000000001rem;
    }

    .grid-fat .col-10 {
        width: 13rem;
    }

    .grid-fat .col-11 {
        width: 14.3rem;
    }

    .grid-fat .col-12 {
        width: 15.600000000000001rem;
    }
    </style>

    <script src="./text-1_files/zepto.js.下载"></script>
    <script>;
    (function (win, lib) {

        lib.env = lib.env || {};
        /**
         * 版本好
         * @class lib.env~Version
         * @param {String} v - 版本号字符串
         */
        function Version(v) {

            Object.defineProperty(this, 'val', {
                value: v.toString(),
                enumerable: true
            });

            /**
             * 判断是否大于某个版本
             * @method gt
             * @param {String} v - 需要比较的版本号
             * @return {Boolean} 是否大于
             * @instance
             * @memberof Version
             */
            this.gt = function (v) {
                return Version.compare(this, v) > 0;
            };

            /**
             * 判断是否大于等于某个版本
             * @method gte
             * @param {String} v - 需要比较的版本号
             * @return {Boolean} 是否大于等于
             * @instance
             * @memberof Version
             */
            this.gte = function (v) {
                return Version.compare(this, v) >= 0;
            };

            /**
             * 判断是否小于某个版本
             * @method lt
             * @param {String} v - 需要比较的版本号
             * @return {Boolean} 是否小于
             * @instance
             * @memberof Version
             */
            this.lt = function (v) {
                return Version.compare(this, v) < 0;
            };

            /**
             * 判断是否小于等于某个版本
             * @method lte
             * @param {String} v - 需要比较的版本号
             * @return {Boolean} 是否小于等于
             * @instance
             * @memberof Version
             */
            this.lte = function (v) {
                return Version.compare(this, v) <= 0;
            };

            /**
             * 判断是否等于某个版本
             * @method eq
             * @param {String} v - 需要比较的版本号
             * @return {Boolean} 是否等于
             * @instance
             * @memberof Version
             */
            this.eq = function (v) {
                return Version.compare(this, v) === 0;
            };
        };

        /**
         * 返回当前版本字符串
         * @method toString
         * @return {String} 当前版本字符串
         * @instance
         * @memberof Version
         */
        Version.prototype.toString = function () {
            return this.val;
        }

        /**
         * 返回当前版本
         * @method valueOf
         * @return {Boolean} 当前版本
         * @instance
         * @memberof Version
         */
        Version.prototype.valueOf = function () {
            var v = this.val.split('.');
            var r = [];
            for (var i = 0; i < v.length; i++) {
                var n = parseInt(v[i], 10);
                if (isNaN(n)) {
                    n = 0;
                }
                var s = n.toString();
                if (s.length < 5) {
                    s = Array(6 - s.length).join('0') + s;
                }
                r.push(s);
                if (r.length === 1) {
                    r.push('.');
                }
            }
            return parseFloat(r.join(''));
        };

        /**
         * 返回当前版本字符串
         * @method compare
         * @param {String} v1 - 需要比较的版本1
         * @param {String} v2 - 需要比较的版本2
         * @return {Number} 0表示相等，-1表示小于，1表示大于
         * @memberof Version
         */
        Version.compare = function (v1, v2) {
            v1 = v1.toString().split('.');
            v2 = v2.toString().split('.');

            for (var i = 0; i < v1.length || i < v2.length; i++) {
                var n1 = parseInt(v1[i], 10), n2 = parseInt(v2[i], 10);

                if (window.isNaN(n1)) {
                    n1 = 0;
                }
                if (window.isNaN(n2)) {
                    n2 = 0;
                }
                if (n1 < n2) {
                    return -1;
                }
                else if (n1 > n2) {
                    return 1;
                }
            }
            return 0;
        }


        /**
         * 解析和操作版本号
         * @method version
         * @param {string} v - 需要解析的版本号
         * @return {lib.env~Version} Verson实例
         * @memberof lib
         */
        lib.version = function (v) {
            return new Version(v);
        };
    })(window, window['lib'] || (window['lib'] = {}));

    ;
    (function (window, lib) {
        lib.env = lib.env || {};
        var search = window.location.search.replace(/^\?/, '')

        /**
         * 当前URL的查询串键值对
         * @member {Object} params
         * @memberof lib.env
         */
        lib.env.params = {};
        if (search) {
            var params = search.split('&');
            for (var i = 0; i < params.length; i++) {
                params[i] = params[i].split('=');
                try {
                    lib.env.params[params[i][0]] = decodeURIComponent(params[i][1]);
                } catch (e) {
                    lib.env.params[params[i][0]] = params[i][1];
                }
            }
        }

    })(window, window['lib'] || (window['lib'] = {}));
    ;
    (function (window, lib) {
        lib.env = lib.env || {};

        var ua = window.navigator.userAgent;
        var matched;

        if ((matched = ua.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))) {
            /**
             * @type {Object}
             * @memberof lib.env
             * @property {String} name - 操作系统名称，比如Android/AndroidPad/iPhone/iPod/iPad/Windows Phone/unknown等
             * @property {lib.env~Version} version - 操作系统版本号
             * @property {Boolean} isWindowsPhone - 是否是Windows Phone
             * @property {Boolean} isIPhone - 是否是iPhone/iTouch
             * @property {Boolean} isIPad - 是否是iPad
             * @property {Boolean} isIOS - 是否是iOS
             * @property {Boolean} isAndroid - 是否是Android手机
             * @property {Boolean} isAndroidPad - 是否是Android平板
             */
            lib.env.os = {
                name: 'Windows Phone',
                isWindowsPhone: true,
                version: matched[1]
            }
        } else if (!!ua.match(/Safari/) && (matched = ua.match(/Android[\s\/]([\d\.]+)/))) {
            lib.env.os = {
                version: matched[1]
            }

            if ((!!ua.match(/Mobile\s+Safari/))) {
                lib.env.os.name = 'Android';
                lib.env.os.isAndroid = true;
            } else {
                lib.env.os.name = 'AndroidPad';
                lib.env.os.isAndroidPad = true;
            }
        } else if ((matched = ua.match(/(iPhone|iPad|iPod)/))) {
            var name = matched[1];

            if ((matched = ua.match(/OS ([\d_\.]+) like Mac OS X/))) {
                lib.env.os = {
                    name: name,
                    isIPhone: (name === 'iPhone' || name === 'iPod'),
                    isIPad: name === 'iPad',
                    isIOS: true,
                    version: matched[1].split('_').join('.')
                }
            }
        }

        if (!lib.env.os) {
            lib.env.os = {
                name: 'unknown',
                version: '0.0.0'
            }
        }

        if (lib.version) {
            lib.env.os.version = lib.version(lib.env.os.version);
        }

    })(window, window['lib'] || (window['lib'] = {}));

    ;
    (function (window, lib) {
        lib.env = lib.env || {};

        var ua = window.navigator.userAgent;
        var matched;

        if ((matched = ua.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/))) {
            /**
             * @type {Object}
             * @memberof lib.env
             * @property {String} name - 浏览器名称，比如UC/QQ/Firefox/Chrome/Android/Safari/iOS Webview/Chrome Webview/IE/IEMobile/unknown等
             * @property {lib.env~Version} version - 浏览器版本号
             * @property {Boolean} isUC - 是否是UC浏览器
             * @property {Boolean} isQQ - 是否是QQ浏览器
             * @property {Boolean} isIE - 是否是IE浏览器
             * @property {Boolean} isIEMobile - 是否是IE移动版浏览器
             * @property {Boolean} isIELikeWebkit - 是否是IE兼容了Webkit特性的浏览器
             * @property {Boolean} isChrome - 是否是Chrome浏览器
             * @property {Boolean} isFirefox - 是否是Firefox浏览器
             * @property {Boolean} isAndroid - 是否是Android的原生浏览器
             * @property {Boolean} isSafari - 是否是Safari浏览器
             * @property {Boolean} isWebview - 是否是iOS下的Webview或Android下Chrome的Webview
             */
            lib.env.browser = {
                name: 'UC',
                isUC: true,
                version: matched[1]
            }
        } else if ((matched = ua.match(/MQQBrowser\/([\d\.]+)/))) {
            lib.env.browser = {
                name: 'QQ',
                isQQ: true,
                version: matched[1]
            }
        } else if ((matched = ua.match(/(?:Firefox|FxiOS)\/([\d\.]+)/))) {
            lib.env.browser = {
                name: 'Firefox',
                isFirefox: true,
                version: matched[1]
            }
        } else if ((matched = ua.match(/MSIE\s([\d\.]+)/)) ||
                (matched = ua.match(/IEMobile\/([\d\.]+)/))) {

            lib.env.browser = {
                version: matched[1]
            }

            if (ua.match(/IEMobile/)) {
                lib.env.browser.name = 'IEMobile';
                lib.env.browser.isIEMobile = true;
            } else {
                lib.env.browser.name = 'IE';
                lib.env.browser.isIE = true;
            }

            if (ua.match(/Android|iPhone/)) {
                lib.env.browser.isIELikeWebkit = true;
            }
        } else if ((matched = ua.match(/(?:Chrome|CriOS)\/([\d\.]+)/))) {
            lib.env.browser = {
                name: 'Chrome',
                isChrome: true,
                version: matched[1]
            }

            if (ua.match(/Version\/[\d+\.]+\s*Chrome/)) {
                lib.env.browser.name = 'Chrome Webview';
                lib.env.browser.isWebview = true;
            }
        } else if (!!ua.match(/Safari/) && (matched = ua.match(/Android[\s\/]([\d\.]+)/))) {
            lib.env.browser = {
                name: 'Android',
                isAndroid: true,
                version: matched[1]
            }
        } else if (ua.match(/iPhone|iPad|iPod/)) {
            if (ua.match(/Safari/) && (matched = ua.match(/Version\/([\d\.]+)/))) {
                lib.env.browser = {
                    name: 'Safari',
                    isSafari: true,
                    version: matched[1]
                }
            } else if ((matched = ua.match(/OS ([\d_\.]+) like Mac OS X/))) {
                lib.env.browser = {
                    name: 'iOS Webview',
                    isWebview: true,
                    version: matched[1].replace(/\_/g, '.')
                }
            }
        }

        if (!lib.env.browser) {
            lib.env.browser = {
                name: 'unknown',
                version: '0.0.0'
            }
        }

        if (lib.version) {
            lib.env.browser.version = lib.version(lib.env.browser.version);
        }

    })(window, window['lib'] || (window['lib'] = {}));
    ;
    (function (window, lib) {
        lib.env = lib.env || {};

        var ua = window.navigator.userAgent;
        var matched;

        if (!!ua.match(/Weibo/i)) {
            /**
             * @type {Object}
             * @memberof lib.env
             * @property {String} appname - 操作系统名称，比如Weibo/Weixin/unknown等
             * @property {Boolean} isWeibo - 是否是微博
             * @property {Boolean} isWeixin - 是否是微信
             */
            lib.env.thirdapp = {
                appname: 'Weibo',
                isWeibo: true
            }
        } else if (!!ua.match(/MicroMessenger/i)) {
            lib.env.thirdapp = {
                appname: 'Weixin',
                isWeixin: true
            }
        } else {
            lib.env.thirdapp = false;
        }
    })(window, window['lib'] || (window['lib'] = {}));
    ;
    (function (window, lib) {
        lib.env = lib.env || {};

        var ua = window.navigator.userAgent;

        var windvane;
        var matched;
        if ((matched = ua.match(/WindVane[\/\s]([\d\.\_]+)/))) {
            windvane = matched[1];
        }

        var aliapp = false;
        var appname = '';
        var platform = '';
        var version = '';

        // poplayer相关信息，在poplayer会有该字段，形如 window._ua_popLayer = 'PopLayer/1.3.4'
        // poplayer信息不在ua中是因为在IOS下，修改poplayer层的ua会导致所有webview的ua改变，所以只能写在全局变量中
        var poplayerInfo = window._ua_popLayer || '';
        var poplayer = false;
        var poplayerVersion = '';
        if ((matched = ua.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i))) {
            aliapp = true;
            appname = matched[1];
            version = matched[2];
            if (appname.indexOf('-PD') > 0) {
                if (lib.env.os.isIOS) {
                    platform = 'iPad';
                } else if (lib.env.os.isAndroid) {
                    platform = 'AndroidPad';
                } else {
                    platform = lib.env.os.name;
                }
            } else {
                platform = lib.env.os.name;
            }
        }

        // 兼容手淘的一个bug，在webview初始化异常时，在ua中只包含TBIOS字样，也认为是手淘webview。
        if (!appname && ua.indexOf('TBIOS') > 0) {
            appname = 'TB';
        }

        // 判断poplayer
        if (poplayerInfo && (matched = poplayerInfo.match(/PopLayer\/([\d\.]+)/i))) {
            poplayer = true;
            poplayerVersion = matched[1];
        }

        if (aliapp) {
            /**
             * @type {Object}
             * @memberof lib.env
             * @property {lib.env~Version} windavne - windvane的版本
             * @property {String} appname - App的名称，比如TB/TM等
             * @property {lib.env~Version} poplayerVersion - poplayer的版本
             * @property {Boolean} poplayer - 是否在poplayer中，默认为false
             * @property {lib.env~Version} version - 客户端的版本
             * @property {String} platform - 平台名称，比如iPhone/iPad/Android/AndroidPad等
             */
            lib.env.aliapp = {
                windvane: lib.version(windvane || '0.0.0'),
                appname: appname || 'unkown',
                version: lib.version(version || '0.0.0'),
                platform: platform || lib.env.os.name,
                poplayer: poplayer || false,
                poplayerVersion: lib.version(poplayerVersion || '0.0.0')
            }
        } else {
            lib.env.aliapp = false;
        }

        // 向下兼容老版本
        lib.env.taobaoApp = lib.env.aliapp;

    })(window, window['lib'] || (window['lib'] = {}));

    /**
     * @namespace lib
     */

    /**
     * @namespace env
     * @memberOf lib
     */
    </script>
    <script>;
    (function (win, lib) {
        var PROTOCAL = [
            'http', 'https', 'taobao', 'taobaowebview', 'taobaohd', 'tmall', 'kddcpublic', 'mdatadwphone'
        ];

        /**
         * 解析和操作url
         * @class HttpURL
         * @param {string} url - 需要解析和操作的url
         */
        function HttpURL(url) {
            var params = {};

            /**
             * 查询串键值对
             * @prop {Object} params
             * @memberof HttpURL
             * @instance
             */
            Object.defineProperty(this, 'params', {
                set: function (v) {
                    if (typeof v === 'object') {
                        for (var p in params) {
                            delete params[p];
                        }
                        for (var p in v) {
                            params[p] = v[p];
                        }
                    }
                },
                get: function () {
                    return params;
                },
                enumerable: true
            });

            Object.defineProperty(this, 'search', {
                set: function (v) {
                    if (typeof v === 'string') {
                        if (v.indexOf('?') === 0) {
                            v = v.substr(1);
                        }
                        var search = v.split('&');
                        for (var p in params) {
                            delete params[p];
                        }
                        for (var i = 0; i < search.length; i++) {
                            var pair = search[i].split('=');
                            if (pair[0]) {
                                try {
                                    params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
                                } catch (e) {
                                    params[pair[0]] = pair[1] || '';
                                }
                            }
                        }
                    }
                },
                get: function () {
                    var search = [];
                    for (var p in params) {
                        if (params[p]) {
                            try {
                                search.push(encodeURIComponent(p) + '=' + encodeURIComponent(params[p]));
                            } catch (e) {
                                search.push(p + '=' + params[p]);
                            }
                        } else {
                            try {
                                search.push(encodeURIComponent(p));
                            } catch (e) {
                                search.push(p);
                            }
                        }
                    }
                    if (search.length) {
                        return '?' + search.join('&');
                    } else {
                        return '';
                    }

                },
                enumerable: true
            });

            var hash;
            Object.defineProperty(this, 'hash', {
                set: function (v) {
                    if (v && v.indexOf('#') < 0) {
                        v = '#' + v;
                    }
                    hash = v || '';
                },
                get: function () {
                    return hash;
                },
                enumerable: true
            });

            this.set = function (v) {
                v = v || '';
                var matchArr;
                if ((matchArr = v.match(new RegExp('^([a-z0-9-]+\:)?' +    //protocol
                                '[/]{2}' +                            //slash x 2
                                '(?:([^@/:\?]+)(?::([^@/:]+))?@)?' +  //username:password@
                                '([^:/?#]+)' +                        //hostname
                                '(?:[:]([0-9]+))?' +                  //port
                                '([/][^?#;]*)?' +                     //pathname
                                '(?:[?]([^?#]*))?' +                  //search
                                '(#[^#]*)?$'                          //hash
                                , 'i')))) {
                    /**
                     * 协议头
                     * @member {String} protocol
                     * @memberof HttpURL
                     * @instance
                     */
                    this.protocol = matchArr[1] || location.protocol;
                    /**
                     * 用户名
                     * @member {String} username
                     * @memberof HttpURL
                     * @instance
                     */
                    this.username = matchArr[2] || '';
                    /**
                     * 密码
                     * @member {String} password
                     * @memberof HttpURL
                     * @instance
                     */
                    this.password = matchArr[3] || '';
                    /**
                     * 主机名
                     * @member {String} hostname
                     * @memberof HttpURL
                     * @instance
                     */
                    /**
                     * 主机名
                     * @member {String} host
                     * @memberof HttpURL
                     * @instance
                     */
                    this.hostname = this.host = matchArr[4];
                    /**
                     * 端口
                     * @member {String} port
                     * @memberof HttpURL
                     * @instance
                     */
                    this.port = matchArr[5] || '';
                    /**
                     * 路径
                     * @member {String} pathname
                     * @memberof HttpURL
                     * @instance
                     */
                    this.pathname = matchArr[6] || '/';
                    /**
                     * 查询串
                     * @member {String} search
                     * @memberof HttpURL
                     * @instance
                     */
                    this.search = matchArr[7] || '';
                    /**
                     * 锚点串
                     * @member {String} hash
                     * @memberof HttpURL
                     * @instance
                     */
                    this.hash = matchArr[8] || '';
                    /**
                     * 地址源
                     * @member {String} origin
                     * @memberof HttpURL
                     * @instance
                     */
                    this.origin = this.protocol + '//' + this.hostname;
                } else {
                    throw new Error('Wrong uri scheme.');
                }
            }

            /**
             * 查询串键值对
             * @method toString
             * @return {String} 完整URL地址
             * @memberof HttpURL
             * @instance
             */
            this.toString = function () {
                var string = this.protocol + '//';
                if (this.username) {
                    string += this.username;
                    if (this.password) {
                        string += ':' + this.password;
                    }
                    string += '@';
                }
                string += this.host;
                if (this.port && this.port !== '80') {
                    string += ':' + this.port;
                }
                if (this.pathname) {
                    string += this.pathname;
                }
                if (this.search) {
                    string += this.search;
                }
                if (this.hash) {
                    string += this.hash;
                }
                return string;
            }

            if (url) {
                this.set(url.toString());
            }
        }

        /**
         * @namespace lib
         */

        /**
         * 解析和操作url
         * @method httpurl
         * @param {string} url - 需要解析和操作的url
         * @return {HttpURL} HttpURL实例
         * @memberof lib
         */
        lib.httpurl = function (url) {
            return new HttpURL(url);
        }
    })(window, window['lib'] || (window['lib'] = {}));
    </script>
    <script>;
    (function (win, lib) {
        var Promise = win.Promise;
        var doc = win.document;
        var ua = win.navigator.userAgent;
        var isWin = (/Windows\sPhone\s(?:OS\s)?[\d\.]+/i).test(ua) || (/Windows\sNT\s[\d\.]+/i).test(ua);
        var isWinWV = isWin && win['WindVane_Win_Private'] && win['WindVane_Win_Private'].call;
        var isIOS = (/iPhone|iPad|iPod/i).test(ua);
        var isAndroid = (/Android/i).test(ua);
        var wvVersion = ua.match(/WindVane[\/\s](\d+[._]\d+[._]\d+)/);
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var WindVane = lib.windvane = win.WindVane || (win.WindVane = {});
        var WindVane_Native = win.WindVane_Native;
        var inc = 1, iframePool = [], iframeLimit = 3;

        var LOCAL_PROTOCOL = 'hybrid';
        var WV_PROTOCOL = 'wv_hybrid';
        var IFRAME_PREFIX = 'iframe_';
        var SUCCESS_PREFIX = 'suc_';
        var FAILURE_PREFIX = 'err_';
        var DEFERRED_PREFIX = 'defer_';
        var PARAM_PREFIX = 'param_';
        var CHUNK_PREFIX = 'chunk_';
        var CALL_GC_TIME = 60 * 1000 * 10;
        var CHUNK_GC_TIME = 60 * 1000 * 10;
        var PARAM_GC_TIME = 60 * 1000;

        function compareVersion(v1, v2) {
            v1 = v1.toString().split('.');
            v2 = v2.toString().split('.');

            for (var i = 0; i < v1.length || i < v2.length; i++) {
                var n1 = parseInt(v1[i], 10), n2 = parseInt(v2[i], 10);

                if (window.isNaN(n1)) {
                    n1 = 0;
                }
                if (window.isNaN(n2)) {
                    n2 = 0;
                }
                if (n1 < n2) {
                    return -1;
                }
                else if (n1 > n2) {
                    return 1;
                }
            }
            return 0;
        }

        if (wvVersion) {
            wvVersion = (wvVersion[1] || '0.0.0').replace(/\_/g, '.');
        } else {
            wvVersion = '0.0.0';
        }

        /**
         * @namespace  lib
         */

        /**
         * @namespace windvane
         * @memberOf lib
         */

        var WV_Core = {
            isAvailable: compareVersion(wvVersion, '0') === 1,

            /**
             * @method  call
             * @memberOf lib.windvane
             * @param  {String} obj       要调用的客户端类名
             * @param  {String} method    要调用的客户端方法名
             * @param  {Object} params    要传递给客户端的参数
             * @param  {Function} [success] 执行成功后的回调
             * @param  {Function} [failure] 执行失败后的回调
             * @param  {Number} [timeout]   执行超时，超时后自动以 {ret:['HY_TIMEOUT']}
             * @return {Promise}          如果当前运行环境支持Promise，则返回一个Promise实例。
             */
            call: function (obj, method, params, success, failure, timeout) {
                var sid;
                var deferred;

                if (typeof arguments[arguments.length - 1] === 'number') {
                    timeout = arguments[arguments.length - 1];
                }

                if (typeof success !== 'function') {
                    success = null;
                }

                if (typeof failure !== 'function') {
                    failure = null;
                }

                if (Promise) {
                    deferred = {};
                    deferred.promise = new Promise(function (resolve, reject) {
                        deferred.resolve = resolve;
                        deferred.reject = reject;
                    });
                }

                if (timeout > 0) {
                    sid = setTimeout(function () {
                        WV_Core.onFailure(sid, {ret: 'HY_TIMEOUT'});
                    }, timeout);
                } else {
                    sid = WV_Private.getSid();
                }

                WV_Private.registerCall(sid, success, failure, deferred);
                WV_Private.registerGC(sid, timeout);
                WV_Private.callMethod(obj, method, params, sid);

                if (deferred) {
                    return deferred.promise;
                }
            },

            fireEvent: function (eventname, eventdata, sid) {
                // 当native需要通知js的时候（通信），用触发事件的方式进行
                var ev = doc.createEvent('HTMLEvents');
                ev.initEvent(eventname, false, true);
                ev.param = WV_Private.parseData(eventdata || WV_Private.getData(sid));

                doc.dispatchEvent(ev);
            },

            getParam: function (sid) {
                return WV_Private.getParam(sid);
            },

            setData: function (sid, chunk) {
                WV_Private.setData(sid, chunk);
            },

            onSuccess: function (sid, data) {
                // native代码处理成功后，调用该方法来通知js
                WV_Private.onComplete(sid, data, 'success');
            },

            onFailure: function (sid, data) {
                // native代码处理失败后，调用该方法来通知js
                WV_Private.onComplete(sid, data, 'failure');
            }
        };

        var WV_Private = {
            params: {},
            chunks: {},
            calls: {},

            getSid: function () {
                return Math.floor(Math.random() * (1 << 50)) + '' + inc++;
            },

            buildParam: function (obj) {
                if (obj && typeof obj === 'object') {
                    return JSON.stringify(obj);
                } else {
                    return obj || '';
                }
            },

            getParam: function (sid) {
                // 因为ios下iframe协议，对于url长度有限制，所以增加一个参数的map。
                return this.params[PARAM_PREFIX + sid] || '';
            },

            setParam: function (sid, params) {
                this.params[PARAM_PREFIX + sid] = params;
            },

            parseData: function (str) {
                var rst;
                if (str && typeof str === 'string') {
                    try {
                        rst = JSON.parse(str);
                    } catch (e) {
                        rst = {ret: ['WV_ERR::PARAM_PARSE_ERROR']};
                    }
                } else {
                    rst = str || {};
                }

                return rst;
            },

            setData: function () {
                // android下，回传函数会超长，通过分段set的方式来传递
                this.chunks[CHUNK_PREFIX + sid] = this.chunks[CHUNK_PREFIX + sid] || [];
                this.chunks[CHUNK_PREFIX + sid].push(chunk);
            },

            getData: function (sid) {
                if (this.chunks[CHUNK_PREFIX + sid]) {
                    return this.chunks[CHUNK_PREFIX + sid].join('');
                } else {
                    return '';
                }
            },

            registerCall: function (sid, success, failure, deferred) {
                if (success) {
                    this.calls[SUCCESS_PREFIX + sid] = success;
                }

                if (failure) {
                    this.calls[FAILURE_PREFIX + sid] = failure;
                }

                if (deferred) {
                    this.calls[DEFERRED_PREFIX + sid] = deferred;
                }
            },

            unregisterCall: function (sid) {
                var sucId = SUCCESS_PREFIX + sid;
                var failId = FAILURE_PREFIX + sid;
                var defId = DEFERRED_PREFIX + sid;
                var call = {};

                if (this.calls[sucId]) {
                    call.success = this.calls[sucId];
                    delete this.calls[sucId];
                }
                if (this.calls[failId]) {
                    call.failure = this.calls[failId];
                    delete this.calls[failId];
                }
                if (this.calls[defId]) {
                    call.deferred = this.calls[defId];
                    delete this.calls[defId];
                }

                return call;
            },

            useIframe: function (sid, url) {
                var iframeid = IFRAME_PREFIX + sid;
                var iframe = iframePool.pop();

                if (!iframe) {
                    iframe = doc.createElement('iframe');
                    iframe.setAttribute('frameborder', '0');
                    iframe.style.cssText = 'width:0;height:0;border:0;display:none;';
                }

                iframe.setAttribute('id', iframeid);
                iframe.setAttribute('src', url);

                if (!iframe.parentNode) {
                    setTimeout(function () {
                        doc.body.appendChild(iframe);
                    }, 5);
                }
            },

            retrieveIframe: function (sid) {
                var iframeid = IFRAME_PREFIX + sid;
                var iframe = doc.querySelector('#' + iframeid);

                if (iframePool.length >= iframeLimit) {
                    doc.body.removeChild(iframe);
                } else {
                    iframePool.push(iframe);
                }
            },

            callMethod: function (obj, method, params, sid) {
                // hybrid://objectName:sid/methodName?params
                params = WV_Private.buildParam(params);

                if (isWin) {
                    if (isWinWV) {
                        win['WindVane_Win_Private'].call(obj, method, sid, params);
                    } else {
                        this.onComplete(sid, {ret: 'HY_NO_HANDLER_ON_WP'}, 'failure');
                    }
                } else {
                    var uri = LOCAL_PROTOCOL + '://' + obj + ':' + sid + '/' + method + '?' + params;

                    if (isIOS) {
                        // iOS下用iframe调用
                        this.setParam(sid, params);
                        this.useIframe(sid, uri);
                    } else if (isAndroid) {
                        // Android下用window.prompt调用调用
                        var value = WV_PROTOCOL + ':';
                        window.prompt(uri, value);
                    } else {
                        this.onComplete(sid, {ret: 'HY_NOT_SUPPORT_DEVICE'}, 'failure');
                    }
                }
            },

            registerGC: function (sid, timeout) {
                // 垃圾回收
                var that = this;
                var callGCTime = Math.max(timeout || 0, CALL_GC_TIME);
                var paramGCTime = Math.max(timeout || 0, PARAM_GC_TIME);
                var chunkGCTime = Math.max(timeout || 0, CHUNK_GC_TIME);

                setTimeout(function () {
                    that.unregisterCall(sid);
                }, callGCTime);

                if (isIOS) {
                    // ios下处理params的回收
                    setTimeout(function () {
                        if (that.params[PARAM_PREFIX + sid]) {
                            delete that.params[PARAM_PREFIX + sid];
                        }
                    }, paramGCTime);
                } else if (isAndroid) {
                    // android下处理chunk的回收
                    setTimeout(function () {
                        if (that.chunks[CHUNK_PREFIX + sid]) {
                            delete that.chunks[CHUNK_PREFIX + sid];
                        }
                    }, chunkGCTime);
                }
            },

            onComplete: function (sid, data, type) {
                clearTimeout(sid);

                var call = this.unregisterCall(sid);
                var success = call.success;
                var failure = call.failure;
                var deferred = call.deferred;

                data = data ? data : this.getData(sid);
                data = this.parseData(data);

                var ret = data.ret;
                if (typeof ret === 'string') {
                    data = data.value || data;
                    if (!data.ret) {
                        data.ret = [ret];
                    }
                }

                if (type === 'success') {
                    success && success(data);
                    deferred && deferred.resolve(data);
                } else if (type === 'failure') {
                    failure && failure(data);
                    deferred && deferred.reject(data);
                }

                if (isIOS) {    //iOS下回收iframe
                    this.retrieveIframe(sid);
                    if (this.params[PARAM_PREFIX + sid]) {
                        delete this.params[PARAM_PREFIX + sid];
                    }
                } else if (isAndroid) {
                    if (this.chunks[CHUNK_PREFIX + sid]) {
                        delete this.chunks[CHUNK_PREFIX + sid];
                    }
                }
            }
        };

        for (var key in WV_Core) {
            if (!hasOwnProperty.call(WindVane, key)) {
                WindVane[key] = WV_Core[key];
            }
        }
    })(window, window['lib'] || (window['lib'] = {}))
    </script>
    <script>;
    (function (win, lib) {
        var doc = win.document;
        var loc = win.location;

        function createImg(url) {
            var img = doc.createElement('img');
            img.style.cssText = 'display:none';
            img.src = url;
            doc.body.appendChild(img);
        }

        function aplus(options) {
            options = options || {};

            var params = {}
            var apname = options.apname || options.ap_name;
            var apuri = options.apuri || options.ap_uri;
            var apdata = options.apdata || options.ap_data;

            if (!apname) return;

            if (apuri) {
                params['apuri'] = apuri;
            }
            if (apdata) {
                for (var k in apdata) {
                    params[k] = apdata[k];
                }
            }
            params['cache'] = parseInt((Math.random() + 1) * Date.now());   //随机数

            var search = [];
            for (var name in params) {
                var val = params[name];
                if (typeof val === 'object') {
                    val = JSON.stringify(val);
                }
                search.push(name + '=' + encodeURIComponent(val));
            }

            createImg('http://wgo.mmstat.com/' + apname + '?' + search.join('&'));
        }

        if (window['Zepto']) {
            var ajax = Zepto.ajax;
            Zepto.ajax = function (options) {
                if (!options) return;

                var complete = options.complete;

                options.complete = function () {
                    if (options.aplus === true || options.apname) {
                        aplus(options);
                    }
                    complete && complete.apply(this, arguments);
                }

                if (options.url) {
                    ajax.call(Zepto, options);
                } else {
                    options.complete();
                }
            }
        }

        lib.aplus = aplus;
    })(window, window['lib'] || (window['lib'] = {}))</script>
    <script>;
    (function (win, lib, undef) {
        function md5(string) {
            function rotateLeft(lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            }

            function addUnsigned(lX, lY) {
                var lX4, lY4, lX8, lY8, lResult;
                lX8 = (lX & 0x80000000);
                lY8 = (lY & 0x80000000);
                lX4 = (lX & 0x40000000);
                lY4 = (lY & 0x40000000);
                lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                if (lX4 & lY4) {
                    return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                }
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) {
                        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                    } else {
                        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    }
                } else {
                    return (lResult ^ lX8 ^ lY8);
                }
            }

            function f(x, y, z) {
                return (x & y) | ((~x) & z);
            }

            function g(x, y, z) {
                return (x & z) | (y & (~z));
            }

            function h(x, y, z) {
                return (x ^ y ^ z);
            }

            function i(x, y, z) {
                return (y ^ (x | (~z)));
            }

            function FF(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function GG(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function HH(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function II(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function convertToWordArray(string) {
                var lWordCount;
                var lMessageLength = string.length;
                var lNumberOfWords_temp1 = lMessageLength + 8;
                var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                var lWordArray = new Array(lNumberOfWords - 1);
                var lBytePosition = 0;
                var lByteCount = 0;
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
                    lByteCount++;
                }
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                return lWordArray;
            }

            function wordToHex(lValue) {
                var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255;
                    WordToHexValue_temp = "0" + lByte.toString(16);
                    WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
                }
                return WordToHexValue;
            }

            function utf8Encode(string) {
                string = string.replace(/\r\n/g, "\n");
                var utftext = "";

                for (var n = 0; n < string.length; n++) {

                    var c = string.charCodeAt(n);

                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    }
                    else if ((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                    else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }

                }

                return utftext;
            }

            var x = [],
                    k, AA, BB, CC, DD, a, b, c, d,
                    S11 = 7, S12 = 12, S13 = 17, S14 = 22,
                    S21 = 5, S22 = 9, S23 = 14, S24 = 20,
                    S31 = 4, S32 = 11, S33 = 16, S34 = 23,
                    S41 = 6, S42 = 10, S43 = 15, S44 = 21;

            string = utf8Encode(string);

            x = convertToWordArray(string);

            a = 0x67452301;
            b = 0xEFCDAB89;
            c = 0x98BADCFE;
            d = 0x10325476;

            for (k = 0; k < x.length; k += 16) {
                AA = a;
                BB = b;
                CC = c;
                DD = d;
                a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
                b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
                b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
                d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
                d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
                c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
                b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
                c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
                c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
                c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
                d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
                b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = addUnsigned(a, AA);
                b = addUnsigned(b, BB);
                c = addUnsigned(c, CC);
                d = addUnsigned(d, DD);
            }

            var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

            return temp.toLowerCase();
        }

        function appendScript(script) {
            var el = doc.getElementsByTagName('head')[0] ||
                    doc.getElementsByTagName('body')[0] ||
                    doc.firstElementChild || doc;
            el.appendChild(script);
        }

        function readCookie(name) {
            var matched = new RegExp('(?:^|;\\s*)' + name + '\\=([^;]+)(?:;\\s*|$)').exec(doc.cookie);
            if (matched) {
                return matched[1];
            } else {
                return undef;
            }
        }

        function delCookie(name) {
            var now = new Date();
            now.setTime(now.getTime() - 86400 * 1000);
            var path = '/';
            doc.cookie = name + '=;path=' + path + ';domain=.' + config.mainDomain + ';expires=' + now.toGMTString();
            doc.cookie = name + '=;path=' + path + ';domain=.' + config.subDomain + '.' + config.mainDomain + ';expires=' + now.toGMTString();
        }

        var doc = win.document;
        var ua = win.navigator.userAgent;
        var hostname = win.location.hostname;
        var WindVaneVersion = ua.match(/WindVane[\/\s]([\d\.\_]+)/);
        if (WindVaneVersion) {
            WindVaneVersion = WindVaneVersion[1];
        }
        var AliApp = ua.match(/AliApp\(([^\/]+)\/([\d\.\_]+)\)/i);
        var AliAppName, AliAppVersion;
        if (AliApp) {
            AliAppName = AliApp[1];
            AliAppVersion = AliApp[2];
        }

        var SUPPORT_HOST = [
            'taobao.net',
            'taobao.com',
            'tmall.com',
            'tmall.hk',
            'etao.com',
            'alibaba.com',
            'alibaba-inc.com',
            'alipay.com',
            'aliyun.com',
            'tdd.la'
        ];
        var HOST_REGEXP = new RegExp('([^.]*?)\\.?((?:' + SUPPORT_HOST.join(')|(?:').replace(/\./g, '\\.') + '))', 'i');
        var matchedHost = hostname.match(HOST_REGEXP) || [];
        var MAIN_DOMAIN = (function () {
            var host = matchedHost[2] || 'taobao.com';
            return host;
        })();
        var SUB_DOMAIN = (function () {
            var host = MAIN_DOMAIN;
            var type = matchedHost[1] || 'm';
            if (host === 'taobao.net' && (type === 'x' || type === 'waptest' || type === 'daily')) {
                type = 'waptest';
            } else if (host === 'taobao.net' && type === 'demo') {
                type = 'demo';
            } else if (host === 'tmall.com' && type === 'www') {
                type = 'm';
            } else if (host === 'tdd.la' && type === 'm') {
                type = '';
            }
            return type;
        })();
        var PREFIX = MAIN_DOMAIN === 'etao.com' ? 'apie' : 'api';

        /**
         * @namespace lib
         */
        /**
         * @namespace mtop
         * @memberof lib
         */
        lib.mtop = lib.mtop || {};
        /**
         * @member config
         * @memberof lib.mtop
         * @property {String} prefix mtop请求地址前缀
         * @property {String} mainDomain mtop请求地址主域，例如：taobao.com/tmall.com
         * @property {String} subDomain mtop请求地址主域，例如：m/wapa/waptest
         * @property {String} H5Request 强制用H5的请求，在手淘和天猫中默认为false，其它为true
         * @property {String} LoginRequest 强制发起登录验证的请求
         * @property {String} AntiCreep 强制发起防爬验证的请求
         * @property {String} AntiFlood 强制发起防刷验证的请求
         */
        var config = {
            prefix: PREFIX,
            mainDomain: MAIN_DOMAIN,
            subDomain: SUB_DOMAIN,
            useAlipayJSBridge: false,   // 默认不使用支付宝的JSBridge获得token
            H5Request: !(AliAppName === 'TB' || AliAppName === 'TM'), // 默认除了手淘和天猫，其它强制用H5的请求
            LoginRequest: false,
            AntiCreep: false,
            AntiFlood: false
        }
        lib.mtop.config = config;

        /**
         * @enum {Object}
         * @readonly
         * @memberof lib.mtop
         */
        var RESPONSE_TYPE = {
            /**
             * @description 请求出错
             * @type {Number}
             */
            'ERROR': -1,
            /**
             * @description 请求成功
             * @type {Number}
             */
            'SUCCESS': 0,
            /**
             * @description 请求token过期
             * @type {Number}
             */
            'TOKEN_EXPIRED': 1,
            /**
             * @description 请求session过期
             * @type {Number}
             */
            'SESSION_EXPIRED': 2
        }
        lib.mtop.RESPONSE_TYPE = RESPONSE_TYPE;

        var APP_KEY = 'J_app_key';

        function getAppKey() {
            var el = doc.getElementById('J_app_key');
            if (el) {
                return el.value;
            } else {
                return (config.subDomain === 'waptest' ? '4272' : '12574478');
            }
        }

        var TOKEN_KEY = '_m_h5_tk';
        var TOKEN_KEY_ENC = '_m_h5_tk_enc';
        var ALIPAY_VER = ua.match(/AliApp\(AP\/([\d\.]+)\)/);
        var IS_ONLINE = !!location.protocol.match(/^https?\:$/);
        var IS_ALIPAY = ALIPAY_VER && parseFloat(ALIPAY_VER[1]) >= 8.2;

        function getToken(callback) {
            function handler(val) {
                if (val) {
                    val = val.split('_')[0];
                } else {
                    val = '';
                }
                callback(val);
            }

            if (config.useAlipayJSBridge === true && !IS_ONLINE && IS_ALIPAY && win.AlipayJSBridge && win.AlipayJSBridge.call) {
                // 支付宝客户端（8.2以上），需要调用客户端提供的js来获得.taobao.com域下的cookie
                win.AlipayJSBridge.call('getMtopToken', function (json) {
                    if (json && json.token) {
                        handler(json.token);
                    } else {
                        handler(readCookie(TOKEN_KEY));
                    }
                }, function () {
                    handler(readCookie(TOKEN_KEY));
                });
            } else {
                handler(readCookie(TOKEN_KEY));
            }
        }

        function delToken() {
            delCookie(TOKEN_KEY);
            delCookie(TOKEN_KEY_ENC);
        }

        function signature(str, t, callback) {
            getToken(function (token) {
                var sign = md5(token + '&' + t + "&" + getAppKey() + "&" + str);
                callback(sign);
            });
        }

        function genApiUrl(params, callback) {
            //判断单元化前缀
            var unitPrefix = getUnitApiPrefix(params.api);

            var path = '//' +
                    (unitPrefix ? unitPrefix + '.' : '') +
                    (config.prefix ? config.prefix + '.' : '') +
                    (config.subDomain ? config.subDomain + '.' : '') +
                    config.mainDomain +
                    '/h5/' + params.api.toLowerCase() + '/' + params.v.toLowerCase() + '/';

            var t = new Date().getTime();
            var querystring = ['v', 'api', 'ttid', 'sprefer', 'appKey=' + getAppKey(), 't=' + t];
            var postdata = ['data', 'ua']

            if (params.isRequestJsonpByGet) {
                querystring.push('callback=jsonpCallback');
                querystring.push('type=jsonp');
            } else if (params.isRequestJsonByGet || params.isRequestJsonByPost) {
                querystring.push('type=originaljson');
            }

            function copyParam(arr) {
                for (var i = 0; i < arr.length;) {
                    var key = arr[i];
                    if (key.match(/^[^=]+$/)) {
                        if (params[key]) {
                            arr[i++] += '=' + encodeURIComponent(params[key]);
                        } else {
                            arr.splice(i, 1);
                        }
                    } else {
                        i++;
                    }
                }
            }

            signature(params.data, t, function (sign) {
                querystring.push('sign=' + sign);

                copyParam(querystring);
                copyParam(postdata);

                callback({
                    path: path,
                    querystring: querystring.join('&'),
                    postdata: postdata.join('&')
                });
            });
        }

        var jsonpInc = 1;
//mtop jsonp 请求方法
        function requestJsonp(url, callback, params) {

            function cleanup(type) {
                timeoutid && clearTimeout(timeoutid);
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
                if (type === 'TIMEOUT') {
                    window[callbackName] = function () {
                        window[callbackName] = undef;
                        try {
                            delete window[callbackName];
                        } catch (e) {
                        }
                    }
                } else {
                    window[callbackName] = undef;
                    try {
                        delete window[callbackName];
                    } catch (e) {
                    }
                }
            }

            var timeout = params.timeout || 20000;
            var callbackName = 'mtopjsonp' + jsonpInc++;
            var timeoutid = setTimeout(function () {
                cleanup('TIMEOUT');
                callback({ret: ['TIMEOUT']});
            }, timeout);

            var script = doc.createElement('script');
            script.src = (url.path + '?' + url.querystring + '&' + url.postdata).replace('callback=jsonpCallback', 'callback=' + callbackName);
            script.sync = true;
            script.onerror = function () {
                cleanup('ABORT');
                callback({ret: ['ABORT']});
            };
            window[callbackName] = function () {
                cleanup();
                callback.apply(this, arguments);
            }
            appendScript(script);
        }

//mtop post请求
        var xhrReg = /^\s*$/;

        function requestJson(url, callback, params) {
            var xhr = new win.XMLHttpRequest();
            var timeout = params.timeout || 20000;

            function cleanup(type) {
                timeoutid && clearTimeout(timeoutid);
                if (type === 'TIMEOUT') {
                    xhr.abort();
                }
            }

            var timeoutid = setTimeout(function () {
                cleanup('TIMEOUT');
                callback({ret: ['TIMEOUT']});
            }, timeout);

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    var status = xhr.status;
                    var result;
                    var headers;
                    var error;
                    if ((status >= 200 && status < 300) || status == 304) {
                        result = xhr.responseText;
                        headers = xhr.getAllResponseHeaders() || '';
                        try {
                            result = xhrReg.test(result) ? null : JSON.parse(result);
                        } catch (e) {
                            error = e;
                        }
                        if (error) {
                            callback({ret: ['PARSERERROR'], error: error, responseHeaders: headers});
                        } else {
                            result.responseHeaders = headers;
                            callback(result);
                        }
                    } else {
                        callback({ret: ['ABORT']});
                    }
                    cleanup();
                }
            }

            var curl = url.path + '?' + url.querystring;
            var senddata;

            if (params.isRequestJsonByGet) {
                curl += '&' + url.postdata;
            } else if (params.isRequestJsonByPost) {
                senddata = url.postdata;
            }

            xhr.open(params.type.toUpperCase(), curl, true);
            xhr.withCredentials = true;
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            if (params.headers) {
                for (var key in params.headers) {
                    xhr.setRequestHeader(key, params.headers[key]);
                }
            }

            xhr.send(senddata);
        }

        function send(url, callback, params) {
            if (params.isRequestJsonByPost || params.isRequestJsonByGet) {
                requestJson(url, callback, params);
            } else if (params.isRequestJsonpByGet) {
                requestJsonp(url, callback, params);
            }
        }

//windvane mtop 请求
        function requestWindvaneSecurityProxy(handler, params) {
            var data = JSON.parse(params.data || '{}');
            var api = params.api;
            var v = params.v;
            var post = parseInt(params.type === 'post' ? 1 : 0);
            var ecode = parseInt(params.ecode || 0);
            var isSec = parseInt(params.isSec || 0);
            var timer = parseInt(params.timer || 3000);
            var timeout = parseInt(params.timeout);

            lib.windvane.call('MtopWVPlugin', 'send', {
                api: api,
                v: v,
                post: post,
                ecode: ecode,
                isSec: isSec,
                param: data,
                timer: timer
            }, handler, handler, timeout);
        }

//队列
        var requestQueue = [];

        function sendInQueue(callback, params) {
            requestQueue.push([callback, params]);
            runNextInQueue();
        }

        var isRunning = false;

        function runNextInQueue() {
            if (requestQueue.length && !isRunning) {
                isRunning = true;
                var args = requestQueue.shift();
                var callback = args[0];
                var params = args[1];
                genApiUrl(params, function (url) {
                    send(url, callback, params)
                });
            }
        }

        function genHandler(params, success, failure, defer) {
            var failTimes = 0;
            var maxRetryTimes = (params.maxRetryTimes != null ? params.maxRetryTimes : 5);

            function handler(json) {
                var ret = (json && json.ret || []);
                if (ret instanceof Array) {
                    ret = ret.join(',');
                }
                var callee = arguments.callee;

                if (ret.indexOf('SUCCESS') > -1) {
                    json.retType = RESPONSE_TYPE['SUCCESS'];
                    success && success(json, json.retType);
                    defer && defer.resolve(json, json.retType);
                    if (isRunning && params.H5Request) {
                        isRunning = false;
                        runNextInQueue();
                    }
                } else if (ret.indexOf('TOKEN_EMPTY') > -1 ||
                        ret.indexOf('TOKEN_EXOIRED') > -1) {
                    if (params.H5Request && ++failTimes < maxRetryTimes) {
                        genApiUrl(params, function (url) {
                            send(url, callee, params);
                        });
                    } else {
                        if (maxRetryTimes > 0) delToken();
                        json.retType = RESPONSE_TYPE['TOKEN_EXPIRED'];
                        failure && failure(json, json.retType);
                        defer && defer.reject(json, json.retType);
                        if (isRunning && params.H5Request) {
                            isRunning = false;
                            runNextInQueue();
                        }
                    }
                } else if (ret.indexOf('SESSION_EXPIRED') > -1 ||
                        ret.indexOf('SID_INVALID') > -1 ||
                        ret.indexOf('AUTH_REJECT') > -1 ||
                        ret.indexOf('NEED_LOGIN') > -1) {
                    json.retType = RESPONSE_TYPE['SESSION_EXPIRED'];
                    failure && failure(json, json.retType);
                    defer && defer.reject(json, json.retType);
                    if (isRunning && params.H5Request) {
                        isRunning = false;
                        runNextInQueue();
                    }
                } else {
                    if (params.WindVaneRequest
                            && (!ret || ret.indexOf('HY_NO_HANDLER') > -1)) {
                        config.H5Request = true;
                        params.H5Request = true;
                        params.WindVaneRequest = false;
                        genApiUrl(params, function (url) {
                            send(url, callee, params);
                        });
                    } else {
                        json.retType = RESPONSE_TYPE['ERROR'];
                        failure && failure(json, json.retType);
                        defer && defer.reject(json, json.retType);
                        if (isRunning && params.H5Request) {
                            isRunning = false;
                            runNextInQueue();
                        }
                    }
                }
            }

            if (lib.mtop.middleware) {
                return function (retJson) {
                    var pipe = lib.mtop.middleware.pipe(params, retJson);

                    pipe.on('reset', function () {
                        var that = this;
                        genApiUrl(that.request, function (url) {
                            send(url, function (retJson) {
                                that.response = retJson;
                                that.next();
                            }, that.request);
                        });
                    });

                    pipe.on('end', function () {
                        handler(this.response);
                    });

                    pipe.next();
                }
            } else {
                return handler;
            }

        }

//检查缓存
        var localStorage = win.localStorage;
        if (!!localStorage) {
            try {
                localStorage.setItem('@private', 'false');
            } catch (e) {
                localStorage = false;
            }
        }

//获得单元化api前缀
        function getUnitApiPrefix(api) {
            var b = false;
            if (localStorage) {
                var unitCookie = readCookie('_m_user_unitinfo_');
                var unitStorage = localStorage.getItem('unitinfo');
                //支持缓存 && 存在cookie && cookie字段是单元化 && 存在缓存数组 && 数组有此api
                if (unitCookie && unitCookie.split('|')[0].indexOf('center') < 0
                        && unitStorage && unitStorage.indexOf(api.toLowerCase()) >= 0) {
                    b = unitCookie.split('|')[1];
                }
                return b;
            }
        }

//获取更新缓存api的方法
        function getUnitApiList() {
            //支持缓存 && 存在cookie && 有缓存数组
            if (localStorage) {
                var unitCookie = readCookie('_m_unitapi_v_');
                var unitStorage = localStorage.getItem('unitinfo');
                if (unitCookie) {
                    var unitinfo = unitStorage ? JSON.parse(unitStorage) : {};
                    //没有缓存数据 或者 版本不一致 拉取数据 jsonp
                    if (!unitStorage || unitCookie !== unitinfo.version) {
                        var isFinish = false;
                        var url = '//h5.' + config.subDomain +
                                '.taobao.com/js/mtop/unit/' + unitCookie + '/unitApi.js';
                        var script = document.createElement('script');
                        script.src = url;

                        function finish() {
                            if (isFinish) return;
                            isFinish = true;
                            script.onload = script.onerror = null;
                            script.parentNode && script.parentNode.removeChild(script);
                        }

                        script.onerror = function () {
                            finish();
                        }

                        //jsonp 方法
                        if (!win['jsonp_unitapi']) {
                            win['jsonp_unitapi'] = function (json) {
                                finish();
                                localStorage.setItem('unitinfo', JSON.stringify(json));
                            }
                        }
                        appendScript(script);
                    }
                }
            }
        }

        /**
         * 请求成功回调
         * @callback successCallback
         * @param {Object} retJson - 请求返回的对象
         * @param {lib.mtop.RESPONSE_TYPE} retJson.retType - 请求返回的状态
         */

        /**
         * 请求成功回调
         * @callback failureCallback
         * @param {Object} retJson - 请求返回的对象
         * @param {lib.mtop.RESPONSE_TYPE} retJson.retType - 请求返回的状态
         */

        /**
         * @typedef {Object} requestParams
         * @property {String} api - 请求api的名称
         * @property {Object} data - 请求api的数据
         * @property {String} v - 请求api的版本
         * @property {String} [type=GET] - 请求的类型，GET/POST
         * @property {String} [dataType=jsonp] - 请求的数据格式，jsonp/json
         * @property {String} [ua] - 人机交互加密串
         * @property {String} isSec - 安全设置
         * @property {String} ecode - 签名设置
         * @property {String} [timeout=20000] - 请求的超时时间
         */

        /**
         * 在浏览器中，会通过Ajax方式发起请求（H5）。在手淘和天猫客户端中，会通过客户端原生接口发起请求（MtopPlugin）。
         * @param {requestParams} params  - 请求参数
         * @param {successCallback} [success] - 成功回调
         * @param {failureCallback} [failure] - 失败回调
         * @return {Promise} Promise对象实例
         * @memberof lib.mtop
         */
        function request(params, success, failure) {
            // 通用参数处理
            params.v = params.v || '*';
            params.data = params.data || '{}';
            params.timeout = params.timeout || 20000;
            params.type = (params.type || 'get').toLowerCase();
            params.dataType = params.dataType || 'jsonp';

            if (params.type === 'get' && params.dataType === 'jsonp') {
                params.isRequestJsonpByGet = true;
            } else if (params.type === 'get' && params.dataType === 'json') {
                params.isRequestJsonByGet = true;
            } else if (params.type === 'post') {
                params.dataType = 'json';
                params.isRequestJsonByPost = true;
            }

            if (typeof params.data === 'object') {
                params.data = JSON.stringify(params.data);
            }

            // 判断H5请求还是Native请求的逻辑
            if (config.H5Request === false && params.WindVaneRequest === true) {
                // 强制发起Native请求
                if (lib.windvane && parseFloat(WindVaneVersion) >= 5.4) {
                    params.WindVaneRequest = true;
                } else {
                    throw new Error('客户端需接入WindVane SDK以及MtopPlugin SDK；页面需引入lib.windvane库');
                    return;
                }
            } else if (config.H5Request === true || params.H5Request === true) {
                // 强制发起H5请求
                params.H5Request = true;
            } else if (params.WindVaneRequest == null) {
                // 如果没有设置，则自动判断
                if (config.H5Request === false && lib.windvane && parseFloat(WindVaneVersion) >= 5.4) {
                    // 走Native请求
                    params.WindVaneRequest = true;
                } else {
                    // 走H5请求
                    params.H5Request = true;
                }
            }

            params.H5Request = !!params.H5Request;
            params.WindVaneRequest = !!params.WindVaneRequest;

            // 用WindVane请求的情况下，不需要用LoginReuest的插件了
            if (params.LoginRequest && params.WindVaneRequest) {
                params.LoginRequest = false;
            }
            // 在非手淘的客户端请求下，发起H5的请求时，不能再用LoginRequest的插件
            // if (params.LoginRequest && params.H5Request && AliApp && AliAppName != 'TB') {
            //     params.LoginRequest = false;
            // }
            // 发起验证登录的请求
            if (config.LoginRequest === true || params.LoginRequest === true) {
                if (!lib.login) {
                    throw new Error('页面需引入lib.login库');
                    return;
                } else if (!lib.mtop.middleware) {
                    throw new Error('页面需引入lib.mtop库中的middleware.js');
                    return;
                } else if (params.WindVaneRequest) {
                    // 如果
                }
            }

            // 发起验证防爬的请求
            if (config.AntiCreep === true || params.AntiCreep === true) {
                if (!lib.mtop.middleware) {
                    throw new Error('页面需引入lib.mtop库中的middleware.js');
                    return;
                } else {
                    params.AntiCreep = true;
                }
            }

            // 发起验证防刷的请求
            if (config.AntiFlood === true || params.AntiFlood === true) {
                if (!lib.mtop.middleware) {
                    throw new Error('页面需引入lib.mtop库中的middleware.js');
                    return;
                } else {
                    params.AntiFlood = true;
                }
            }

            // 发起请求
            var defer;
            var Promise = lib.promise;
            if (Promise && Promise.defer) {
                defer = Promise.defer();
            }

            var handler = genHandler(params, success, failure || success, defer);
            if (!!params.WindVaneRequest) {
                // 客户端环境（MtopPluginSDK）
                requestWindvaneSecurityProxy(handler, params);
            } else if (!!params.H5Request) {
                // 浏览器环境（H5）
                sendInQueue(handler, params);
            }

            //获取单元化API数组
            if (localStorage) {
                getUnitApiList();
            }

            return defer && defer.promise;
        }

        lib.mtop.request = request

        /**
         * H5请求Mtop的快捷方法
         * @param {requestParams} params  - 请求参数
         * @param {successCallback} [success] - 成功回调
         * @param {failureCallback} [failure] - 失败回调
         * @return {Promise} Promise对象实例
         * @memberof lib.mtop
         */
        function H5Request(params, success, failure) {
            params.H5Request = true;
            return request(params, success, failure);
        }

        lib.mtop.H5Request = H5Request;

        /**
         * 验证登录请求Mtop的快捷方法
         * @param {requestParams} params  - 请求参数
         * @param {successCallback} [success] - 成功回调
         * @param {failureCallback} [failure] - 失败回调
         * @return {Promise} Promise对象实例
         * @memberof lib.mtop
         */
        function loginRequest(params, success, failure) {
            params.LoginRequest = true;
            return lib.mtop.request(params, success, failure);
        }

        lib.mtop.loginRequest = loginRequest;

        /**
         * 验证防爬请求Mtop的快捷方法
         * @param {requestParams} params  - 请求参数
         * @param {successCallback} [success] - 成功回调
         * @param {failureCallback} [failure] - 失败回调
         * @return {Promise} Promise对象实例
         * @memberof lib.mtop
         */
        function antiCreepRequest(params, success, failure) {
            params.AntiCreep = true;
            return lib.mtop.request(params, success, failure);
        }

        lib.mtop.antiCreepRequest = antiCreepRequest;

        /**
         * 验证防刷请求Mtop的快捷方法
         * @param {requestParams} params  - 请求参数
         * @param {successCallback} [success] - 成功回调
         * @param {failureCallback} [failure] - 失败回调
         * @return {Promise} Promise对象实例
         * @memberof lib.mtop
         */
        function antiFloodRequest(params, success, failure) {
            params.AntiFlood = true;
            return lib.mtop.request(params, success, failure);
        }

        lib.mtop.antiFloodRequest = antiFloodRequest;

    })(window, window['lib'] || (window['lib'] = {}));

    </script>
    <script>;
    (function (win, lib, undef) {

        var doc = win.document;
        var ua = win.navigator.userAgent;
        var WindVaneVersion = ua.match(/WindVane[\/\s]([\d\.\_]+)/);
        if (WindVaneVersion) {
            WindVaneVersion = WindVaneVersion[1];
        }
        var AliApp = ua.match(/AliApp\(([^\/]+)\/([\d\.\_]+)\)/i);
        var AliAppName, AliAppVersion;
        if (AliApp) {
            AliAppName = AliApp[1];
            AliAppVersion = AliApp[2];
        }

        function preventMove(e) {
            e.preventDefault();
            return false;
        }

        function FrameWidget(text, url) {
            var that = this;
            var dpr = win.dpr || 1;
            var widget = document.createElement('div');
            var rect = document.documentElement.getBoundingClientRect();
            var width = Math.max(rect.width, window.innerWidth) / dpr;
            var height = Math.max(rect.height, window.innerHeight) / dpr;

            widget.style.cssText = [
                '-webkit-transform:scale(' + dpr + ') translateZ(0)',
                '-ms-transform:scale(' + dpr + ') translateZ(0)',
                'transform:scale(' + dpr + ') translateZ(0)',
                '-webkit-transform-origin:0 0',
                '-ms-transform-origin:0 0',
                'transform-origin:0 0',
                'width:' + width + 'px',
                'height:' + height + 'px',
                'z-index:999999',
                'position:absolute',
                'left:0',
                'top:0px',
                'background:#FFF',
                'display:none'
            ].join(';');

            var title = document.createElement('div');
            title.style.cssText = [
                'width:100%',
                'height:' + 52 + 'px',
                'background:#EEE',
                'line-height:' + 52 + 'px',
                'text-align:left',
                'box-sizing:border-box',
                'padding-left:' + 20 + 'px',
                'position:absolute',
                'left:0',
                'top:0',
                'font-size:' + 16 + 'px',
                'font-weight:bold',
                'color:#333'
            ].join(';');
            title.innerText = text;

            var close = document.createElement('a');
            close.style.cssText = [
                'display:block',
                'position:absolute',
                'right:0',
                'top:0',
                'height:' + 52 + 'px',
                'line-height:' + 52 + 'px',
                'padding:0 ' + 20 + 'px',
                'color:#999'
            ].join(';');
            close.innerText = '关闭';

            var content = document.createElement('iframe');
            content.style.cssText = [
                'width:100%',
                'height:100%',
                'border:0',
                'overflow:hidden'
            ].join(';');

            title.appendChild(close);
            widget.appendChild(title);
            widget.appendChild(content);
            doc.body.appendChild(widget);

            content.src = url;

            close.addEventListener('click', function () {
                that.hide();

                var ev = doc.createEvent('HTMLEvents');
                ev.initEvent('close', false, false);
                widget.dispatchEvent(ev);
            }, false);

            this.addEventListener = function () {
                widget.addEventListener.apply(widget, arguments);
            }

            this.removeEventListener = function () {
                widget.removeEventListener.apply(widget, arguments);
            }

            this.show = function () {
                document.addEventListener('touchmove', preventMove, false);
                widget.style.display = 'block';
                window.scrollTo(0, 0);
            }

            this.hide = function () {
                document.removeEventListener('touchmove', preventMove);
                window.scrollTo(0, -rect.top);
                doc.body.removeChild(widget);
            }
        }

        lib.mtop = lib.mtop || {};
        /**
         * @namespace middleware
         * @memberof lib.mtop
         */
        lib.mtop.middleware = {};

        var middlewares = [];

        /**
         * @class Pipe
         * @param {Object} request  请求参数
         * @param {Object} response 响应参数
         */
        function Pipe(request, response) {
            this.request = request;
            this.response = response;

            var processIndex = 0;
            var handlers = {};

            /**
             * 设置管道的句柄
             * @method on
             * @param  {String} name    reset/end
             * @param  {Function} handler 操作句柄
             * @memberof Pipe
             * @instance
             */
            this.on = function (name, handler) {
                handlers[name] = handler;
            }

            /**
             * 执行管道中的下一个函数
             * @method next
             * @memberof Pipe
             * @instance
             */
            this.next = function () {
                var p = middlewares[processIndex++];
                if (p) {
                    if (!!request[p.__name__]) {
                        p(this);
                    } else {
                        this.next();
                    }
                } else {
                    this.end();
                }
            }

            /**
             * 重置管道
             * @method reset
             * @memberof Pipe
             * @instance
             */
            this.reset = function () {
                processIndex = 0;
                handlers['reset'] && handlers['reset'].call(this);
            }

            /**
             * 终止管道
             * @method end
             * @memberof Pipe
             * @instance
             */
            this.end = function () {
                handlers['end'] && handlers['end'].call(this);
            }
        }

        /**
         * 生成一个中间件管道
         * @param {Object} request  请求参数
         * @param {Object} response 响应参数
         */
        lib.mtop.middleware.pipe = function (request, response) {
            return new Pipe(request, response);
        }

        /**
         * @callback processFunction
         * @param {Pipe} pipe - 管道对象
         */

        /**
         * 新增一个中间件
         * @param {String} name - 中间件名称
         * @param {processFunction} process - 中间件处理函数
         * @memberof lib.mtop.middleware
         */
        function add(name, process) {
            process.__name__ = name;
            middlewares.push(process);
        }

        lib.mtop.middleware.add = add;

        add('LoginRequest', function (pipe) {
            var ret = (pipe.response && pipe.response.ret || []).join(',');

            if (ret.indexOf('SESSION_EXPIRED') > -1 ||
                    ret.indexOf('SID_INVALID') > -1 ||
                    ret.indexOf('AUTH_REJECT') > -1 ||
                    ret.indexOf('NEED_LOGIN') > -1) {

                function successHandler() {
                    pipe.reset();
                }

                function failureHandler() {
                    if (pipe.response) {
                        pipe.response.ret.push('MW_ERROR::LOGIN_FAILURE');
                    }
                    pipe.end();
                }

                function cancelHandler() {
                    if (pipe.response) {
                        pipe.response.ret.push('MW_ERROR::WIDGET_CANCEL');
                    }
                    pipe.end();
                }

                lib.login.goLogin(function (status) {
                    if (status === 'SUCCESS') {
                        successHandler();
                    } else if (status === 'CANCEL') {
                        cancelHandler();
                    } else {
                        failureHandler();
                    }
                });
            } else {
                pipe.next();
            }
        });

        add('AntiCreep', function (pipe) {
            var ret = (pipe.response && pipe.response.ret || []).join(',');

            if (!AliApp && ret.indexOf('RGV587_ERROR::SM') > -1 && pipe.response.data.url) {
                var url = pipe.response.data.url;
                var widget = new FrameWidget('', url);

                function closeHandler() {
                    widget.removeEventListener('close', closeHandler);
                    win.removeEventListener('message', messageHandler);
                    if (pipe.response) {
                        pipe.response.ret.push('MW_ERROR::WIDGET_CANCEL');
                    }
                    pipe.end();
                }

                function messageHandler() {
                    widget.removeEventListener('close', closeHandler);
                    win.removeEventListener('message', messageHandler);
                    var data = JSON.parse(e.data) || {};
                    if (data && data.type === 'child') {
                        var token;
                        try {
                            token = JSON.parse(decodeURIComponent(data.content));
                            if (typeof token === 'string') {
                                token = JSON.parse(token);
                            }
                        } catch (e) {
                            token = null;
                        }

                        if (token) {
                            for (var key in token) {
                                pipe.request[key] = token[key];
                            }
                            pipe.reset();
                        } else {
                            if (pipe.response) {
                                pipe.response.ret.push('MW_ERROR::SM_FAILURE');
                            }
                            pipe.end();
                        }
                        widget.hide();
                    } else {
                        pipe.end();
                    }
                }

                widget.addEventListener('close', closeHandler, false);

                win.addEventListener('message', messageHandler, false);

                widget.show();
            } else {
                pipe.next();
            }
        });

        add('AntiFlood', function (pipe) {
            var ret = (pipe.response && pipe.response.ret || []).join(',');

            if (!AliApp && ret.indexOf('FAIL_SYS_USER_VALIDATE') > -1 && pipe.response.data.url) {
                var url = pipe.response.data.url;
                location.href = url;
            } else {
                pipe.next();
            }
        });

    })(window, window['lib'] || (window['lib'] = {}));
    </script>
    <script>;
    (function (win, lib, undef) {
        var doc = win.document;
        var ua = win.navigator.userAgent;
        var hostname = location.hostname;
        var search = win.location.search;
        var WindVaneVersion = ua.match(/WindVane[\/\s]([\d\.\_]+)/);
        var AliApp = ua.match(/AliApp\(([^\/]+)\/([\d\.\_]+)\)/i);
// var inAliApp = !!(AliApp || WindVaneVersion);
        var isTaobaoApp = !!(AliApp && AliApp[1] === 'TB' && WindVaneVersion && parseFloat(WindVaneVersion[1]) > 5.2);

        var SUPPORT_HOST = [
            'taobao.net',
            'taobao.com'
        ];
        var HOST_REGEXP = new RegExp('([^.]*?)\\.?((?:' + SUPPORT_HOST.join(')|(?:').replace(/\./g, '\\.') + '))', 'i');
        var matchedHost = hostname.match(HOST_REGEXP) || [];
        var MAIN_DOMAIN = (function () {
            var host = matchedHost[2] || 'taobao.com';
            if (host.match(/\.?taobao\.net$/)) {
                return 'taobao.net';
            } else {
                return 'taobao.com';
            }
        })();
        var SUB_DOMAIN = (function () {
            var host = MAIN_DOMAIN;
            var type = matchedHost[1] || 'm';
            if (host === 'taobao.net') {
                type = 'waptest';
            }
            return type;
        })();
        var PREFIX = 'login';

        /**
         * @namespace lib
         */
        /**
         * @namespace login
         * @memberof lib
         */
        lib.login = lib.login || {};

        /**
         * @member config
         * @memberof lib.login
         * @property {String} loginName - 登录页面的地址
         * @property {String} logoutName - 注销页面的地址
         * @property {String} subDomain - 二级域名
         */
        var config = {
            loginName: 'login.htm',
            logoutName: 'logout.htm',
            subDomain: SUB_DOMAIN
        };
        lib.login.config = config;

        function readCookie(name) {
            var matched = new RegExp('(?:^|;\\s*)' + name + '\\=([^;]+)(?:;\\s*|$)').exec(doc.cookie);
            if (matched) {
                return matched[1];
            } else {
                return undef;
            }
        }

        function preventMove(e) {
            e.preventDefault();
            return false;
        }

        function FrameWidget(text, url) {
            var that = this;
            var dpr = win.dpr || 1;
            var widget = document.createElement('div');
            var rect = document.documentElement.getBoundingClientRect();
            var width = Math.max(rect.width, window.innerWidth) / dpr;
            var height = Math.max(rect.height, window.innerHeight) / dpr;


            widget.style.cssText = [
                '-webkit-transform:scale(' + dpr + ') translateZ(0)',
                '-ms-transform:scale(' + dpr + ') translateZ(0)',
                'transform:scale(' + dpr + ') translateZ(0)',
                '-webkit-transform-origin:0 0',
                '-ms-transform-origin:0 0',
                'transform-origin:0 0',
                'width:' + width + 'px',
                'height:' + height + 'px',
                'z-index:999999',
                'position:absolute',
                'left:0',
                'top:0px',
                'background:#FFF',
                'display:none'
            ].join(';');

            var title = document.createElement('div');
            title.style.cssText = [
                'width:100%',
                'height:' + 52 + 'px',
                'background:#EEE',
                'line-height:' + 52 + 'px',
                'text-align:left',
                'box-sizing:border-box',
                'padding-left:' + 20 + 'px',
                'position:absolute',
                'left:0',
                'top:0',
                'font-size:' + 16 + 'px',
                'font-weight:bold',
                'color:#333'
            ].join(';');
            title.innerText = text;

            var close = document.createElement('a');
            close.style.cssText = [
                'display:block',
                'position:absolute',
                'right:0',
                'top:0',
                'height:' + 52 + 'px',
                'line-height:' + 52 + 'px',
                'padding:0 ' + 20 + 'px',
                'color:#999'
            ].join(';');
            close.innerText = '关闭';

            var content = document.createElement('iframe');
            content.style.cssText = [
                'width:100%',
                'height:100%',
                'border:0',
                'overflow:hidden'
            ].join(';');

            title.appendChild(close);
            widget.appendChild(title);
            widget.appendChild(content);
            doc.body.appendChild(widget);

            content.src = url;

            close.addEventListener('click', function () {
                that.hide();

                var ev = doc.createEvent('HTMLEvents');
                ev.initEvent('close', false, false);
                widget.dispatchEvent(ev);
            }, false);

            this.addEventListener = function () {
                widget.addEventListener.apply(widget, arguments);
            }

            this.removeEventListener = function () {
                widget.removeEventListener.apply(widget, arguments);
            }

            this.show = function () {
                document.addEventListener('touchmove', preventMove, false);
                widget.style.display = 'block';
                window.scrollTo(0, 0);
            }

            this.hide = function () {
                document.removeEventListener('touchmove', preventMove);
                window.scrollTo(0, -rect.top);
                doc.body.removeChild(widget);
            }
        }

        /**
         * 检查是否登录
         * @function
         * @return {Boolean} 是否登录
         * @memberof lib.login
         */
        function isLogin(callback) {
            if (callback && typeof callback === 'function' && lib.mtop) {
                lib.mtop.request({
                    api: 'mtop.user.getUserSimple',
                    v: '1.0',
                    data: {'isSec': 0},
                    H5Request: true
                }, function (json) {
                    if (json.retType === lib.mtop.RESPONSE_TYPE.SUCCESS) {
                        callback(true, json);
                    } else if (json.retType === lib.mtop.RESPONSE_TYPE.SESSION_EXPIRED) {
                        callback(false, json);
                    } else {
                        callback(undef, json);
                    }
                });
            } else {
                var nick = this.getUserNick();
                return !!nick
            }
        }

        lib.login.isLogin = isLogin;

        /**
         * 是否登录的回调
         * @callback loginCallback
         * @param {Boolean} status - 是否登录的状态
         * @param {Object} profile - 当前登录用户的信息
         */

        /**
         * 异步检查是否登录
         * @function
         * @param {loginCallback} [callback] - 回调函数
         * @return {Promise} Promise实例
         * @memberof lib.login
         */
        function isLoginAsync(callback) {
            var defer;

            if (lib.promise) {
                defer = lib.promise.defer();
            }

            this.isLogin(function (status, profile) {
                callback && callback(status, profile);
                if (status === true) {
                    defer.resolve(profile);
                } else {
                    defer.reject(profile);
                }
            });

            if (defer) {
                return defer.promise;
            }
        }

        lib.login.isLoginAsync = isLoginAsync;

        /**
         * 获得用户昵称
         * @function
         * @return {String} 用户昵称
         * @memberof lib.login
         */
        function getUserNick(callback) {
            if (callback && typeof callback === 'function') {
                this.isLogin(function (is, json) {
                    if (is === true && json && json.data && json.data.nick) {
                        callback(json.data.nick);
                    } else if (is === false) {
                        callback('');
                    } else {
                        callback(undef);
                    }
                });
            } else {
                var nick = '';
                var wapnick = readCookie('_w_tb_nick');
                var tbnick = readCookie('_nk_') || readCookie('snk');
                if (wapnick && wapnick.length > 0 && wapnick != 'null') {
                    nick = decodeURIComponent(wapnick); // 中文会encode，需要decode
                } else if (tbnick && tbnick.length > 0 && tbnick != 'null') {
                    nick = unescape(unescape(tbnick).replace(/\\u/g, '%u'));
                }
                nick = nick.replace(/\</g, '&lt;').replace(/\>/g, '&gt;');
                return nick;
            }
        }

        lib.login.getUserNick = getUserNick;

        /**
         * 异步获得用户昵称
         * @function
         * @param {Function} [callback] - 回调函数
         * @return {Promise} Promise实例
         * @memberof lib.login
         */
        function getUserNickAsync(callback) {
            var defer;

            if (lib.promise) {
                defer = lib.promise.defer();
            }

            this.getUserNick(function (nick) {
                callback && callback(nick);
                if (!!nick) {
                    defer.resolve(nick);
                } else {
                    defer.reject();
                }

            });

            if (defer) {
                return defer.promise;
            }
        }

        lib.login.getUserNickAsync = getUserNickAsync;


        /**
         * 获得登录/注销地址
         * @function
         * @param {String} type - login或logout类型
         * @param {Object} param - 需要透传的参数
         * @return {String} 生成的地址
         * @memberof lib.login
         */
        function generateUrl(type, params) {
            var url = '//' +
                    PREFIX + '.' +
                    config.subDomain + '.' +
                    MAIN_DOMAIN +
                    '/' + config[(type || 'login') + 'Name'];

            if (params) {
                var qs = [];
                for (var key in params) {
                    qs.push(key + '=' + encodeURIComponent(params[key]));
                }
                url += '?' + qs.join('&');
            }

            return url;
        }

        lib.login.generateUrl = generateUrl;


        function redirect(url, isReplace) {
            if (isReplace) {
                location.replace(url);
            } else {
                var anchorElement = doc.createElement('a');
                var clickEvent = doc.createEvent('HTMLEvents');

                anchorElement.style.display = 'none';
                anchorElement.href = url;
                doc.body.appendChild(anchorElement);

                clickEvent.initEvent('click', false, true);
                anchorElement.dispatchEvent(clickEvent);
            }
        }

        function widget(type, options, callback) {
            var redirectUrl = location.protocol + '//h5.' + config.subDomain +
                    '.taobao.com/' + (config.subDomain === 'waptest' ? 'src' : 'other') + '/' + type + 'end.html?origin=' +
                    encodeURIComponent(location.protocol + '//' + location.hostname);

            var url = generateUrl(type, {
                ttid: 'h5@iframe',
                tpl_redirect_url: redirectUrl,
            });

            var widget = new FrameWidget(options.title || '您需要登录才能继续访问', url);

            function closeHandler(e) {
                widget.removeEventListener('close', closeHandler);
                win.removeEventListener('message', messageHandler);
                callback('CANCEL');
            }

            function messageHandler(e) {
                widget.removeEventListener('close', closeHandler);
                win.removeEventListener('message', messageHandler);
                widget.hide();

                var data = e.data || {};
                if (data && data.type === 'child' && data.content.indexOf('SUCCESS') > -1) {
                    callback('SUCCESS');
                } else {
                    callback('FAILURE');
                }
            }

            widget.addEventListener('close', closeHandler, false);

            win.addEventListener('message', messageHandler, false);

            widget.show();
        }

        function native(type, options, callback) {
            var url = generateUrl(type, {
                wvLoginCallback: 'wvLoginCallback'
            });

            win['wvLoginCallback'] = function (ret) {
                delete win['wvLoginCallback'];

                if (ret.indexOf(':SUCCESS') > -1) {
                    callback('SUCCESS');
                } else if (ret.indexOf(':CANCEL') > -1) {
                    callback('CANCEL');
                } else {
                    callback('FAILURE');
                }
            }

            redirect(url);
        }

        function go(type, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = null;
            } else if (typeof options === 'string') {
                options = {redirectUrl: options};
            }

            options = options || {};

            if (callback && isTaobaoApp) { // 有回调且在手淘客户端里，则用客户端的登录框
                native(type, options, callback);
            } else if (callback && !AliApp && type === 'login') { // 有回调且不在阿里系客户端里，且发起的是异步登录，则用iframe弹窗
                widget(type, options, callback);
            } else { // 其余情况都直接跳转
                var url = generateUrl(type, {
                    tpl_redirect_url: options.redirectUrl || location.href
                });
                redirect(url, options.replace);
            }
        }

        function goAync(type, options, callback) {
            var defer;

            if (lib.promise) {
                defer = lib.promise.defer();
            }

            go(type, options, function (status) {
                callback && callback(status);
                if (status === 'SUCCESS') {
                    defer.resolve(status);
                } else {
                    defer.reject(status);
                }
            });

            if (defer) {
                return defer.promise;
            }
        }

        /**
         * 跳转登录页面
         * @function
         * @param {String} [url=当前页面地址] - 登录成功后跳转的页面
         * @memberof lib.login
         */
        function goLogin(url) {
            go('login', url);
        }

        lib.login.goLogin = goLogin;

        /**
         * 异步登录
         * @function
         * @param {Function} [callback] - 回调函数
         * @return {Promise} Promise实例
         * @memberof lib.login
         */
        function goLoginAsync(callback) {
            return goAync('login', callback);
        }

        lib.login.goLoginAsync = goLoginAsync;

        /**
         * 跳转注销页面
         * @function
         * @param {String} [url=当前页面地址] - 注销成功后跳转的页面
         * @memberof lib.login
         */
        function goLogout(url) {
            go('logout', url);
        }

        lib.login.goLogout = goLogout;

        /**
         * 异步注销
         * @function
         * @param {Function} [callbacak] - 回调函数
         * @return {Promise} Promise实例
         * @memberof lib.login
         */
        function goLogoutAsync(callback) {
            return goAync('logout', callback);
        }

        lib.login.goLogoutAsync = goLogoutAsync;
    })(window, window['lib'] || (window['lib'] = {}));</script>
    <script>;
    (function (win, lib) {
        //
        var CDN = {};


        CDN.isWebp = false;
        CDN.defaultDPI = 1;
        CDN.q = 'q90';//默认都给q90质量图片
        //110x100000.jpg 等宽缩放   , 580, 620, 790
        CDN.widths = [110, 150, 170, 220, 240, 290, 340, 450, 570, 580, 620, 790];
        //10000x 170 等高缩放
        CDN.heights = [170, 220, 340, 500];
        //裁剪成正方形  , 640
        CDN.xzs = [72, 88, 90, 100, 110, 120, 145, 160, 170, 180, 200, 230, 270, 290, 310, 360, 430, 460, 580, 640];
        CDN.rects = ['160x240', '112x336', '560x840'];
        CDN.square = [16, 20, 24, 30, 32, 36, 40, 48, 50, 60, 64, 70, 72, 80, 88, 90, 100, 110, 120, 125, 128, 145, 180, 190, 200, 200, 210, 220, 230, 240, 250, 270, 300, 310, 315, 320, 336, 360, 468, 490, 540, 560, 580, 600, 640, 720, 728, 760, 970];
        /**
         * 初始化
         */
        CDN.init = function () {
            var that = this;
            that.detectWebp();
            that.detectDPI()
            that.getNetWork(function (q) {
                that.q = that.getQ(q);
            });
        };
        /**
         * 侦探浏览器是否支持webp格式的图片
         * isWebp 属性表现
         */
        CDN.detectWebp = function () {
            var webP = new Image(), that = this;
            webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
            webP.onload = function () {
                if (webP.height === 2) {
                    that.isWebp = true;
                } else {
                    that.isWebp = false;
                }
            };
            webP.onerror = function () {
                that.isWebp = false;
            };
        };
        /**
         * 侦探DPI
         * 默认值为1
         */

        CDN.detectDPI = function () {
            var that = this;
            if (window.devicePixelRatio) {
                that.defaultDPI = window.devicePixelRatio;
            }
            ;
        };
        CDN.uaInTaobaoApp = function () {
            var userAgent = navigator.userAgent;
            if (userAgent.match(/WindVane/i) != null) {
                return true;
            }
            else {
                return false;
            }
        };
        /**
         * 获取降级图片参数
         * @param data
         * @returns {string}
         */

        CDN.getQ = function (data) {
            var network = data ? data : this.getStatus;
            if (!network) {
                return 'q90'; //默认也加q90...
            }
            var q = '';
            switch (network) {
                case 'false':
                    q = 'q90';
                    break;
                case 'true':
                    q = 'q75';
                    break;
                case '_noq': //不加后缀q
                    q = '';
                    break;
                default:
                    q = 'q90';
            }
            return q;
        };
        /**
         * 获取网络状况
         * @param callback
         */
        CDN.getNetWork = function (callback) {
            var that = this;
            var WindVane = win['WindVane'];
            if (that.uaInTaobaoApp()) { //在客户端内
                if (WindVane) {
                    WindVane.call('TBWeakNetStatus', 'getStatus', '', function (r) {
                                callback(r.WeakNetStatus);
                            },
                            function (e) {
                                callback();
                            }, 20);
                }
            }
            else {
                callback();
            }
        };
        /**
         * 获取正方形图片
         * -- 判断原图是否为正方形，是正方形直接取期望尺寸，不是去裁剪图片
         * @param {object} param            请求参数
         * @param {string} param.url        图片地址
         * @param {number} param.bestWidth   期望宽度
         * @param {number} param.oWidth     原宽度
         * @param {number} param.oHeight    原高度
         */
        CDN.getSquare = function (param) {
            var that = this, bestWidth = parseInt(param.bestWidth), rs = {}, xz = '', getWidth = 0;
            /**
             * 期望值大于实际值，那么就不必裁剪了，反正也不能变大～
             */
            if (bestWidth > parseInt(param.oWidth)) {
                getWidth = parseInt(param.oWidth);
            } else {
                /**
                 * 不是retina屏幕 加载一半尺寸大小的图片
                 */
                if (that.defaultDPI < 2) {
                    bestWidth = bestWidth / 2;
                }
                /**
                 * 是否取裁剪图片
                 */
                if (param.xz) {
                    //获取裁剪的正方形图片
                    getWidth = that.getBestWith(bestWidth, that.xzs);
                    xz = 'xz';
                } else {
                    /**
                     * 如果带原始尺寸，根据原始尺寸判断是否正方形
                     */
                    if (param.oWidth && param.oHeight) {
                        if (param.oWidth == param.oHeight) {
                            //获取正方形图片
                            getWidth = that.getBestWith(bestWidth, that.square);
                        } else {
                            //获取裁剪的正方形图片
                            getWidth = that.getBestWith(bestWidth, that.xzs);
                            xz = 'xz';
                        }
                    } else {
                        //获取正方形图片
                        getWidth = that.getBestWith(bestWidth, that.square);
                    }
                }
            }
            /**
             * 没有匹配到，那就不用裁剪了～
             */
            if (!getWidth) {
                if (param.xz) {
                    if (bestWidth < that.xzs[0]) {
                        getWidth = that.xzs[0];
                    }
                    ;
                    if (bestWidth > that.xzs[that.xzs.length - 1]) {
                        getWidth = that.xzs[that.xzs.length - 1];
                    }
                    ;
                } else {
                    if (bestWidth < that.square[0]) {
                        getWidth = that.square[0];
                    }
                    ;
                    if (bestWidth > that.square[that.square.length - 1]) {
                        getWidth = that.square[that.square.length - 1];
                    }
                    ;
                }
            }

            rs.url = param.url + '_' + getWidth + 'x' + getWidth + xz + '.jpg';
            /**
             * 判断是否支持webp
             */
            if (!(lib.env.os.isAndroid && lib.env.os.version <= '2.3')) {
                if (that.isWebp) {
                    rs.url += '_.webp';
                }
            }
            return rs;
        };
        /**
         *  宽度最佳展示
         */
        CDN.widthOfBest = function (param) {
            var that = this, bestWidth = parseInt(param.bestWidth), rs = {}, getWidth = 0;
            /**
             * 不是retina屏幕 加载一半尺寸大小的图片
             */
            if (that.defaultDPI < 2) {
                bestWidth = bestWidth / 2;
            }
            getWidth = that.getBestWith(bestWidth, that.widths);

            if (getWidth == 0) {
                rs.url = param.url;
            } else {
                rs.url = param.url + '_' + getWidth + 'x10000.jpg';
            }
            /**
             * 判断是否支持webp
             */
            if (!(lib.env.os.isAndroid && lib.env.os.version <= '2.3')) {
                if (that.isWebp) {
                    rs.url += '_.webp';
                }
            }

            return rs;
        };
        /**
         * 高度最佳展示
         * @param param
         */
        CDN.heightOfBest = function (param) {
            var that = this, bestHeight = parseInt(param.bestHeight), rs = {}, getHeight = 0;
            /**
             * 不是retina屏幕 加载一半尺寸大小的图片
             */
            if (that.defaultDPI < 2) {
                bestHeight = bestHeight / 2;
            }

            getHeight = that.getBestWith(bestHeight, that.heights);
            if (getHeight == 0) {
                rs.url = param.url;
            } else {
                rs.url = param.url + '_10000x' + getHeight + '.jpg';
            }

            /**
             * 判断是否支持webp
             */
            if (!(lib.env.os.isAndroid && lib.env.os.version <= '2.3')) {
                if (that.isWebp) {
                    rs.url += '_.webp';
                }
            }

            return rs;
        };

        CDN.createURL = function () {

        };

        /**
         * 获取最佳图片尺寸
         * @param exp  期望宽度
         * @param arr  查找那个尺寸列表
         * @returns {*}
         */
        CDN.getBestWith = function (exp, arr) {
            var max = arr[arr.length - 1], bestWidth = 0;
            ;
            if (max <= exp) {
                return max;
            }
            for (var i = arr.length; i >= 0; i--) {
                if (arr[i] <= exp) {
                    if (arr[i] == exp) {
                        bestWidth = exp;
                    } else {
                        i < ( arr.length - 1 ) && (bestWidth = arr[i + 1]);
                    }
                    break;
                }
            }
            return bestWidth;
        }
        lib.cdn = CDN;
        lib.cdn.init();

    })(window, window['lib'] || (window['lib'] = {}));</script>
    <script>;
    (function (win, lib) {

        /**
         * 二次贝塞尔曲线(即抛物线)转换为三次贝塞尔曲线
         *
         * @param  {number} a p1点的横坐标
         * @param  {number} b p1点的纵坐标
         * @return {Array}    4个三次贝塞尔参数组成的数组，形如[[p1x, p1y], [p2x, p2y]]
         */
        function quadratic2cubicBezier(a, b) {
            return [[(a / 3 + (a + b) / 3 - a) / (b - a), (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)],
                [(b / 3 + (a + b) / 3 - a) / (b - a), (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)]];
        }

        /**
         * 通过已知的运动参数，推导出其它的位置参数
         * 基于牛顿第二定律：s = vt + at^2/2
         *
         * @param {object} config 形如{v, a, s, t}，其中：
         *                        v是已知初速度，a是已知加速度
         *                        t是时间，s是位移
         *                        t和s最少知其一，即可推导出另一个
         */
        function Motion(config) {

            this.v = config.v || 0;
            this.a = config.a || 0;

            if (typeof config.t !== 'undefined') {
                this.t = config.t;
            }

            if (typeof config.s !== 'undefined') {
                this.s = config.s;
            }

            // 通过位移倒推时间
            if (typeof this.t === 'undefined') {
                if (typeof this.s === 'undefined') {
                    this.t = -this.v / this.a;
                } else {
                    var t1 = (Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v) / this.a;
                    var t2 = (-Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v) / this.a;
                    this.t = Math.min(t1, t2);
                }
            }

            // 通过时间推导位移
            if (typeof this.s === 'undefined') {
                this.s = this.a * this.t * this.t / 2 + this.v * this.t;
            }
        }

        /**
         * 根据运动参数推导出三维贝塞尔参数
         * @return {Array} 4个三次贝塞尔参数组成的数组，形如[[p1x, p1y], [p2x, p2y]]
         */
        Motion.prototype.generateCubicBezier = function () {
            return quadratic2cubicBezier(this.v / this.a, this.t + this.v / this.a);
        };

        lib.motion = Motion;

    })(window, window['lib'] || (window['lib'] = {}));</script>
    <script>;
    (function (win, lib, undef) {

        'use strict';

        var doc = win.document,
                docEl = doc.documentElement,
                slice = Array.prototype.slice,
                gestures = {}, lastTap = null
                ;

        /**
         * 找到两个结点共同的最小根结点
         * 如果跟结点不存在，则返回null
         *
         * @param  {Element} el1 第一个结点
         * @param  {Element} el2 第二个结点
         * @return {Element}     根结点
         */
        function getCommonAncestor(el1, el2) {
            var el = el1;
            while (el) {
                if (el.contains(el2) || el == el2) {
                    return el;
                }
                el = el.parentNode;
            }
            return null;
        }

        /**
         * 触发一个事件
         *
         * @param  {Element} element 目标结点
         * @param  {string}  type    事件类型
         * @param  {object}  extra   对事件对象的扩展
         */
        function fireEvent(element, type, extra) {
            var event = doc.createEvent('HTMLEvents');
            event.initEvent(type, true, true);

            if (typeof extra === 'object') {
                for (var p in extra) {
                    event[p] = extra[p];
                }
            }

            element.dispatchEvent(event);
        }

        /**
         * 计算变换效果
         * 假设坐标系上有4个点ABCD
         * > 旋转：从AB旋转到CD的角度
         * > 缩放：从AB长度变换到CD长度的比例
         * > 位移：从A点位移到C点的横纵位移
         *
         * @param  {number} x1 上述第1个点的横坐标
         * @param  {number} y1 上述第1个点的纵坐标
         * @param  {number} x2 上述第2个点的横坐标
         * @param  {number} y2 上述第2个点的纵坐标
         * @param  {number} x3 上述第3个点的横坐标
         * @param  {number} y3 上述第3个点的纵坐标
         * @param  {number} x4 上述第4个点的横坐标
         * @param  {number} y4 上述第4个点的纵坐标
         * @return {object}    变换效果，形如{rotate, scale, translate[2], matrix[3][3]}
         */
        function calc(x1, y1, x2, y2, x3, y3, x4, y4) {
            var rotate = Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y2 - y1, x2 - x1),
                    scale = Math.sqrt((Math.pow(y4 - y3, 2) + Math.pow(x4 - x3, 2)) / (Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2))),
                    translate = [x3 - scale * x1 * Math.cos(rotate) + scale * y1 * Math.sin(rotate), y3 - scale * y1 * Math.cos(rotate) - scale * x1 * Math.sin(rotate)]
                    ;
            return {
                rotate: rotate,
                scale: scale,
                translate: translate,
                matrix: [
                    [scale * Math.cos(rotate), -scale * Math.sin(rotate), translate[0]],
                    [scale * Math.sin(rotate), scale * Math.cos(rotate), translate[1]],
                    [0, 0, 1]
                ]
            };
        }

        /**
         * 捕获touchstart事件，将每一个新增的触点添加到gestrues
         * 如果之前尚无被记录的触点，则绑定touchmove, touchend, touchcancel事件
         *
         * 新增触点默认处于tapping状态
         * 500毫秒之后如果还处于tapping状态，则触发press手势
         * 如果触点数为2，则触发dualtouchstart手势，该手势的目标结点为两个触点共同的最小根结点
         *
         * @event
         * @param  {event} event
         */
        function touchstartHandler(event) {

            if (Object.keys(gestures).length === 0) {
                docEl.addEventListener('touchmove', touchmoveHandler, false);
                docEl.addEventListener('touchend', touchendHandler, false);
                docEl.addEventListener('touchcancel', touchcancelHandler, false);
            }

            // 记录每一个触点
            // TODO: 变量声明方式，建议在函数最前面声明
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i],
                        touchRecord = {};

                for (var p in touch) {
                    touchRecord[p] = touch[p];
                }

                var gesture = {
                    startTouch: touchRecord,
                    startTime: Date.now(),
                    status: 'tapping',
                    element: event.srcElement || event.target,
                    // TODO: Don't make functions within a loop
                    pressingHandler: setTimeout(function (element) {
                        return function () {
                            if (gesture.status === 'tapping') {
                                gesture.status = 'pressing';

                                fireEvent(element, 'press', {
                                    touchEvent: event
                                });
                            }

                            clearTimeout(gesture.pressingHandler);
                            gesture.pressingHandler = null;
                        };
                    }(event.srcElement || event.target), 500)
                };
                gestures[touch.identifier] = gesture;
            }

            // TODO: 变量声明方式，建议在函数最前面声明
            if (Object.keys(gestures).length == 2) {
                var elements = [];

                for (var p in gestures) {
                    elements.push(gestures[p].element);
                }

                fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchstart', {
                    touches: slice.call(event.touches),
                    touchEvent: event
                });
            }
        }

        /**
         * 捕获touchmove事件，处理pan和dual的相关手势
         *
         * 1. 遍历每个触点：
         * > 如果触点之前处于tapping状态，且位移超过10像素，则认定为进入panning状态
         * 先触发panstart手势，然后根据移动的方向选择性触发horizontalpanstart或verticalpanstart手势
         * > 如果触点之前处于panning状态，则根据pan的初始方向触发horizontalpan或verticalpan手势
         *
         * 2. 如果当前触点数为2，则计算出几何变换的各项参数，触发dualtouch手势
         *
         * @event
         * @param  {event} event
         */
        function touchmoveHandler(event) {
            // TODO: 函数太大了，影响可读性，建议分解并加必要的注释

            // 遍历每个触点：
            // 1. 如果触点之前处于tapping状态，且位移超过10像素，则认定为进入panning状态
            // 先触发panstart手势，然后根据移动的方向选择性触发horizontalpanstart或verticalpanstart手势
            // 2. 如果触点之前处于panning状态，则根据pan的初始方向触发horizontalpan或verticalpan手势
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i],
                        gesture = gestures[touch.identifier];

                if (!gesture) {
                    return;
                }

                if (!gesture.lastTouch) {
                    gesture.lastTouch = gesture.startTouch;
                }
                if (!gesture.lastTime) {
                    gesture.lastTime = gesture.startTime;
                }
                if (!gesture.velocityX) {
                    gesture.velocityX = 0;
                }
                if (!gesture.velocityY) {
                    gesture.velocityY = 0;
                }
                if (!gesture.duration) {
                    gesture.duration = 0;
                }

                var time = Date.now() - gesture.lastTime;
                var vx = (touch.clientX - gesture.lastTouch.clientX) / time,
                        vy = (touch.clientY - gesture.lastTouch.clientY) / time;

                var RECORD_DURATION = 70;
                if (time > RECORD_DURATION) {
                    time = RECORD_DURATION;
                }
                if (gesture.duration + time > RECORD_DURATION) {
                    gesture.duration = RECORD_DURATION - time;
                }

                gesture.velocityX = (gesture.velocityX * gesture.duration + vx * time) / (gesture.duration + time);
                gesture.velocityY = (gesture.velocityY * gesture.duration + vy * time) / (gesture.duration + time);
                gesture.duration += time;

                gesture.lastTouch = {};

                for (var p in touch) {
                    gesture.lastTouch[p] = touch[p];
                }
                gesture.lastTime = Date.now();

                var displacementX = touch.clientX - gesture.startTouch.clientX,
                        displacementY = touch.clientY - gesture.startTouch.clientY,
                        distance = Math.sqrt(Math.pow(displacementX, 2) + Math.pow(displacementY, 2));

                // magic number 10: moving 10px means pan, not tap
                if ((gesture.status === 'tapping' || gesture.status === 'pressing') && distance > 10) {
                    gesture.status = 'panning';
                    gesture.isVertical = !(Math.abs(displacementX) > Math.abs(displacementY));

                    fireEvent(gesture.element, 'panstart', {
                        touch: touch,
                        touchEvent: event,
                        isVertical: gesture.isVertical
                    });

                    fireEvent(gesture.element, (gesture.isVertical ? 'vertical' : 'horizontal') + 'panstart', {
                        touch: touch,
                        touchEvent: event
                    });
                }

                if (gesture.status === 'panning') {
                    gesture.panTime = Date.now();
                    fireEvent(gesture.element, 'pan', {
                        displacementX: displacementX,
                        displacementY: displacementY,
                        touch: touch,
                        touchEvent: event,
                        isVertical: gesture.isVertical
                    });


                    if (gesture.isVertical) {
                        fireEvent(gesture.element, 'verticalpan', {
                            displacementY: displacementY,
                            touch: touch,
                            touchEvent: event
                        });
                    } else {
                        fireEvent(gesture.element, 'horizontalpan', {
                            displacementX: displacementX,
                            touch: touch,
                            touchEvent: event
                        });
                    }
                }
            }

            // 如果当前触点数为2，则计算出几何变换的各项参数，触发dualtouch手势
            if (Object.keys(gestures).length == 2) {
                var position = [],
                        current = [],
                        elements = [],
                        transform
                        ;

                // TODO: 变量声明方式，建议在函数最前面声明
                for (var i = 0; i < event.touches.length; i++) {
                    var touch = event.touches[i];
                    var gesture = gestures[touch.identifier];
                    position.push([gesture.startTouch.clientX, gesture.startTouch.clientY]);
                    current.push([touch.clientX, touch.clientY]);
                }

                // TODO: 变量声明方式，建议在函数最前面声明
                for (var p in gestures) {
                    elements.push(gestures[p].element);
                }

                transform = calc(position[0][0], position[0][1], position[1][0], position[1][1], current[0][0], current[0][1], current[1][0], current[1][1]);
                fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouch', {
                    transform: transform,
                    touches: event.touches,
                    touchEvent: event
                });
            }
        }

        /**
         * 捕获touchend事件
         *
         * 1. 如果当前触点数为2，则触发dualtouchend手势
         *
         * 2. 遍历每个触点：
         * > 如果处于tapping状态，则触发tap手势
         * 如果之前300毫秒出现过tap手势，则升级为doubletap手势
         * > 如果处于panning状态，则根据滑出的速度，触发panend/flick手势
         * flick手势被触发之后，再根据滑出的方向触发verticalflick/horizontalflick手势
         * > 如果处于pressing状态，则触发pressend手势
         *
         * 3. 解绑定所有相关事件
         *
         * @event
         * @param  {event} event
         */
        function touchendHandler(event) {

            if (Object.keys(gestures).length == 2) {
                var elements = [];
                for (var p in gestures) {
                    elements.push(gestures[p].element);
                }
                fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {
                    touches: slice.call(event.touches),
                    touchEvent: event
                });
            }

            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i],
                        id = touch.identifier,
                        gesture = gestures[id];

                if (!gesture) continue;

                if (gesture.pressingHandler) {
                    clearTimeout(gesture.pressingHandler);
                    gesture.pressingHandler = null;
                }

                if (gesture.status === 'tapping') {
                    gesture.timestamp = Date.now();
                    fireEvent(gesture.element, 'tap', {
                        touch: touch,
                        touchEvent: event
                    });

                    if (lastTap && gesture.timestamp - lastTap.timestamp < 300) {
                        fireEvent(gesture.element, 'doubletap', {
                            touch: touch,
                            touchEvent: event
                        });
                    }

                    lastTap = gesture;
                }

                if (gesture.status === 'panning') {
                    var now = Date.now();
                    var duration = now - gesture.startTime,
                    // TODO: velocityX & velocityY never used
                            velocityX = (touch.clientX - gesture.startTouch.clientX) / duration,
                            velocityY = (touch.clientY - gesture.startTouch.clientY) / duration,
                            displacementX = touch.clientX - gesture.startTouch.clientX,
                            displacementY = touch.clientY - gesture.startTouch.clientY
                            ;

                    var velocity = Math.sqrt(gesture.velocityY * gesture.velocityY + gesture.velocityX * gesture.velocityX);
                    var isflick = velocity > 0.5 && (now - gesture.lastTime) < 100;
                    var extra = {
                        duration: duration,
                        isflick: isflick,
                        velocityX: gesture.velocityX,
                        velocityY: gesture.velocityY,
                        displacementX: displacementX,
                        displacementY: displacementY,
                        touch: touch,
                        touchEvent: event,
                        isVertical: gesture.isVertical
                    }

                    fireEvent(gesture.element, 'panend', extra);
                    if (isflick) {
                        fireEvent(gesture.element, 'flick', extra);

                        if (gesture.isVertical) {
                            fireEvent(gesture.element, 'verticalflick', extra);
                        } else {
                            fireEvent(gesture.element, 'horizontalflick', extra);
                        }
                    }
                }

                if (gesture.status === 'pressing') {
                    fireEvent(gesture.element, 'pressend', {
                        touch: touch,
                        touchEvent: event
                    });
                }

                delete gestures[id];
            }

            if (Object.keys(gestures).length === 0) {
                docEl.removeEventListener('touchmove', touchmoveHandler, false);
                docEl.removeEventListener('touchend', touchendHandler, false);
                docEl.removeEventListener('touchcancel', touchcancelHandler, false);
            }
        }

        /**
         * 捕获touchcancel事件
         *
         * 1. 如果当前触点数为2，则触发dualtouchend手势
         *
         * 2. 遍历每个触点：
         * > 如果处于panning状态，则触发panend手势
         * > 如果处于pressing状态，则触发pressend手势
         *
         * 3. 解绑定所有相关事件
         *
         * @event
         * @param  {event} event
         */
        function touchcancelHandler(event) {
            // TODO: 和touchendHandler大量重复，建议DRY

            if (Object.keys(gestures).length == 2) {
                var elements = [];
                for (var p in gestures) {
                    elements.push(gestures[p].element);
                }
                fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {
                    touches: slice.call(event.touches),
                    touchEvent: event
                });
            }

            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i],
                        id = touch.identifier,
                        gesture = gestures[id];

                if (!gesture) continue;

                if (gesture.pressingHandler) {
                    clearTimeout(gesture.pressingHandler);
                    gesture.pressingHandler = null;
                }

                if (gesture.status === 'panning') {
                    fireEvent(gesture.element, 'panend', {
                        touch: touch,
                        touchEvent: event
                    });
                }
                if (gesture.status === 'pressing') {
                    fireEvent(gesture.element, 'pressend', {
                        touch: touch,
                        touchEvent: event
                    });
                }
                delete gestures[id];
            }

            if (Object.keys(gestures).length === 0) {
                docEl.removeEventListener('touchmove', touchmoveHandler, false);
                docEl.removeEventListener('touchend', touchendHandler, false);
                docEl.removeEventListener('touchcancel', touchcancelHandler, false);
            }
        }

        docEl.addEventListener('touchstart', touchstartHandler, false);

    })(window, window.lib || (window.lib = {}));</script>
    <script>;
    (function (win, lib) {

        var FPS = 60;
        var INTERVAL = 1000 / FPS;

        function setTimeoutFrame(cb) {
            return setTimeout(cb, INTERVAL);
        }

        function clearTimeoutFrame(tick) {
            clearTimeout(tick);
        }

        var requestAnimationFrame =
                window.requestAnimationFrame ||
                window.msRequestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                setTimeoutFrame;


        var cancelAnimationFrame =
                window.cancelAnimationFrame ||
                window.msCancelAnimationFrame ||
                window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                clearTimeoutFrame;

        if (requestAnimationFrame === setTimeoutFrame || cancelAnimationFrame === clearTimeoutFrame) {
            requestAnimationFrame = setTimeoutFrame;
            cancelAnimationFrame = clearTimeoutFrame;
        }

        function Frame(fun) {
            var isRequested = false;
            Object.defineProperty(this, 'isRequested', {
                get: function () {
                    return isRequested;
                }
            });

            var callback = [];

            function done() {
                isRequested = true;
                if (callback) {
                    callback.forEach(function (cb) {
                        cb && cb();
                    });
                }
            }

            var tick;
            var isCancel = false;
            this.request = function () {
                if (isRequested) return;

                var args = arguments;
                isCancel = false;
                tick = requestAnimationFrame(function () {
                    if (isCancel) return;
                    fun.apply(win, args);
                    done();
                });

                return this;
            }

            this.cancel = function () {
                if (tick) {
                    isCancel = true;
                    cancelAnimationFrame(tick);
                }
            }

            this.then = function (cb) {
                if (isRequested) {
                    cb && cb();
                } else {
                    callback.push(cb);
                }
                return this;
            }

            this.clone = function () {
                return new Frame(fun);
            }
        }

        function Animation(duration, timingFunction, delay, frames) {

            if (typeof frames === 'function') {
                frames = {
                    '0': frames
                };
            }

            var frameCount = duration / INTERVAL;
            var framePercent = 1 / frameCount;
            var frameQueue = [];
            var frameKeys = Object.keys(frames).map(function (i) {
                return parseInt(i)
            });

            for (var i = 0; i < frameCount; i++) {
                var key = frameKeys[0];
                var percent = framePercent * i;
                if (key != null && key <= percent * 100) {
                    var frame = frames['' + key];
                    if (!(frame instanceof Frame)) {
                        frame = new Frame(frame);
                    }
                    frameQueue.push(frame);
                    frameKeys.shift();
                } else if (frameQueue.length) {
                    frameQueue.push(frameQueue[frameQueue.length - 1].clone());
                }
            }

            var bezier;
            if (typeof timingFunction === 'string' || timingFunction instanceof Array) {
                if (!lib['cubicbezier']) {
                    console.error('require lib.cubicbezier');
                } else {
                    if (typeof timingFunction === 'string') {
                        if (lib.cubicbezier[timingFunction]) {
                            bezier = lib.cubicbezier[timingFunction];
                        }
                    } else if (timingFunction instanceof Array && timingFunction.length === 4) {
                        bezier = lib.cubicbezier.apply(lib.cubicbezier, timingFunction);
                    }
                }
            } else if (typeof timingFunction === 'function') {
                bezier = timingFunction;
            }

            if (!bezier) {
                console.error('unexcept timing function');
            }

            var isPlaying = false;
            var delayTick = 0;
            var frameIndex = 0;
            var currentFrame;

            this.play = function () {
                if (isPlaying) return;
                isPlaying = true;

                function done() {
                    isPlaying = false;
                    endHandler && endHandler();
                }

                function request() {
                    var percent = framePercent * (frameIndex + 1).toFixed(10);

                    currentFrame = frameQueue[frameIndex];
                    currentFrame.request(percent.toFixed(10), timingFunction(percent).toFixed(10));
                    currentFrame.then(function () {
                        frameIndex++;
                        next();
                    });
                }

                function next() {
                    if (!isPlaying) return;

                    if (frameIndex === frameQueue.length) {
                        done();
                    } else {
                        request();
                    }
                }

                delayTick = setTimeout(function () {
                    delayTick = 0;
                    next();
                }, !frameIndex && delay || 0);
                return this;
            }

            this.stop = function () {
                if (!isPlaying) return;
                isPlaying = false;

                if (delayTick) {
                    clearTimeout(delayTick);
                    delayTick = 0;
                }

                if (currentFrame) {
                    currentFrame.cancel();
                }

                return this;
            }

            var endHandler;
            this.onend = function (handler) {
                endHandler = handler;
            }
        }

        lib.animation = Animation;

        lib.animation.Frame = Frame;

        lib.animation.requestFrame = function (fun) {
            var frame = new Frame(fun);
            frame.request();
            return frame;
        }

    })(window, window['lib'] || (window['lib'] = {}))</script>
    <script>;
    (function (win, lib) {

        function cubicBezierFunction(p1x, p1y, p2x, p2y) {
            var ZERO_LIMIT = 1e-6;
            // Calculate the polynomial coefficients,
            // implicit first and last control points are (0,0) and (1,1).
            var ax = 3 * p1x - 3 * p2x + 1,
                    bx = 3 * p2x - 6 * p1x,
                    cx = 3 * p1x;

            var ay = 3 * p1y - 3 * p2y + 1,
                    by = 3 * p2y - 6 * p1y,
                    cy = 3 * p1y;

            function sampleCurveDerivativeX(t) {
                // `ax t^3 + bx t^2 + cx t' expanded using Horner 's rule.
                return (3 * ax * t + 2 * bx) * t + cx;
            }

            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx ) * t;
            }

            function sampleCurveY(t) {
                return ((ay * t + by) * t + cy ) * t;
            }

            // Given an x value, find a parametric value it came from.
            function solveCurveX(x) {
                var t2 = x,
                        derivative,
                        x2;

                // https://trac.webkit.org/browser/trunk/Source/WebCore/platform/animation
                // First try a few iterations of Newton's method -- normally very fast.
                // http://en.wikipedia.org/wiki/Newton's_method
                for (var i = 0; i < 8; i++) {
                    // f(t)-x=0
                    x2 = sampleCurveX(t2) - x;
                    if (Math.abs(x2) < ZERO_LIMIT) {
                        return t2;
                    }
                    derivative = sampleCurveDerivativeX(t2);
                    // == 0, failure
                    if (Math.abs(derivative) < ZERO_LIMIT) {
                        break;
                    }
                    t2 -= x2 / derivative;
                }

                // Fall back to the bisection method for reliability.
                // bisection
                // http://en.wikipedia.org/wiki/Bisection_method
                var t1 = 1,
                        t0 = 0;
                t2 = x;
                while (t1 > t0) {
                    x2 = sampleCurveX(t2) - x;
                    if (Math.abs(x2) < ZERO_LIMIT) {
                        return t2;
                    }
                    if (x2 > 0) {
                        t1 = t2;
                    } else {
                        t0 = t2;
                    }
                    t2 = (t1 + t0) / 2;
                }

                // Failure
                return t2;
            }

            function solve(x) {
                return sampleCurveY(solveCurveX(x));
            }

            return solve;
        }

        lib.cubicbezier = cubicBezierFunction;
        lib.cubicbezier.liner = cubicBezierFunction(0, 0, 1, 1);
        lib.cubicbezier.ease = cubicBezierFunction(.25, .1, .25, 1);
        lib.cubicbezier.easeIn = cubicBezierFunction(.42, 0, 1, 1);
        lib.cubicbezier.easeOut = cubicBezierFunction(0, 0, .58, 1);
        lib.cubicbezier.easeInOut = cubicBezierFunction(.42, 0, .58, 1);

    })(window, window['lib'] || (window['lib'] = {}));</script>
    <script>;
    (function (win, lib, undef) {
        var doc = win.document;
        var ua = win.navigator.userAgent;
        var scrollObjs = {};
        var plugins = {};
        var dpr = win.dpr || (!!win.navigator.userAgent.match(/iPhone|iPad|iPod/) ? document.documentElement.clientWidth / win.screen.availWidth : 1);
        var inertiaCoefficient = {
            'normal': [2 * dpr, 0.0015 * dpr],
            'slow': [1.5 * dpr, 0.003 * dpr],
            'veryslow': [1.5 * dpr, 0.005 * dpr]
        }
        var timeFunction = {
            'ease': [.25, .1, .25, 1],
            'liner': [0, 0, 1, 1],
            'ease-in': [.42, 0, 1, 1],
            'ease-out': [0, 0, .58, 1],
            'ease-in-out': [.42, 0, .58, 1]
        }
        var Firefox = !!ua.match(/Firefox/i);
        var IEMobile = !!ua.match(/IEMobile/i);
        var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-';
        var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit';

        function debugLog() {
            if (lib.scroll.outputDebugLog) {
                console.debug.apply(console, arguments);
            }
        }

        function getBoundingClientRect(el) {
            var rect = el.getBoundingClientRect();
            if (!rect) {
                rect = {};
                rect.width = el.offsetWidth;
                rect.height = el.offsetHeight;

                rect.left = el.offsetLeft;
                rect.top = el.offsetTop;
                var parent = el.offsetParent;
                while (parent) {
                    rect.left += parent.offsetLeft;
                    rect.top += parent.offsetTop;
                    parent = parent.offsetParent;
                }

                rect.right = rect.left + rect.width;
                rect.bottom = rect.top + rect.height;
            }
            return rect;
        }

        function getMinScrollOffset(scrollObj) {
            return 0 - scrollObj.options[scrollObj.axis + 'Padding1'];
        }

        function getMaxScrollOffset(scrollObj) {
            var rect = getBoundingClientRect(scrollObj.element);
            var pRect = getBoundingClientRect(scrollObj.viewport);
            var min = getMinScrollOffset(scrollObj);
            if (scrollObj.axis === 'y') {
                var max = 0 - rect.height + pRect.height;
            } else {
                var max = 0 - rect.width + pRect.width;
            }
            return Math.min(max + scrollObj.options[scrollObj.axis + 'Padding2'], min);
        }

        function getBoundaryOffset(scrollObj, offset) {
            if (offset > scrollObj.minScrollOffset) {
                return offset - scrollObj.minScrollOffset;
            } else if (offset < scrollObj.maxScrollOffset) {
                return offset - scrollObj.maxScrollOffset;
            }
        }

        function touchBoundary(scrollObj, offset) {
            if (offset > scrollObj.minScrollOffset) {
                offset = scrollObj.minScrollOffset;
            } else if (offset < scrollObj.maxScrollOffset) {
                offset = scrollObj.maxScrollOffset;
            }
            return offset;
        }

        function fireEvent(scrollObj, eventName, extra) {
            debugLog(scrollObj.element.scrollId, eventName, extra);

            var event = doc.createEvent('HTMLEvents');
            event.initEvent(eventName, false, true);
            event.scrollObj = scrollObj;
            if (extra) {
                for (var key in extra) {
                    event[key] = extra[key];
                }
            }
            scrollObj.element.dispatchEvent(event);
            scrollObj.viewport.dispatchEvent(event);
        }

        function getTransformOffset(scrollObj) {
            var offset = {x: 0, y: 0};
            var transform = getComputedStyle(scrollObj.element)[stylePrefix + 'Transform'];
            var matched;

            if (transform !== 'none') {
                if ((matched = transform.match(/^matrix3d\((?:[-\d.]+,\s*){12}([-\d.]+),\s*([-\d.]+)(?:,\s*[-\d.]+){2}\)/) ||
                                transform.match(/^matrix\((?:[-\d.]+,\s*){4}([-\d.]+),\s*([-\d.]+)\)$/))) {
                    offset.x = parseFloat(matched[1]) || 0;
                    offset.y = parseFloat(matched[2]) || 0;
                }
            }

            return offset;
        }

        var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix';
        var has3d = !!Firefox || CSSMatrix in win && 'm11' in new win[CSSMatrix]();

        function getTranslate(x, y) {
            x = parseFloat(x);
            y = parseFloat(y);

            if (x != 0) {
                x += 'px';
            }

            if (y != 0) {
                y += 'px';
            }

            if (has3d) {
                return 'translate3d(' + x + ', ' + y + ', 0)';
            } else {
                return 'translate(' + x + ', ' + y + ')';
            }
        }

        function setTransitionStyle(scrollObj, duration, timingFunction) {
            if (arguments.length === 1) {
                scrollObj.element.style[stylePrefix + 'Transition'] = '';
            } else {
                scrollObj.element.style[stylePrefix + 'Transition'] = cssPrefix + 'transform ' + duration + ' ' + timingFunction + ' 0s';
            }
        }

        function setTransformStyle(scrollObj, offset) {
            if (scrollObj.axis === 'y') {
                scrollObj.element.style[stylePrefix + 'Transform'] = getTranslate(0, offset);
            } else {
                scrollObj.element.style[stylePrefix + 'Transform'] = getTranslate(offset, 0);
            }
        }

        var panning = false;
        doc.addEventListener('touchmove', function (e) {
            if (panning) {
                e.preventDefault();
                return false;
            }
            return true;
        }, false);

        function Scroll(element, options) {
            var that = this;

            options = options || {};
            options.noBounce = !!options.noBounce;
            options.padding = options.padding || {};

            if (options.isPrevent == null) {
                options.isPrevent = true;
            } else {
                options.isPrevent = !!options.isPrevent;
            }

            if (options.isFixScrollendClick == null) {
                options.isFixScrollendClick = true;
            } else {
                options.isFixScrollendClick = !!options.isFixScrollendClick;
            }

            if (options.padding) {
                options.yPadding1 = -options.padding.top || 0;
                options.yPadding2 = -options.padding.bottom || 0;
                options.xPadding1 = -options.padding.left || 0;
                options.xPadding2 = -options.padding.right || 0;
            } else {
                options.yPadding1 = 0;
                options.yPadding2 = 0;
                options.xPadding1 = 0;
                options.xPadding2 = 0;
            }

            if (options.margin) {
                options.yMargin1 = -options.margin.top || 0;
                options.yMargin2 = -options.margin.bottom || 0;
                options.xMargin1 = -options.margin.left || 0;
                options.xMargin2 = -options.margin.right || 0;
            } else {
                options.yMargin1 = 0;
                options.yMargin2 = 0;
                options.xMargin1 = 0;
                options.xMargin2 = 0;
            }

            options.direction = options.direction || 'y';
            options.inertia = options.inertia || 'normal';

            this.options = options;
            that.axis = options.direction;
            this.element = element;
            this.viewport = element.parentNode;
            this.plugins = {};

            this.viewport.addEventListener('touchstart', touchstartHandler, false);
            this.viewport.addEventListener('touchend', touchendHandler, false);
            this.viewport.addEventListener('touchcancel', touchendHandler, false);
            this.viewport.addEventListener('panstart', panstartHandler, false);
            this.viewport.addEventListener('pan', panHandler, false);
            this.viewport.addEventListener('panend', panendHandler, false);

            this.element.scrollId = setTimeout(function () {
                scrollObjs[that.element.scrollId + ''] = that;
            }, 1);

            if (options.isPrevent) {
                this.viewport.addEventListener('touchstart', function (e) {
                    panning = true;
                }, false);
                that.viewport.addEventListener('touchend', function (e) {
                    panning = false;
                }, false);
            }

            if (options.isFixScrollendClick) {
                var preventScrollendClick;
                var fixScrollendClickTimeoutId;

                this.viewport.addEventListener('scrolling', function () {
                    preventScrollendClick = true;
                    fixScrollendClickTimeoutId && clearTimeout(fixScrollendClickTimeoutId);
                    fixScrollendClickTimeoutId = setTimeout(function (e) {
                        preventScrollendClick = false;
                    }, 400);
                }, false);

                function preventScrollendClickHandler(e) {
                    if (preventScrollendClick || isScrolling) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    } else {
                        return true;
                    }
                }

                function fireNiceTapEventHandler(e) {
                    if (!preventScrollendClick && !isScrolling) {
                        setTimeout(function () {
                            var niceTapEvent = document.createEvent('HTMLEvents');
                            niceTapEvent.initEvent('niceclick', true, true);
                            e.target.dispatchEvent(niceTapEvent);
                        }, 300);
                    }
                }

                this.viewport.addEventListener('click', preventScrollendClickHandler, false);
                this.viewport.addEventListener('tap', fireNiceTapEventHandler, false);
            }

            if (options.useFrameAnimation) {
                var scrollAnimation;

                Object.defineProperty(this, 'animation', {
                    get: function () {
                        return scrollAnimation;
                    }
                });
            } else {
                var transitionEndHandler;
                var transitionEndTimeoutId = 0;

                function setTransitionEndHandler(h, t) {
                    transitionEndHandler = null;
                    clearTimeout(transitionEndTimeoutId);

                    transitionEndTimeoutId = setTimeout(function () {
                        if (transitionEndHandler) {
                            transitionEndHandler = null;
                            lib.animation.requestFrame(h);
                        }
                    }, (t || 400));

                    transitionEndHandler = h;
                }

                element.addEventListener(Firefox ? 'transitionend' : (stylePrefix + 'TransitionEnd'), function (e) {
                    if (transitionEndHandler) {
                        var handler = transitionEndHandler;

                        transitionEndHandler = null;
                        clearTimeout(transitionEndTimeoutId);

                        lib.animation.requestFrame(function () {
                            handler(e);
                        });
                    }
                }, false);
            }

            var panFixRatio;
            var isScrolling;
            var isFlickScrolling;
            var cancelScrollEnd;

            Object.defineProperty(this, 'isScrolling', {
                get: function () {
                    return !!isScrolling;
                }
            });

            function isEnabled(e) {
                if (!that.enabled) {
                    return false;
                }

                if (typeof e.isVertical != 'undefined') {
                    if (that.axis === 'y' && e.isVertical || that.axis === 'x' && !e.isVertical) {
                        // 同方向的手势，停止冒泡
                        e.stopPropagation();
                    } else {
                        // 不是同方向的手势，冒泡到上层，不做任何处理
                        return false;
                    }
                }

                return true;
            }

            function touchstartHandler(e) {
                if (!isEnabled(e)) {
                    return;
                }

                if (isScrolling) {
                    scrollEnd();
                }

                if (options.useFrameAnimation) {
                    scrollAnimation && scrollAnimation.stop();
                    scrollAnimation = null;
                } else {
                    var offset = getTransformOffset(that);
                    setTransformStyle(that, offset);
                    setTransitionStyle(that, '', '');
                    transitionEndHandler = null;
                    clearTimeout(transitionEndTimeoutId);
                }

            }

            function touchendHandler(e) {
                if (!isEnabled(e)) {
                    return;
                }

                var s0 = getTransformOffset(that)[that.axis];
                var boundaryOffset = getBoundaryOffset(that, s0);

                if (boundaryOffset) {
                    // 拖动超出边缘，需要回弹
                    var s1 = touchBoundary(that, s0);

                    if (options.useFrameAnimation) {
                        // frame
                        var _s = s1 - s0;
                        scrollAnimation = new lib.animation(400, lib.cubicbezier.ease, 0, function (i1, i2) {
                            var offset = (s0 + _s * i2).toFixed(2);
                            setTransformStyle(that, offset);
                            fireEvent(that, 'scrolling');
                        });
                        scrollAnimation.onend(scrollEnd);
                        scrollAnimation.play();
                    } else {
                        // css
                        var offset = s1.toFixed(0);
                        setTransitionStyle(that, '0.4s', 'ease');
                        setTransformStyle(that, offset);
                        setTransitionEndHandler(scrollEnd, 400);

                        lib.animation.requestFrame(function () {
                            if (isScrolling && that.enabled) {
                                fireEvent(that, 'scrolling');
                                lib.animation.requestFrame(arguments.callee);
                            }
                        });
                    }

                    if (boundaryOffset > 0) {
                        fireEvent(that, that.axis === 'y' ? 'pulldownend' : 'pullrightend');
                    } else if (boundaryOffset < 0) {
                        fireEvent(that, that.axis === 'y' ? 'pullupend' : 'pullleftend');
                    }
                } else if (isScrolling) {
                    // 未超出边缘，直接结束
                    scrollEnd();
                }
            }

            var lastDisplacement;

            function panstartHandler(e) {
                if (!isEnabled(e)) {
                    return;
                }

                that.transformOffset = getTransformOffset(that);
                that.minScrollOffset = getMinScrollOffset(that);
                that.maxScrollOffset = getMaxScrollOffset(that);
                panFixRatio = 2.5;
                cancelScrollEnd = true;
                isScrolling = true;
                isFlickScrolling = false;
                fireEvent(that, 'scrollstart');

                lastDisplacement = e['displacement' + that.axis.toUpperCase()];
            }


            function panHandler(e) {
                if (!isEnabled(e)) {
                    return;
                }

                // 手指移动小于5像素，也忽略
                var displacement = e['displacement' + that.axis.toUpperCase()];
                if (Math.abs(displacement - lastDisplacement) < 5) {
                    e.stopPropagation();
                    return;
                }
                lastDisplacement = displacement;

                var offset = that.transformOffset[that.axis] + displacement;
                if (offset > that.minScrollOffset) {
                    offset = that.minScrollOffset + (offset - that.minScrollOffset) / panFixRatio;
                    panFixRatio *= 1.003;
                } else if (offset < that.maxScrollOffset) {
                    offset = that.maxScrollOffset - (that.maxScrollOffset - offset) / panFixRatio;
                    panFixRatio *= 1.003;
                }
                if (panFixRatio > 4) {
                    panFixRatio = 4;
                }

                // 判断是否到了边缘
                var boundaryOffset = getBoundaryOffset(that, offset);
                if (boundaryOffset) {
                    fireEvent(that, boundaryOffset > 0 ? (that.axis === 'y' ? 'pulldown' : 'pullright') : (that.axis === 'y' ? 'pullup' : 'pullleft'), {
                        boundaryOffset: Math.abs(boundaryOffset)
                    });
                    if (that.options.noBounce) {
                        offset = touchBoundary(that, offset);
                    }
                }

                setTransformStyle(that, offset.toFixed(2));
                fireEvent(that, 'scrolling');
            }

            function panendHandler(e) {
                if (!isEnabled(e)) {
                    return;
                }

                if (e.isflick) {
                    flickHandler(e);
                }
            }

            function flickHandler(e) {
                cancelScrollEnd = true;

                var v0, a0, t0, s0, s, motion0;
                var v1, a1, t1, s1, motion1, sign;
                var v2, a2, t2, s2, motion2, ft;

                s0 = getTransformOffset(that)[that.axis];
                var boundaryOffset0 = getBoundaryOffset(that, s0);
                if (!boundaryOffset0) {
                    //手指离开屏幕时，已经超出滚动范围，不作处理，让touchend handler处理
                    //手指离开屏幕时，在滚动范围内，做一下惯性计算
                    v0 = e['velocity' + that.axis.toUpperCase()];

                    var maxV = 2;
                    var friction = 0.0015;
                    if (options.inertia && inertiaCoefficient[options.inertia]) {
                        maxV = inertiaCoefficient[options.inertia][0];
                        friction = inertiaCoefficient[options.inertia][1];
                    }

                    if (v0 > maxV) {
                        v0 = maxV;
                    }
                    if (v0 < -maxV) {
                        v0 = -maxV;
                    }
                    a0 = friction * ( v0 / Math.abs(v0));
                    motion0 = new lib.motion({
                        v: v0,
                        a: -a0
                    });
                    t0 = motion0.t;
                    s = s0 + motion0.s;

                    var boundaryOffset1 = getBoundaryOffset(that, s);
                    if (boundaryOffset1) {
                        //惯性运动足够滑出屏幕边缘
                        debugLog('惯性计算超出了边缘', boundaryOffset1);

                        v1 = v0;
                        a1 = a0;
                        if (boundaryOffset1 > 0) {
                            s1 = that.minScrollOffset;
                            sign = 1;
                        } else {
                            s1 = that.maxScrollOffset;
                            sign = -1;
                        }
                        motion1 = new lib.motion({
                            v: sign * v1,
                            a: -sign * a1,
                            s: Math.abs(s1 - s0)
                        });
                        t1 = motion1.t;
                        var timeFunction1 = motion1.generateCubicBezier();

                        v2 = v1 - a1 * t1;
                        a2 = 0.03 * (v2 / Math.abs(v2));
                        motion2 = new lib.motion({
                            v: v2,
                            a: -a2
                        });
                        t2 = motion2.t;
                        s2 = s1 + motion2.s;
                        var timeFunction2 = motion2.generateCubicBezier();

                        if (options.noBounce) {
                            // 没有边缘回弹效果，直接平顺滑到边缘
                            debugLog('没有回弹效果');

                            if (s0 !== s1) {
                                if (options.useFrameAnimation) {
                                    // frame
                                    var _s = s1 - s0;
                                    var bezier = lib.cubicbezier(timeFunction1[0][0], timeFunction1[0][1], timeFunction1[1][0], timeFunction1[1][1]);
                                    scrollAnimation = new lib.animation(t1.toFixed(0), bezier, 0, function (i1, i2) {
                                        var offset = (s0 + _s * i2);
                                        getTransformOffset(that, offset.toFixed(2));
                                        fireEvent(that, 'scrolling', {
                                            afterFlick: true
                                        });
                                    });

                                    scrollAnimation.onend(scrollEnd);

                                    scrollAnimation.play();
                                } else {
                                    // css
                                    var offset = s1.toFixed(0);
                                    setTransitionStyle(that, (t1 / 1000).toFixed(2) + 's', 'cubic-bezier(' + timeFunction1 + ')');
                                    setTransformStyle(that, offset);
                                    setTransitionEndHandler(scrollEnd, (t1 / 1000).toFixed(2) * 1000);
                                }
                            } else {
                                scrollEnd();
                            }
                        } else if (s0 !== s2) {
                            debugLog('惯性滚动', 's=' + s2.toFixed(0), 't=' + ((t1 + t2) / 1000).toFixed(2));

                            if (options.useFrameAnimation) {
                                var _s = s2 - s0;
                                var bezier = lib.cubicbezier.easeOut;
                                scrollAnimation = new lib.animation((t1 + t2).toFixed(0), bezier, 0, function (i1, i2) {
                                    var offset = s0 + _s * i2;
                                    setTransformStyle(that, offset.toFixed(2));
                                    fireEvent(that, 'scrolling', {
                                        afterFlick: true
                                    });
                                });

                                scrollAnimation.onend(function () {
                                    if (!that.enabled) {
                                        return;
                                    }

                                    var _s = s1 - s2;
                                    var bezier = lib.cubicbezier.ease;
                                    scrollAnimation = new lib.animation(400, bezier, 0, function (i1, i2) {
                                        var offset = s2 + _s * i2;
                                        setTransformStyle(that, offset.toFixed(2));
                                        fireEvent(that, 'scrolling', {
                                            afterFlick: true
                                        });
                                    });

                                    scrollAnimation.onend(scrollEnd);

                                    scrollAnimation.play();
                                });

                                scrollAnimation.play();
                            } else {
                                var offset = s2.toFixed(0);
                                setTransitionStyle(that, ((t1 + t2) / 1000).toFixed(2) + 's', 'ease-out');
                                setTransformStyle(that, offset);

                                setTransitionEndHandler(function (e) {
                                    if (!that.enabled) {
                                        return;
                                    }

                                    debugLog('惯性回弹', 's=' + s1.toFixed(0), 't=400');

                                    if (s2 !== s1) {
                                        var offset = s1.toFixed(0);
                                        setTransitionStyle(that, '0.4s', 'ease');
                                        setTransformStyle(that, offset);
                                        setTransitionEndHandler(scrollEnd, 400);
                                    } else {
                                        scrollEnd();
                                    }
                                }, ((t1 + t2) / 1000).toFixed(2) * 1000);
                            }
                        } else {
                            scrollEnd();
                        }
                    } else {
                        debugLog('惯性计算没有超出边缘');
                        var timeFunction = motion0.generateCubicBezier();

                        if (options.useFrameAnimation) {
                            // frame;
                            var _s = s - s0;
                            var bezier = lib.cubicbezier(timeFunction[0][0], timeFunction[0][1], timeFunction[1][0], timeFunction[1][1]);
                            scrollAnimation = new lib.animation(t0.toFixed(0), bezier, 0, function (i1, i2) {
                                var offset = (s0 + _s * i2).toFixed(2);
                                setTransformStyle(that, offset);
                                fireEvent(that, 'scrolling', {
                                    afterFlick: true
                                });
                            });

                            scrollAnimation.onend(scrollEnd);

                            scrollAnimation.play();
                        } else {
                            // css
                            var offset = s.toFixed(0);
                            setTransitionStyle(that, (t0 / 1000).toFixed(2) + 's', 'cubic-bezier(' + timeFunction + ')');
                            setTransformStyle(that, offset);
                            setTransitionEndHandler(scrollEnd, (t0 / 1000).toFixed(2) * 1000);
                        }
                    }


                    isFlickScrolling = true;
                    if (!options.useFrameAnimation) {
                        lib.animation.requestFrame(function () {
                            if (isScrolling && isFlickScrolling && that.enabled) {
                                fireEvent(that, 'scrolling', {
                                    afterFlick: true
                                });
                                lib.animation.requestFrame(arguments.callee);
                            }
                        });
                    }
                }
            }

            function scrollEnd() {
                if (!that.enabled) {
                    return;
                }

                cancelScrollEnd = false;

                setTimeout(function () {
                    if (!cancelScrollEnd && isScrolling) {
                        isScrolling = false;
                        isFlickScrolling = false;

                        if (options.useFrameAnimation) {
                            scrollAnimation && scrollAnimation.stop();
                            scrollAnimation = null;
                        } else {
                            setTransitionStyle(that, '', '');
                        }
                        fireEvent(that, 'scrollend');
                    }
                }, 50);
            }


            var proto = {
                init: function () {
                    this.enable();
                    this.refresh();
                    this.scrollTo(0);
                    return this;
                },

                enable: function () {
                    this.enabled = true;
                    return this;
                },

                disable: function () {
                    var el = this.element;
                    this.enabled = false;

                    if (this.options.useFrameAnimation) {
                        scrollAnimation && scrollAnimation.stop();
                    } else {
                        lib.animation.requestFrame(function () {
                            el.style[stylePrefix + 'Transform'] = getComputedStyle(el)[stylePrefix + 'Transform'];
                        });
                    }

                    return this;
                },

                getScrollWidth: function () {
                    return getBoundingClientRect(this.element).width;
                },

                getScrollHeight: function () {
                    return getBoundingClientRect(this.element).height;
                },

                getScrollLeft: function () {
                    return -getTransformOffset(this).x - this.options.xPadding1;
                },

                getScrollTop: function () {
                    return -getTransformOffset(this).y - this.options.yPadding1;
                },

                getMaxScrollLeft: function () {
                    return -that.maxScrollOffset - this.options.xPadding1;
                },

                getMaxScrollTop: function () {
                    return -that.maxScrollOffset - this.options.yPadding1;
                },

                getBoundaryOffset: function () {
                    return Math.abs(getBoundaryOffset(this, getTransformOffset(this)[this.axis]) || 0);
                },

                refresh: function () {
                    var el = this.element;
                    var isVertical = (this.axis === 'y');
                    var type = isVertical ? 'height' : 'width';

                    if (this.options[type] != null) {
                        // use options
                        el.style[type] = this.options[type] + 'px';
                    } else if (!!this.options.useElementRect) {
                        el.style[type] = 'auto';
                        el.style[type] = getBoundingClientRect(el)[type] + 'px';
                    } else if (el.childElementCount > 0) {
                        var range
                        var rect;
                        var firstEl = el.firstElementChild;
                        var lastEl = el.lastElementChild;

                        if (document.createRange && !this.options.ignoreOverflow) {
                            // use range
                            range = document.createRange();
                            range.selectNodeContents(el);
                            rect = getBoundingClientRect(range);
                        }

                        if (rect) {
                            el.style[type] = rect[type] + 'px';
                        } else {
                            // use child offsets
                            while (firstEl) {
                                if (getBoundingClientRect(firstEl)[type] === 0 && firstEl.nextElementSibling) {
                                    firstEl = firstEl.nextElementSibling;
                                } else {
                                    break;
                                }
                            }

                            while (lastEl && lastEl !== firstEl) {
                                if (getBoundingClientRect(lastEl)[type] === 0 && lastEl.previousElementSibling) {
                                    lastEl = lastEl.previousElementSibling;
                                } else {
                                    break;
                                }
                            }

                            el.style[type] = (getBoundingClientRect(lastEl)[isVertical ? 'bottom' : 'right'] -
                                    getBoundingClientRect(firstEl)[isVertical ? 'top' : 'left']) + 'px';
                        }
                    }

                    this.transformOffset = getTransformOffset(this);
                    this.minScrollOffset = getMinScrollOffset(this);
                    this.maxScrollOffset = getMaxScrollOffset(this);
                    this.scrollTo(-this.transformOffset[this.axis] - this.options[this.axis + 'Padding1']);
                    fireEvent(this, 'contentrefresh');

                    return this;
                },

                offset: function (childEl) {
                    var elRect = getBoundingClientRect(this.element);
                    var childRect = getBoundingClientRect(childEl);
                    if (this.axis === 'y') {
                        var offsetRect = {
                            top: childRect.top - elRect.top - this.options.yPadding1,
                            left: childRect.left - elRect.left,
                            right: elRect.right - childRect.right,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.bottom = offsetRect.top + offsetRect.height;
                    } else {
                        var offsetRect = {
                            top: childRect.top - elRect.top,
                            bottom: elRect.bottom - childRect.bottom,
                            left: childRect.left - elRect.left - this.options.xPadding1,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.right = offsetRect.left + offsetRect.width;
                    }
                    return offsetRect;
                },

                getRect: function (childEl) {
                    var viewRect = getBoundingClientRect(this.viewport);
                    var childRect = getBoundingClientRect(childEl);
                    if (this.axis === 'y') {
                        var offsetRect = {
                            top: childRect.top - viewRect.top,
                            left: childRect.left - viewRect.left,
                            right: viewRect.right - childRect.right,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.bottom = offsetRect.top + offsetRect.height;
                    } else {
                        var offsetRect = {
                            top: childRect.top - viewRect.top,
                            bottom: viewRect.bottom - childRect.bottom,
                            left: childRect.left - viewRect.left,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.right = offsetRect.left + offsetRect.width;
                    }
                    return offsetRect;
                },

                isInView: function (childEl) {
                    var viewRect = this.getRect(this.viewport);
                    var childRect = this.getRect(childEl);
                    if (this.axis === 'y') {
                        return viewRect.top < childRect.bottom && viewRect.bottom > childRect.top;
                    } else {
                        return viewRect.left < childRect.right && viewRect.right > childRect.left;
                    }
                },

                scrollTo: function (offset, isSmooth) {
                    var that = this;
                    var element = this.element;

                    offset = -offset - this.options[this.axis + 'Padding1'];
                    offset = touchBoundary(this, offset);

                    isScrolling = true;
                    if (isSmooth === true) {
                        if (this.options.useFrameAnimation) {
                            var s0 = getTransformOffset(that)[this.axis];
                            var _s = offset - s0;
                            scrollAnimation = new lib.animation(400, lib.cubicbezier.ease, 0, function (i1, i2) {
                                var offset = (s0 + _s * i2).toFixed(2);
                                setTransformStyle(that, offset);
                                fireEvent(that, 'scrolling');
                            });

                            scrollAnimation.onend(scrollEnd);

                            scrollAnimation.play();
                        } else {
                            setTransitionStyle(that, '0.4s', 'ease');
                            setTransformStyle(that, offset);
                            setTransitionEndHandler(scrollEnd, 400);

                            lib.animation.requestFrame(function () {
                                if (isScrolling && that.enabled) {
                                    fireEvent(that, 'scrolling');
                                    lib.animation.requestFrame(arguments.callee);
                                }
                            });
                        }
                    } else {
                        if (!this.options.useFrameAnimation) {
                            setTransitionStyle(that, '', '');
                        }
                        setTransformStyle(that, offset);
                        scrollEnd();
                    }

                    return this;
                },

                scrollToElement: function (childEl, isSmooth) {
                    var offset = this.offset(childEl);
                    offset = offset[this.axis === 'y' ? 'top' : 'left'];
                    return this.scrollTo(offset, isSmooth);
                },

                getViewWidth: function () {
                    return getBoundingClientRect(this.viewport).width;
                },

                getViewHeight: function () {
                    return getBoundingClientRect(this.viewport).height;
                },

                addPulldownHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('pulldownend', function (e) {
                        that.disable();
                        handler.call(that, e, function () {
                            that.scrollTo(0, true);
                            that.refresh();
                            that.enable();
                        });
                    }, false);

                    return this;
                },

                addPullupHandler: function (handler) {
                    var that = this;

                    this.element.addEventListener('pullupend', function (e) {
                        that.disable();
                        handler.call(that, e, function () {
                            that.scrollTo(that.getScrollHeight(), true);
                            that.refresh();
                            that.enable();
                        });
                    }, false);

                    return this;
                },

                addScrollstartHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('scrollstart', function (e) {
                        handler.call(that, e);
                    }, false);

                    return this;
                },

                addScrollingHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('scrolling', function (e) {
                        handler.call(that, e);
                    }, false);

                    return this;
                },

                addScrollendHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('scrollend', function (e) {
                        handler.call(that, e);
                    }, false);

                    return this;
                },

                addContentrenfreshHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('contentrefresh', function (e) {
                        handler.call(that, e);
                    }, false);
                },

                addEventListener: function (name, handler, useCapture) {
                    var that = this;
                    this.element.addEventListener(name, function (e) {
                        handler.call(that, e);
                    }, !!useCapture);
                },

                removeEventListener: function (name, handler) {
                    var that = this;
                    this.element.removeEventListener(name, function (e) {
                        handler.call(that, e);
                    });
                },

                enablePlugin: function (name, options) {
                    var plugin = plugins[name];
                    if (plugin && !this.plugins[name]) {
                        this.plugins[name] = true;
                        options = options || {};
                        plugin.call(this, name, options);
                    }
                    return this;
                }
            }

            for (var k in proto) {
                this[k] = proto[k];
            }
            delete proto;
        }

        lib.scroll = function (el, options) {
            if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
                options = arguments[0];
                if (options.scrollElement) {
                    el = options.scrollElement;
                } else if (options.scrollWrap) {
                    el = options.scrollWrap.firstElementChild;
                } else {
                    throw new Error('no scroll element');
                }
            }

            if (!el.parentNode) {
                throw new Error('wrong dom tree');
            }
            if (options && options.direction && ['x', 'y'].indexOf(options.direction) < 0) {
                throw new Error('wrong direction');
            }

            var scroll;
            if (el.scrollId) {
                scroll = scrollObjs[el.scrollId];
            } else {
                scroll = new Scroll(el, options);
            }
            return scroll;
        }

        lib.scroll.plugin = function (name, constructor) {
            if (constructor) {
                name = name.split(',');
                name.forEach(function (n) {
                    plugins[n] = constructor;
                });
            } else {
                return plugins[name];
            }
        }

    })(window, window['lib'] || (window['lib'] = {}));
    </script>
    <script>/**
     * @fileoverview slider组件 (支持translate3d)
     * @module zepto
     * @namespace lib.Slider
     * @author caochun.cr@taobao.com (曹纯) , siqi.song@alibaba-inc.com (颂奇)
     * @since 2013.8.2
     */
    ;
    (function (win, lib) {
        var hasTransform = function () { // 判断浏览器是否支持transform（仅webkit）
            var ret = ('WebkitTransform' in document.documentElement.style) ? true : false;
            return ret;
        }
        var has3d = function () { // 判断浏览器是否支持3d效果（仅webkit）
            var style,
                    ret = false,
                    div = document.createElement('div'),
                    style = ['&#173;', '<style id="smodernizr">', '@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', '</style>'].join(''),
                    mStyle = document.documentElement.style;
            div.id = 'modernizr';
            div.innerHTML += style;
            document.body.appendChild(div);
            if ('WebkitPerspective' in mStyle && 'webkitPerspective' in mStyle) {
                ret = (div.offsetLeft === 9 && div.offsetHeight === 3);
            }
            div.parentNode.removeChild(div);
            return ret;
        }

        var gv1 = has3d ? 'translate3d(' : 'translate(';
        var gv2 = has3d ? ',0)' : ')';
        var css = function (el, props) {
            for (var key in props) {
                el.style[key] = props[key];
            }
        }
        var removeClass = function (el, cls) {
            el.className = el.className.replace(new RegExp("(?:^|\\s)" + cls + "(?:\\s|$)", "ig"), " ").trim();
        }
        var addClass = function (el, cls) {
            var reg = new RegExp("(?:^|\\s)" + cls + "(?:\\s|$)");
            var ocls = el.className;
            if (!reg.test(ocls)) {
                el.className = ocls + " " + cls
            }
        }
        var TouchSlider = function (container, options) {
            if (!container) return null;
            var defaultConfig = {
                steps: 0,  //步长，每次滑动的距离
                duration: 300,  //动画持续时间
                loop: false,  //动画循环
                play: false,  //动画自动播放
                interval: 5000,  //播放间隔时间，play为true时才有效

                //进阶属性
                wrap: null,  //滑动显示区域，默认为container的第一个子元素。（该元素固定宽高overflow为hidden，否则无法滑动）
                panel: null,  //面板元素，默认为wrap的第一个子元素
                trigger: null,   //触发元素，也可理解为状态元素
                activeTriggerCls: 'sel',  //触发元素内子元素的激活样式
                hasTrigger: false,  //是否需要触发事件，例tab页签就需要click触发
                left: 0,  //panel初始的x坐标
                visible: 1,  //每次滑动几个panels，默认1
                curIndex: 0,  //初始化在哪个panels上，默认0为第一个
                //easing : 'ease-out', //动画公式
                useTransform: (has3d() && hasTransform()) ? true : false, //以translate方式动画，安卓现在也支持了
                lazy: 'data-img', //图片延时加载classname//改为若延迟图片数据从哪里取
                lazyIndex: 1,  //curIndex左右第几屏
                callback: null, //动画结束后触发
                prev: null,  //上一页
                next: null,  //下一页
                activePnCls: 'none',  //prev和next在头尾时的样式
                lazyBind: false,
                degree: 10//touchmove超过设定值就算滑动到下一张图
            };
            this.config = defaultConfig;

            for (var key in options) {
                this.config[key] = options[key];
            }

            if (typeof container === 'string') {
                this.container = document.querySelector(container);
            } else {
                this.container = container;
            }

            if (this.config.lazyBind) {
                this.findEl() && this.lazyBind();
            } else {
                this.findEl() && this.init() && this.increaseEvent();
            }
//    return this.container;
        };
        TouchSlider.prototype = {
            lazyBind: function () {
                var that = this;
                var wrap = that.wrap;
                if (that.config.play) {
                    var timer = setInterval(function () {
                        if (that.panel.children.length) {
                            clearInterval(timer);
                            that.init() && that.increaseEvent();
                        }
                        ;
                    }, that.config.interval)
                }
                function fireSlider(e) {
                    e.preventDefault();
                    wrap.removeEventListener('touchstart', fireSlider, false);
                    that.init() && that.increaseEvent();
                    that.start(e);
                };
                wrap.addEventListener('touchstart', fireSlider, false);

            },
            reset: function (options) {
                if (this.config.loop) {
                    this._oldLoop = true;  //保存之前的值，init需要处理
                }
                options = options || {};
                for (var key in options) {
                    this.config[key] = options[key]
                }
                this.init();
            },
            initEl: function (el) {
                if (typeof el === "string") {
                    return this.container.querySelector(el);
                } else {
                    return el;
                }
            },
            findEl: function () {
                var container = this.container; //= $(this.container);
                this.wrap = this.initEl(this.wrap || container.children[0]);
                this.panel = this.initEl(this.panel || this.wrap.children[0]);
                if (!this.panel || !this.wrap) {
                    return null;
                }
                this.trigger = this.initEl(this.config.trigger);
                this.prev = this.initEl(this.config.prev);
                this.next = this.initEl(this.config.next);
                return this;
            },
            init: function () {
                var wrap = this.wrap,
                        panel = this.panel,
                        panels = this.panel.children,
                        trigger = this.trigger,
                        len = this.len = panels.length,  //子元素的个数
                        margin = parseInt(getComputedStyle(panels[0]).marginLeft) + parseInt(getComputedStyle(panels[0]).marginRight),
                        allWidth = 0,  //滑动容器的宽度
                        status = this.config.visible,  //每次切换多少个panels
                        useTransform = this.config.useTransform,
                        steps = this.config.steps || wrap.clientWidth; //|| wrap.width();  //滑动步长，默认wrap的宽度
                //panels.each(function(n,item){
                [].forEach.call(panels, function (item) {
                    allWidth += item.offsetWidth;
                });

                if (margin) {
                    allWidth += (len - 1) * margin;  //总宽度增加
                    steps += margin;  //步长增加margin
                }
                this.config.steps = steps;

                if (status > 1) {
                    this.config.loop = false;
                }  //如果一页显示的子元素超出1个，或设置了步长，则不支持循环；若自动播放，则只支持一次

                if (useTransform) {
                    css(wrap, {'-webkit-transform': 'translateZ(0)'});
                    css(panel, {'-webkit-backface-visibility': 'hidden'});
                }

                var pages = this._pages = Math.ceil(len / status);  //总页数
                //初始坐标参数
                this._minpage = 0;  //最小页
                this._maxpage = this._pages - 1;  //最大页

                this.updateArrow();

                if (pages <= 1) { //如果没超出一页，则不需要滑动
                    if (trigger) {
                        trigger.style.display = "none";//.hide();
                    }
                    this.loadImg();
                    return null;
                }

                if (this._oldLoop) {  //之前已经复制过的删除
                    var oldpanels = panel.children;
                    oldpanels.removeChild(oldpanels.length - 2);
                    oldpanels.removeChild(oldpanels.length - 1);
                    //oldpanels.eq(oldpanels.length-2).remove();
                    //oldpanels.eq(oldpanels.length - 1).remove();
                }
                if (this.config.loop) {  //复制首尾以便循环
                    panel.appendChild(panels[0].cloneNode(true));
//        this.getImg(panels[len-1]);
                    var lastp = panels[len - 1].cloneNode(true);
                    panel.appendChild(lastp);
//        this.getImg(lastp);
                    lastp.style.cssText += 'position:relative;left:' + (-this.config.steps * (len + 2)) + 'px;';
                    allWidth += panels[0].offsetWidth;
                    allWidth += panels[len - 1].offsetWidth;
                }
                css(panel, {'width': allWidth + "px"});
                if (trigger) {  //如果触发容器存在，触发容器无子元素则添加子元素
                    var temp = '',
                            childstu = trigger.children;
                    if (!childstu.length) {
                        for (var i = 0; i < pages; i++) {
                            temp += '<span' + (i == this.config.curIndex ? " class=" + this.config.activeTriggerCls + "" : "") + '></span>';
                        }
                        trigger.innerHTML = temp
                    }
                    this.triggers = trigger.children;
                    this.triggerSel = this.triggers[this.config.curIndex];  //当前状态元素
                }
                else {
                    this.config.hasTrigger = false;
                }
                this.slideTo(this.config.curIndex);
                return this;
            },
            increaseEvent: function () {
                var that = this,
                        _panel = that.wrap,  //外层容器
                        prev = that.prev,
                        next = that.next,
                        triggers = that.triggers;
                if (_panel.addEventListener) {
                    _panel.addEventListener('touchstart', that, false);
                    _panel.addEventListener('touchmove', that, false);
                    _panel.addEventListener('touchend', that, false);
                    _panel.addEventListener('webkitTransitionEnd', that, false);
                    _panel.addEventListener('msTransitionEnd', that, false);
                    _panel.addEventListener('oTransitionEnd', that, false);
                    _panel.addEventListener('transitionend', that, false);
                }
                if (that.config.play) {
                    that.begin();
                }
                if (prev) {
                    this.prevHandler = function (e) {
                        that.stop();
                        that.backward.call(that, e)
                    };
                    prev.addEventListener("click", this.prevHandler, false);
                }
                if (next) {
                    this.nextHandler = function (e) {
                        that.stop();
                        that.forward.call(that, e)
                    };
                    next.addEventListener('click', this.nextHandler, false);
                }
                if (that.config.hasTrigger && triggers.length) {
                    that.triggerHandler = [];
                    [].forEach.call(triggers, function (item, n) {
                        //triggers.each(function(n,item){
                        //$(item).on('click',function(){
                        //that.triggerHandler.push(function(){
                        var fn = function () {
                            that.slideTo(n);
                        };
                        that.triggerHandler.push(fn);
                        item.addEventListener("click", fn, false);
                    });
                }
            },
            handleEvent: function (e) {
                switch (e.type) {
                    case 'touchstart':
                        this.start(e);
                        break;
                    case 'touchmove':
                        this.move(e);
                        break;
                    case 'touchend':
                    case 'touchcancel':
                        this.end(e);
                        break;
                    case 'webkitTransitionEnd':
                    case 'msTransitionEnd':
                    case 'oTransitionEnd':
                    case 'transitionend':
                        this.transitionEnd(e);
                        break;
                }
            },
            loadImg: function (n) {  //判断加载哪屏图片
                n = n || 0;
                //不考虑循环时候复制的元素
                var panels = this.panel.children;
                if (n < this._minpage) {
                    this.getImg(panels[panels.length - 1]);
                    n = this._maxpage;
                } else if (n > this._maxpage) {
                    this.getImg(panels[panels.length - 2]);
                    n = this._minpage;
                }
                ;
                var status = this.config.visible,
                        lazyIndex = this.config.lazyIndex,
                        arr = [n],
                        total = this._maxpage + 1,
                        _this = this;
                for (var i = 0; i < lazyIndex; i++) {
                    arr.push(n - i - 1);
                    arr.push(n + i + 1);
                }
                arr.forEach(function (item, x) {
                    if (item < 0) {
                        arr[x] = item + total;
                    } else if (item > _this._maxpage) {
                        arr[x] = item - total;
                    }
                    ;
                });
                arr.forEach(function (item) {
                    var start = item * status;
                    if (_this.config.loop) {
                        var end = Math.min(start + status, panels.length - 2);
                    } else {
                        var end = Math.min(start + status, panels.length);
                    }
                    for (var i = start; i < end; i++) {
                        _this.getImg(panels[i]);
                    }
                });
                //todo
            },
            getImg: function (obj) {  //加载图片
                //if(!obj) return;
                //obj = $(obj);
                if (obj.getAttribute('l')) {
                    return;
                }  //已加载
                var that = this,
                        lazy = that.config.lazy,
                        cls = 'img[' + lazy + ']';
                [].forEach.call(obj.querySelectorAll(cls), function (item) {
                    var src = item.getAttribute(lazy);

                    item.setAttribute('src', src);
                    item.removeAttribute(lazy);
                });
                obj.setAttribute('l', '1');
            },
            start: function (e) {  //触摸开始
                var et = e.touches[0];
                //if(this._isScroll){return;}  //滑动未停止，则返回
                this._movestart = undefined;
                this._disX = 0;
                this._coord = {
                    x: et.pageX,
                    y: et.pageY
                };
            },
            move: function (e) {
                if (e.touches.length > 1 || e.scale && e.scale !== 1) return;
                var et = e.touches[0],
                        disX = this._disX = et.pageX - this._coord.x,
                        initLeft = this.config.left,
                        tmleft;
                if (typeof this._movestart == 'undefined') {  //第一次执行touchmove
                    this._movestart = !!(this._movestart || Math.abs(disX) < Math.abs(et.pageY - this._coord.y));
                }
                if (!this._movestart) { //不是上下//todo @zhuxun
                    e.preventDefault();
                    this.stop();
                    if (!this.config.loop) {  //不循环
                        disX = disX / ( (!this.config.curIndex && disX > 0 || this.config.curIndex == this._maxpage && disX < 0 ) ? ( Math.abs(disX) / this.config.steps + 1 ) : 1 );  //增加阻力
                    }
                    tmleft = initLeft - this.config.curIndex * this.config.steps + disX;
                    this.setCoord(this.panel, tmleft);
                    this._disX = disX;
                    //this._left = tmleft;
                }
            },
            end: function (e) {
                if (!this._movestart) {  //如果执行了move
                    var distance = this._disX;
                    if (distance < (0 - this.config.degree)) {
                        e.preventDefault();
                        this.forward();
                    } else if (distance > this.config.degree) {
                        e.preventDefault();
                        this.backward();
                    }
                    distance = null;
                }
            },
            backward: function (e) {
                if (e && e.preventDefault) {
                    e.preventDefault()
                }
                var cur = this.config.curIndex,
                        minp = this._minpage;
                cur -= 1;
                if (cur < minp) {
                    if (!this.config.loop) {
                        cur = minp;
                    }
                    else {
                        cur = minp - 1;
                    }
                }
                this.slideTo(cur);
                this.config.callback && this.config.callback(Math.max(cur, minp), -1);

                var evt = document.createEvent('HTMLEvents');
                evt.initEvent('SliderBackward', true, true);
                this.container.dispatchEvent(evt);
            },
            forward: function (e) {
                if (e && e.preventDefault) {
                    e.preventDefault()
                }
                var cur = this.config.curIndex,
                        maxp = this._maxpage;
                cur += 1;
                if (cur > maxp) {
                    if (!this.config.loop) {
                        cur = maxp;
                    }
                    else {
                        cur = maxp + 1;
                    }
                }
                this.slideTo(cur);
                this.config.callback && this.config.callback(Math.min(cur, maxp), 1);

                var evt = document.createEvent('HTMLEvents');
                evt.initEvent('SliderForward', true, true);
                this.container.dispatchEvent(evt);
            },
            setCoord: function (obj, x) {
                //this.useTransform && obj.css("-webkit-transform",gv1 + x + 'px,0' + gv2) || obj.css("left",x);
                if (this.config.useTransform) {
                    css(obj, {'-webkit-transform': gv1 + x + 'px,0' + gv2})
                } else {
                    css(obj, {left: x + "px"})
                }
                ;
            },
            slideTo: function (cur) {
                var cur = cur || 0;
                this.config.curIndex = cur;  //保存当前屏数
                var panel = this.panel,
                        style = panel.style,
                        scrollx = this.config.left - cur * this.config.steps;
                style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = this.config.duration + 'ms';
                this.setCoord(panel, scrollx);
                this.loadImg(cur);
            },
            transitionEnd: function () {
                var panel = this.panel,
                        style = panel.style,
                        loop = this.config.loop,
                        cur = this.config.curIndex;
                if (loop) {  //把curIndex和坐标重置
                    if (cur > this._maxpage) {
                        this.config.curIndex = 0;
                    } else if (cur < this._minpage) {
                        this.config.curIndex = this._maxpage;
                    }
                    this.setCoord(panel, this.config.left - this.config.curIndex * this.config.steps);
                }
                if (!loop && cur == this._maxpage) {  //不循环的，只播放一次
                    this.stop();
                    this.config.play = false;
                }
                else {
                    this.begin();
                }
                this.update();
                this.updateArrow();
                style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = 0;
                //this._isScroll = false;
            },
            update: function () {
                var triggers = this.triggers,
                        cls = this.config.activeTriggerCls,
                        curIndex = this.config.curIndex;
                if (triggers && triggers[curIndex]) {
                    this.triggerSel && (this.triggerSel.className = '');
                    triggers[curIndex].className = cls;
                    this.triggerSel = triggers[curIndex];
                }
            },
            updateArrow: function () {  //左右箭头状态
                if (this.config.loop) return;  //循环不需要隐藏
                var prev = this.prev,
                        next = this.next;
                if (!prev || !prev.length || !next || !next.length) return;
                var cur = this.config.curIndex,
                        cls = 'none';
                if (cur <= 0) {
                    addClass(prev, cls);
                } else {
                    removeClass(prev, cls);
                }
                //console.log(cur,this._maxpage);
                if (cur >= this._maxpage) {
                    addClass(next, cls)
                } else {
                    removeClass(next, cls)
                }
            },
            begin: function () {
                var that = this;
                if (that.config.play && !that._playTimer) {  //自动播放
                    that.stop();
                    that._playTimer = setInterval(function () {
                        that.forward();
                    }, that.config.interval);
                }
            },
            stop: function () {
                var that = this;
                if (that.config.play && that._playTimer) {
                    clearInterval(that._playTimer);
                    that._playTimer = null;
                }
            },
            destroy: function () {
                var that = this,
                        _panel = that.wrap[0],
                        prev = that.prev,
                        next = that.next,
                        triggers = that.triggers;
                if (_panel.removeEventListener) {
                    _panel.removeEventListener('touchstart', that, false);
                    _panel.removeEventListener('touchmove', that, false);
                    _panel.removeEventListener('touchend', that, false);
                    _panel.removeEventListener('webkitTransitionEnd', that, false);
                    _panel.removeEventListener('msTransitionEnd', that, false);
                    _panel.removeEventListener('oTransitionEnd', that, false);
                    _panel.removeEventListener('transitionend', that, false);
                }
                if (prev) {
                    prev.removeEventListener("click", this.prevHandler, false);
                }
                if (next) {
                    next.removeEventLIstener("click", this.nextHandler, false);
                }
                if (that.config.hasTrigger && triggers.length) {
                    [].forEach.call(triggers, function (item, n) {
                        //triggers.each(function(n,item){
                        //$(item).off('click');
                        item.removeEventListener("click", that.triggerHandler.shift(), false);
                    });
                }
            },
            // 去掉了原$.fn.slider方法，改用这个方法
            attachTo: function (obj, options) {
                //obj = $(obj);
                [].forEach.call(obj, function (item, n) {
                    if (!item.getAttribute('l')) {
                        item.setAttribute('l', true);
                        TouchSlider.cache.push(new TouchSlider(item, options));
                    }
                });
            }
        };
        TouchSlider.cache = [];
        /*$.fn.slider = function(options){
         return this.each(function(n,item){
         if(!item.getAttribute('l')){
         item.setAttribute('l',true);
         TouchSlider.cache.push(new TouchSlider(item,options));
         }
         });
         }*/
        TouchSlider.destroy = function () {
            var cache = TouchSlider.cache,
                    len = cache.length;
            //console.log(TouchSlider.cache);
            if (len < 1) {
                return;
            }
            for (var i = 0; i < len; i++) {
                cache[i].destroy();
            }
            TouchSlider.cache = [];
            //console.log(TouchSlider.cache);
        };

        lib.Slider = TouchSlider;
    })(window, window['lib'] || (window['lib'] = {}))
    </script>
    <script>;
    (function (win, lib) {
        var doc = win.document,
                body = doc.body,
                E_float, E_floatMsg, E_floatContent, E_floatOk, E_floatCancel,
                initDom = false,
                flashTimeoutId;
        ;

        E_float = doc.createElement('div');
        E_float.className = 'c-float-popWrap msgMode hide';
        E_float.innerHTML = ['<div class="c-float-modePop">',
            '<div class="warnMsg"></div>',
            '<div class="content"></div>',
            '<div class="doBtn">',
            '<button class="ok">确定</button>',
            '<button class="cancel">取消</button>',
            '</div>',
            '</div>'].join('');

        E_floatMsg = E_float.querySelector('.warnMsg');
        E_floatContent = E_float.querySelector('.content');
        E_floatOk = E_float.querySelector('.doBtn .ok');
        E_floatCancel = E_float.querySelector('.doBtn .cancel');

        function _extend(a, b) {
            for (var key in b) {
                a[key] = b[key]
            }
            return a;
        }

        function successHandler(e) {
            this.callback && this.callback(e, true);
        }

        function failureHandler(e) {
            this.callback && this.callback(e, false);
        }

        function ModePop(options) {
            this._options = _extend({
                mode: 'msg',
                text: '网页提示',
                useTap: false
            }, options || {});

            this._init();
        }

        _extend(ModePop.prototype, {
            _init: function () {
                var that = this,
                        opt = that._options,
                        mode = opt.mode,
                        text = opt.text,
                        content = opt.content,
                        callback = opt.callback,
                        background = opt.background,
                        clickEvent = opt.useTap ? 'touchend' : 'click'
                        ;

                // set mode
                var classTxt = E_float.className;
                classTxt = classTxt.replace(/(msg|alert|confirm)Mode/i, mode + 'Mode');
                E_float.className = classTxt;

                // set background
                background && (E_float.firstChild.style.background = background);

                // set text & content
                text && (E_floatMsg.innerHTML = text);
                content && (E_floatContent.innerHTML = content);

                // click event
                E_floatOk.removeEventListener('touchend', successHandler);
                E_floatOk.removeEventListener('click', successHandler);
                E_floatCancel.removeEventListener('touchend', successHandler);
                E_floatCancel.removeEventListener('click', successHandler);
                E_floatOk.addEventListener(clickEvent, successHandler, false);
                E_floatCancel.addEventListener(clickEvent, failureHandler, false);
                E_floatOk.callback = E_floatCancel.callback = function () {
                    callback.apply(that, arguments);
                };

                if (!initDom) {
                    initDom = true;
                    doc.body.appendChild(E_float);
                    win.addEventListener('resize', function () {
                        setTimeout(function () {
                            that._pos();
                        }, 500);
                    }, false);
                }
            },

            _pos: function () {
                var that = this;
                var bodyRect;
                var top, left;
                var iW, iH;
                var floatRect;
                var eW, eH;

                if (!that.isHide()) {
                    bodyRect = doc.body.getBoundingClientRect();
                    //top = doc.body.scrollTop;
                    //left = doc.documentElement.scrollLeft;
                    top = -bodyRect.top;
                    left = -bodyRect.left;
                    iW = win.innerWidth;
                    iH = win.innerHeight;
                    floatRect = E_float.getBoundingClientRect();
                    eW = floatRect.width;
                    eH = floatRect.height;

                    E_float.style.top = (top + (iH - eH) / 2) + 'px';
                    E_float.style.left = (left + (iW - eW) / 2) + 'px';
                }
            },

            isShow: function () {
                return E_float.className.indexOf('show') > -1;
            },

            isHide: function () {
                return E_float.className.indexOf('hide') > -1;
            },

            _cbShow: function () {
                var that = this,
                        opt = that._options,
                        onShow = opt.onShow
                        ;

                E_float.style.opacity = '1';
                E_float.className = E_float.className.replace(/\b(?:show|hide)/, 'show');
                onShow && onShow.call(that);
            },

            show: function () {
                var that = this
                        ;

                if (flashTimeoutId) {
                    clearTimeout(flashTimeoutId);
                    flashTimeoutId = undefined;
                }

                if (!that.isShow()) {

                    E_float.style.opacity = '0';
                    E_float.className = E_float.className.replace('hide', '');
                    that._pos();

                    setTimeout(function () {
                        that._cbShow();
                    }, 300);
                    setTimeout(function () {
                        E_float.style.webkitTransition = 'opacity 0.4s linear 0';
                        E_float.style.opacity = '1';
                        //E_float.animate({'opacity': '1'}, 300, 'linear');
                    }, 1);

                } else {
                    that._cbShow();
                }
            },

            _cbHide: function () {
                var that = this,
                        opt = that._options,
                        onHide = opt.onHide
                        ;

                E_float.style.opacity = '0';
                E_float.className = E_float.className.replace(/\s*show|hide/, '') + ' hide';
                onHide && onHide.call(that);
            },

            hide: function () {
                var that = this
                        ;

                if (!that.isHide()) {
                    E_float.style.opacity = '1';
                    E_float.className = E_float.className.replace('show', '');

                    setTimeout(function () {
                        that._cbHide();
                    }, 300);
                    setTimeout(function () {
                        E_float.style.webkitTransition = 'opacity 0.4s linear 0';
                        E_float.style.opacity = '0';
                    }, 1);

                } else {
                    that._cbHide();
                }
            },

            flash: function (timeout) {
                var that = this
                opt = that._options
                ;

                opt.onShow = function () {
                    flashTimeoutId = setTimeout(function () {
                        if (flashTimeoutId) {
                            that.hide();
                        }
                    }, timeout);
                }

                that.show();
            }
        });

        lib.notification = new function () {

            this.simple = function (text, bg, timeout) {
                if (arguments.length == 2) {
                    if (typeof arguments[1] == 'number') {
                        timeout = arguments[1];
                        bg = undefined;
                    }
                }

                var pop = new ModePop({
                    mode: 'msg',
                    text: text,
                    background: bg
                });

                pop.flash(timeout || 2000);
                return pop;
            }

            this.msg = function (text, options) {
                return new ModePop(_extend({
                    mode: 'msg',
                    text: text
                }, options || {}));
            }

            this.alert = function (text, callback, options) {
                return new ModePop(_extend({
                    mode: 'alert',
                    text: text,
                    callback: callback
                }, options || {}));
            }

            this.confirm = function (text, content, callback, options) {
                return new ModePop(_extend({
                    mode: 'confirm',
                    text: text,
                    content: content,
                    callback: callback,
                }, options || {}));
            }

            this.pop = function (options) {
                return new ModePop(options);
            }

        };
    })(window, window['lib'] || (window['lib'] = {}))
    </script>
    <script>;
    (function (win, lib) {
        var doc = window.document;
        var ua = navigator.userAgent;
        var DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;
        var isIPhone = ua.match(/(iPhone\sOS)\s([\d_]+)/i) != null;
        var isIPhone6Plus = isIPhone && DPR == 3;
        var isIpad = ua.match(/(iPad)/);
        var isRetinaDevice = DPR >= 2;
        if (isIpad) {
            isRetinaDevice = true;
        }

        //常量
        //域名收敛地址
        var DEFAULT_HOSTNAME = 'gw.alicdn.com';
        //默认占位图
        var IMG_DEFAULT_SRC = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==';
        //图片url正则
        var REG_IMG_SRC = /^(?:(?:http|https):)?\/\/(.+\.(?:alicdn|taobaocdn|taobao)\.(?:com|net))(\/.*(?:\.(jpg|png|gif|jpeg|webp))?)$/i;
        //cdn后缀正则
        var REG_IMG_EXT = /_(\d+x\d+|cy\d+i\d+|sum|m|b)?(xz|xc)?(q\d+)?(s\d+)?(\.jpg)?(_\.webp)?$/i;
        //四种图片类型:方图，定宽，定高，裁剪
        var IMG_TYPE_SQUARE = 'square';
        var IMG_TYPE_WF = 'widthFixed';
        var IMG_TYPE_HF = 'heightFixed';
        var IMG_TYPE_XZ = 'xz';
        //cdn尺寸对象
        var CDN = {};
        //定宽不定高尺寸列表   110x100000.jpg
        CDN.widths = [110, 150, 170, 220, 240, 290, 450, 570, 580, 620, 790];
        //定高不定宽尺寸列表  10000x 170
        CDN.heights = [170, 220, 340, 500];
        //裁剪成正方形 尺寸列表
        CDN.xzs = [72, 80, 88, 90, 100, 110, 120, 145, 160, 170, 180, 200, 230, 270, 290, 310, 360, 430, 460, 580, 640];
        //正方形尺寸列表
        CDN.square = [16, 20, 24, 30, 32, 36, 40, 48, 50, 60, 64, 70, 72, 80, 88, 90, 100, 110, 120, 125, 128, 145, 180, 190, 200, 200, 210, 220, 230, 240, 250, 270, 300, 310, 315, 320, 336, 360, 468, 490, 540, 560, 580, 600, 640, 720, 728, 760, 970];
        //添加cdn后缀需要过滤的域名列表
        CDN.filterDomains = ['a.tbcdn.cn', 'assets.alicdn.com', 'wwc.taobaocdn.com', 'wwc.alicdn.com'];

        //节流函数
        function throttle(func, wait) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            var later = function () {
                previous = Date.now();
                timeout = null;
                result = func.apply(context, args);
            };
            return function () {
                var now = Date.now();
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                } else if (!timeout) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        }

        var network;
        //获取网络信息
        function getNewWork(callback) {
            var isTaobaoApp = navigator.userAgent.match(/WindVane/i) != null;
            if (isTaobaoApp) {
                if (window.WindVane) {
                    WindVane.call('WVNetwork', 'getNetworkType', {}, function (info) {
                                if (info && info.type) {
                                    network = info.type.toLowerCase();
                                }
                                callback && callback();
                            },
                            function (info) {
                                callback && callback();
                            });
                } else {
                    callback && callback();
                }
            } else {
                callback && callback();
            }
        }

        var isWebp = false;
        //webp格式探测
        function detectWebp(callback) {
            try {
                var webP = new Image();
                webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
                webP.onload = function () {
                    if (webP.height === 2) {
                        isWebp = true;
                    } else {
                        isWebp = false;
                    }
                    callback && callback();
                };
                webP.onerror = function () {
                    isWebp = false;
                    callback && callback();
                };
            } catch (e) {
                callback && callback();
            }
        }

        function extend(target, obj) {
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    target[k] = obj[k];
                }
            }
            return target;
        }

        function getOffset(obj, param) {
            if (!obj) {
                return;
            }
            if (!param) {
                param = {x: 0, y: 0};
            }

            if (obj != window) {
                var el = obj.getBoundingClientRect();
                var l = el.left;
                var t = el.top;
                var r = el.right;
                var b = el.bottom;
            } else {
                l = 0;
                t = 0;
                r = l + obj.innerWidth;
                b = t + obj.innerHeight;
            }
            return {
                'left': l,
                'top': t,
                'right': r + param.x,
                'bottom': b + param.y
            };
        }

        //元素位置比较
        function compareOffset(d1, d2) {
            var left = d2.right > d1.left && d2.left < d1.right;
            var top = d2.bottom > d1.top && d2.top < d1.bottom;
            return left && top;
        }


        var lazyImgs;
        //获取懒加载图片
        function getLazyImgs() {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext('2d');

            lazyImgs = Array.prototype.slice.call(document.querySelectorAll('.' + opts.class));
            if (lazyImgs.length) {
                lazyImgs.forEach(function (el, index) {
                    if (el.getAttribute('data-cache') == '1') {
                        cacheImg(el);
                    }
                });
            }
        }

        //对懒加载图片url域名收敛，添加cdn后缀
        function checkLazyImgs() {
            var srcAttr = opts.dataSrc;
            if (lazyImgs.length) {
                lazyImgs.forEach(function (el, index) {
                    if (el.getAttribute('data-src-checked') != 'true') {
                        var dataSrc = el.getAttribute(srcAttr);
                        var dataSize = el.getAttribute('data-size');
                        var dataType = el.getAttribute('data-type');
                        var param = {};
                        if (dataSize) {
                            param.size = dataSize;
                        }
                        if (dataType) {
                            param.type = dataType;
                        }
                        //判断是否需要原图
                        if (el.attributes['data-original']) {
                            param.isOriginal = true;
                        }
                        if (dataSrc) {
                            el.setAttribute(srcAttr, imgHelper.getNewUrl(dataSrc, param));
                            el.setAttribute('data-src-checked', 'true');
                        }
                    }
                });
            }
        }

        //加载可视区域内的 懒加载图
        function loadImg() {
            var srcAttr = opts.dataSrc;
            var winOffset = getOffset(window, {
                'x': opts.lazyWidth,
                'y': opts.lazyHeight
            });
            if (lazyImgs.length) {
                lazyImgs.forEach(function (el, index) {
                    var dataSrc = el.getAttribute(srcAttr);
                    var elOffset = getOffset(el);
                    var isInViewport = compareOffset(winOffset, elOffset);

                    function load(el) {
                        el.removeAttribute(srcAttr);

                        if (el.tagName === 'IMG') {
                            if (el.getAttribute('data-cache') == 1) {
                                var cachedData = getBaseImgFromCache(dataSrc);
                                el.setAttribute('src', cachedData || dataSrc);
                            } else {
                                el.setAttribute('src', dataSrc);
                            }
                        } else {
                            //非图片元素设置其backgroundImage为真实src
                            el.style.backgroundImage = 'url(' + dataSrc + ')';
                        }

                        el.className = el.className.replace(new RegExp('(^|\\s)' + opts.class + '(\\s|$)'), '');
                    }

                    if (dataSrc) {
                        //wifi环境&& iphone机型，去掉懒加载，一次性加载所有图片
                        if (network == 'wifi' && isIPhone && opts.enalbeIOSWifiLoadMore) {
                            load(el);
                        } else {
                            if (isInViewport) {
                                load(el);
                            }
                        }
                    }

                });
            }
        }

        //根据url缓存该图片图片的base64格式
        function cacheImg(img) {
            var isSupportCached = !!window.localStorage && !!document.createElement('canvas').getContext;

            if (!isSupportCached || img.src.substring(0, 4) == 'data') {
                return;
            }
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext('2d');
            var lsKeyName = 'h5_lib_img_cached_data';
            img.setAttribute('crossOrigin', 'anonymous');
            img.onload = function () {

                if (!this.getAttribute(opts.dataSrc) && img.src.substring(0, 4) != 'data') {
                    var w = this.width;
                    var h = this.height;
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage(this, 0, 0, w, h);
                    var baseImg = canvas.toDataURL();
                    var imgData = {}
                    var url = this.src;
                    imgData[this.src] = baseImg;


                    var cachedData = localStorage.getItem(url);
                    var listKey = localStorage.getItem('h5_lib_img_cached_list');
                    var cachedList = listKey ? JSON.parse(listKey) : [];
                    if (!cachedData) {
                        localStorage.setItem('h5_lib_img_cached_url_' + url, baseImg);

                        //一个域名下，最多cache200张图片
                        if (cachedList.length >= 200) {
                            var firstKey = cachedList.shift();
                            localStorage.removeItem(firstKey);
                        }
                        cachedList.push('h5_lib_img_cached_url_' + url);
                        localStorage.setItem('h5_lib_img_cached_list', JSON.stringify(cachedList));
                    }

                }
            };

        }

        //从loaclstorage获取已缓存图片url对应的base64格式
        function getBaseImgFromCache(url) {
            var isSupportCached = !!window.localStorage;
            var cachedData = localStorage.getItem('h5_lib_img_cached_url_' + url);

            if (isSupportCached && cachedData) {
                return cachedData;
            } else {
                return null;
            }
        }

        /*
         * 获取cdn最佳图片尺寸
         * @param {string|number} curSize :期望尺寸,参数格式为——>'200x220' | 200
         * @param {string} type : 尺寸类型，'square':方图尺寸，'widthFixed':定宽尺寸，'heightFixed':定高尺寸,'xz':裁剪
         * @return {number} cdn size
         * */
        function getBestCdnSize(curSize, type) {
            type = type || IMG_TYPE_SQUARE;
            var sizeList = CDN.square;
            if (!curSize || typeof curSize != 'string' && typeof curSize != 'number') {
                throw new Error('wrong size type');
            }

            if (typeof curSize == 'string' && curSize.match(/^\d+x\d+$/)) {
                if (type == IMG_TYPE_HF) {
                    curSize = curSize.split('x')[1];
                } else {
                    curSize = curSize.split('x')[0];
                }
            }
            switch (type) {
                case IMG_TYPE_WF:
                    sizeList = CDN.widths;
                    break;
                case IMG_TYPE_HF:
                    sizeList = CDN.heights;
                    break;
                case IMG_TYPE_XZ:
                    sizeList = CDN.xzs;
                    break;
            }

            var max = sizeList[sizeList.length - 1];
            var min = sizeList[0];
            var bestSize = 0;
            var baseDpr = opts.baseDpr;


            //非retina设备 cdn size/baseDpr
            if (!isRetinaDevice) {
                curSize = parseInt(curSize / baseDpr);
            }

            if (max <= curSize) {
                return max;
            }
            if (min >= curSize) {
                return min;
            }
            for (var i = sizeList.length; i >= 0; i--) {
                if (sizeList[i] <= curSize) {
                    if (sizeList[i] == curSize) {
                        bestSize = curSize;
                    } else {
                        i < ( sizeList.length - 1 ) && (bestSize = sizeList[i + 1]);
                    }
                    break;
                }
            }
            return bestSize;
        }

        /*
         * 根据配置项输出自定义的图片cdn后缀
         * @param {object} config 配置参数
         * @param {string | number} config.size cdn尺寸
         * @param {string} config.type 尺寸类型，'square':方图尺寸，'widthFixed':定宽尺寸，'heightFixed':定高尺寸,'xz':裁剪
         * @return {string} 拼接好的cdn后缀
         * */
        function getImgExt(config) {
            var size = '';
            var result = '';
            var q = opts.q;
            var sharpen = opts.sharpen;
            var dataSize = opts.defaultSize;
            var dataType = IMG_TYPE_SQUARE;

            if (Object.prototype.toString.call(q) == '[object Array]') {
                q = q[0];
            }

            if (config) {
                if (config.size) {
                    dataSize = config.size;
                }
                if (config.type && config.type.match(new RegExp('^(' + [IMG_TYPE_SQUARE, IMG_TYPE_WF, IMG_TYPE_HF, IMG_TYPE_XZ].join('|') + ')$'))) {
                    dataType = config.type;
                }
            }

            size = getBestCdnSize(dataSize, dataType);
            switch (dataType) {
                case IMG_TYPE_SQUARE:
                    size = size + 'x' + size;
                    break;
                case IMG_TYPE_WF:
                    size = size + 'x10000';
                    break;
                case IMG_TYPE_HF:
                    size = '10000x' + size;
                    break;
                case IMG_TYPE_XZ:
                    size = size + 'x' + size + 'xz';
                    break;
            }

            result = '_' + size;
            result += q + sharpen + '.jpg';

            return result;
        }

        //绑定懒加载所需的事件
        function bindLazyEvent() {
            var scrollHandler = throttle(loadImg, 100);
            window.addEventListener('scroll', scrollHandler, false);
        }

        //配置参数
        var opts = {
            'class': 'lib-img',//img 样式名称
            'size': '320x320',//cdn尺寸
            'sharpen': 's150',//锐化参数
            'dataSrc': 'data-src',
            'q': ['q50', 'q30'],//图片质量[非弱网，弱网],
            'enableLazyload': true,//是否开启懒加载功能，默认true
            'lazyHeight': 0,
            'lazyWidth': 0,
            'enalbeIOSWifiLoadMore': false,//ios&&wifi情况下 是否关闭懒加载,采用一次性加载,默认false,
            'baseDpr': 2,
            'filterDomains': []//自定义过滤的域名命令，适用于不能收敛的域名url
        };

        var imgHelper = {
            /*
             * 输出转换后的图片url
             * @param {string} src 图片url
             * @param {string | object} param 配置参数
             * @return {string}
             * */
            getNewUrl: function (src, param) {

                if (!src || typeof src != 'string') {
                    return '';
                }

                var size = opts.defaultSize + 'x' + opts.defaultSize;
                var q = opts.q;
                if (Object.prototype.toString.call(q) == '[object Array]') {
                    q = q[0];
                }
                var imgExt = '_' + size + q + opts.sharpen + '.jpg';

                //针对错误的图片url进行异常捕获
                try {
                    var originUrl = new lib.httpurl(src);
                } catch (e) {
                    console.log('[error]wrong img url:', src);
                    return src;
                }
                //var originUrl = new lib.httpurl(src);
                var host = originUrl.host;
                var pathname = originUrl.pathname;
                var protocol = originUrl.protocol;

                //过滤域名列表里的cdn不做任何处理
                if (CDN.filterDomains.indexOf(host) != -1) {
                    return originUrl.toString();
                }

                //判断域名收敛
                var hostReg = host.match(/(.+\.(?:alicdn|taobaocdn|taobao|mmcdn)\.com)/);
                if (hostReg && hostReg[0] != DEFAULT_HOSTNAME) {
                    //console.warn && console.warn(hostReg[0] + '不是推荐的图片域名(' + DEFAULT_HOSTNAME + ')-->' + src);
                    originUrl.host = DEFAULT_HOSTNAME;
                }

                //判断是否需要原图，如果需要，则收敛域名，不加任何cnd后缀
                if (param && param.isOriginal) {
                    return originUrl.toString();
                }
                //图片cdn后缀正则校验
                var cdnExt = pathname.match(REG_IMG_EXT);
                //获取图片原始cdn尺寸,类似http://gw.alicdn.com//tps/i4/T1IcIoFvhXXXbfY_Er-640-340.jpg,表示640x340的size
                var originalSizeReg = pathname.match(/-(\d+)-(\d+)\.(?:jpg|png|gif)/);
                if (originalSizeReg) {
                    var result;
                    var originalSize;

                    //如果原始cdn尺寸比默认值小，则取默认值
                    if (parseInt(originalSizeReg[1]) < parseInt(opts.defaultSize)) {
                        result = opts.defaultSize
                    } else {
                        //最大上限最到760,针对那些1125尺寸的图片
                        result = originalSizeReg[1] > 760 ? 760 : originalSizeReg[1];
                    }

                    originalSize = getBestCdnSize(result);

                    imgExt = '_' + originalSize + 'x' + originalSize + q + opts.sharpen + '.jpg';
                }

                if (param && typeof param == 'string') {
                    imgExt = getImgExt({'size': param});
                } else if (param && typeof param == 'object' && Object.keys(param).length > 0) {
                    imgExt = getImgExt(param);
                }

                //gif图片只做域名收敛，不加任何后缀
                //if ((/\.gif/.test(pathname))) {
                //  return originUrl.toString();
                //}

                //png图片后缀q值无效，sharpen值会使图片失真
                if ((/\.png/.test(pathname))) {
                    imgExt = imgExt.replace(/(q\d+)(s\d+)/, '');
                }

                //png|gif不加webp后缀，
                //if (isWebp && !isIPhone) {
                //  if (!(/\.(png|gif)/.test(pathname))) {
                //    imgExt += '_.webp';
                //  }
                //}

                if (isWebp) {
                    imgExt += '_.webp';
                }

                if (!cdnExt) {
                    if (pathname.match(/_\.webp$/g)) {
                        originUrl.pathname = pathname.replace(/_\.webp$/g, imgExt)
                    } else {
                        originUrl.pathname = pathname + imgExt;
                    }
                } else {
                    if (cdnExt[1] || cdnExt[2] || cdnExt[3] || cdnExt[4]) {
                        originUrl.pathname = pathname.replace(REG_IMG_EXT, imgExt)
                    } else if (cdnExt[0].match(/_\.(jpg|png|gif|jpef)/)) {
                        //过滤图片url里有伪cdn后缀格式，如：http://gw.alicdn.com/tfscom/tuitui/i2/TB1R6TyGpXXXXX0XFXXXXXXXXXX_.jpg，则不执行替换，而是在后面添加后缀
                        originUrl.pathname += imgExt;
                    }
                }
                //去掉协议头，https改造
                originUrl.protocol = '';
                return originUrl.toString();

            },
            /*
             * 主动触发懒加载，适用于动态插入图片节点的场景
             * */
            fireLazyload: function () {
                getLazyImgs();
                checkLazyImgs();
                loadImg();
            }
        };

        function __init(options) {
            options = options || {};
            opts = extend(opts, options);
            if (options.filterDomains && options.filterDomains.length) {
                CDN.filterDomains = CDN.filterDomains.concat(options.filterDomains);
            }

            opts.class = opts.class.charAt(0) !== '.' ? opts.class : opts.class.slice(1);
            if (opts.size) {
                opts.defaultSize = getBestCdnSize(opts.size);
            }
            function networkCallback() {

                if (Object.prototype.toString.call(opts.q) == '[object Array]') {
                    if (!isRetinaDevice) {
                        //适配非retina设备下的q值,非弱网上限q90,弱网上限q75
                        var q1 = parseInt(opts.q[0].slice(1));
                        var q2 = parseInt(opts.q[1].slice(1));
                        var highQ = (q1 + 40) >= 90 ? 'q90' : 'q' + (q1 + 40);
                        var lowQ = (q2 + 45) >= 75 ? 'q75' : 'q' + (q2 + 45);
                        opts.q = network ? network == 'wifi' ? highQ : lowQ : highQ;
                    } else {
                        opts.q = network ? network == 'wifi' ? opts.q[0] : opts.q[1] : opts.q[0];
                    }
                }

                getLazyImgs();
                detectWebp(function () {
                    checkLazyImgs();
                    if (opts.enableLazyload) {
                        bindLazyEvent();
                        loadImg();
                    }
                });
            }

            getNewWork(networkCallback);
        }

        lib.img = function (options) {
            __init.apply(imgHelper, arguments);
            return imgHelper;
        };
        lib.img.defaultSrc = IMG_DEFAULT_SRC;


    })(window, window['lib'] || (window['lib'] = {}));
    </script>
    <script>/* jshint ignore:start */

    ;
    (function (win, lib, undef) {
        var doc = win.document;
        var scrollObjs = {};
        var plugins = {};

        function debugLog() {
            if (lib.scroll.outputDebugLog) {
                console.debug.apply(console, arguments);
            }
        }

        function getBoundingClientRect(el) {
            var rect = el.getBoundingClientRect();
            if (!rect) {
                rect = {};
                rect.width = el.offsetWidth;
                rect.height = el.offsetHeight;

                rect.left = el.offsetLeft;
                rect.top = el.offsetTop;
                var parent = el.offsetParent;
                while (parent) {
                    rect.left += parent.offsetLeft;
                    rect.top += parent.offsetTop;
                    parent = parent.offsetParent;
                }

                rect.right = rect.left + rect.width;
                rect.bottom = rect.top + rect.height;
            }
            return rect;
        }

        function getMinScrollOffset(scrollObj) {
            return 0 - scrollObj.options[scrollObj.axis + 'Padding1'];
        }

        function getMaxScrollOffset(scrollObj) {
            var rect = getBoundingClientRect(scrollObj.element);
            var pRect = getBoundingClientRect(scrollObj.viewport);
            var min = getMinScrollOffset(scrollObj);
            if (scrollObj.axis === 'y') {
                var max = 0 - rect.height + pRect.height;
            } else {
                var max = 0 - rect.width + pRect.width;
            }
            return Math.min(max + scrollObj.options[scrollObj.axis + 'Padding2'], min);
        }

        function getBoundaryOffset(scrollObj, offset) {
            if (offset > scrollObj.minScrollOffset) {
                return offset - scrollObj.minScrollOffset;
            } else if (offset < scrollObj.maxScrollOffset) {
                return offset - scrollObj.maxScrollOffset;
            }
        }

        function fireEvent(scrollObj, eventName, extra) {
            debugLog(scrollObj.element.scrollId, eventName, extra);

            var event = doc.createEvent('HTMLEvents');
            event.initEvent(eventName, false, true);
            event.scrollObj = scrollObj;
            if (extra) {
                for (var key in extra) {
                    event[key] = extra[key];
                }
            }
            scrollObj.element.dispatchEvent(event);
            scrollObj.viewport.dispatchEvent(event);
        }

        function Scroll(element, options) {
            var that = this;

            options = options || {};
            options.noBounce = !!options.noBounce;
            options.padding = options.padding || {};

            if (options.isPrevent == null) {
                options.isPrevent = true;
            } else {
                options.isPrevent = !!options.isPrevent;
            }

            if (options.isFixScrollendClick == null) {
                options.isFixScrollendClick = true;
            } else {
                options.isFixScrollendClick = !!options.isFixScrollendClick;
            }

            if (options.padding) {
                options.yPadding1 = -options.padding.top || 0;
                options.yPadding2 = -options.padding.bottom || 0;
                options.xPadding1 = -options.padding.left || 0;
                options.xPadding2 = -options.padding.right || 0;
            } else {
                options.yPadding1 = 0;
                options.yPadding2 = 0;
                options.xPadding1 = 0;
                options.xPadding2 = 0;
            }

            if (options.margin) {
                options.yMargin1 = -options.margin.top || 0;
                options.yMargin2 = -options.margin.bottom || 0;
                options.xMargin1 = -options.margin.left || 0;
                options.xMargin2 = -options.margin.right || 0;
            } else {
                options.yMargin1 = 0;
                options.yMargin2 = 0;
                options.xMargin1 = 0;
                options.xMargin2 = 0;
            }

            options.direction = options.direction || 'y';
            options.inertia = options.inertia || 'normal';

            this.options = options;
            that.axis = options.direction;
            this.element = element;
            this.viewport = element.parentNode;
            this.plugins = {};

            this.element.scrollId = setTimeout(function () {
                scrollObjs[that.element.scrollId + ''] = that;
            }, 1);

            var isPaning = false;
            var isScrollStart = false;
            var isScrolling = false;
            this.viewport.addEventListener('scroll', function (e) {
                if (!isScrollStart) return;

                fireEvent(that, 'scrolling');

                var scrollOffset = that.axis === 'y' ? that.getScrollTop() : that.getScrollLeft();
                setTimeout(function () {
                    var endScrollOffset = that.axis === 'y' ? that.getScrollTop() : that.getScrollLeft();
                    if (scrollOffset === endScrollOffset && !isPaning) {
                        fireEvent(that, 'scrollend');
                    }
                }, 50);
            });

            var pullDirection = false;
            var pullDisplacementStart = 0;
            this.viewport.addEventListener('panstart', function (e) {
                isPaning = true;
                pullDirection = false;
                pullDisplacementStart = 0;
                fireEvent(that, 'scrollstart');
            });

            this.viewport.addEventListener('pan', function (e) {
                var offset = that.axis === 'y' ? that.getScrollTop() : that.getScrollLeft();
                var maxOffset = that.axis === 'y' ? that.getScrollHeight() - that.getViewHeight() : that.getScrollWidth() - that.getViewWidth();
                if (offset === 0 || offset === maxOffset) {
                    if (!pullDisplacementStart) {
                        pullDisplacementStart = e['displacement' + that.axis.toUpperCase()];
                    } else {

                        if (e.displacementY > 0) {
                            pullDirection = that.axis === 'y' ? 'down' : 'right';
                        } else if (e.displacementY < 0) {
                            pullDirection = that.axis === 'y' ? 'up' : 'left';
                        }

                        var boundaryOffset = e.displacementY - pullDisplacementStart;

                        if ((pullDirection === 'down' || pullDirection === 'right') && boundaryOffset > 0 && offset === 0) {
                            fireEvent(that, 'pull' + pullDirection, {
                                boundaryOffset: Math.abs(boundaryOffset)
                            });
                        } else if ((pullDirection === 'up' || pullDirection === 'left') && boundaryOffset < 0 && offset === maxOffset) {
                            fireEvent(that, 'pull' + pullDirection, {
                                boundaryOffset: Math.abs(boundaryOffset)
                            });
                        } else {
                            pullDirection = false;
                            pullDisplacementStart = 0;
                        }
                    }
                } else {
                    pullDirection = false;
                    pullDisplacementStart = 0;
                }
            });

            this.viewport.addEventListener('panend', function (e) {
                isPaning = false;
                if (pullDirection) {
                    fireEvent(that, 'pull' + pullDirection + 'end');
                    pullDirection = false;
                    pullDisplacementStart = 0;
                }

                var scrollOffset = that.axis === 'y' ? that.getScrollTop() : that.getScrollLeft();
                setTimeout(function () {
                    var endScrollOffset = that.axis === 'y' ? that.getScrollTop() : that.getScrollLeft();
                    if (scrollOffset === endScrollOffset && !isPaning) {
                        fireEvent(that, 'scrollend');
                    }
                }, 50);
            });

            // this.viewport.addEventListener('touchmove', function(e) {
            //     if (pullDirection) {
            //         e.preventDefault();
            //     }
            // }, false);

            this.viewport.addEventListener('scrollstart', function (e) {
                isScrollStart = true;
                isScrolling = true;
            }, false);

            this.viewport.addEventListener('scrolling', function (e) {
                isScrolling = true;
            }, false);

            this.viewport.addEventListener('scrollend', function (e) {
                isScrollStart = false;
                isScrolling = false;
            }, false);

            this.viewport.addEventListener('click', function (e) {
                var niceTapEvent = document.createEvent('HTMLEvents');
                niceTapEvent.initEvent('niceclick', true, true);
                e.target.dispatchEvent(niceTapEvent);
            }, false);

            var proto = {
                init: function () {
                    this.viewport.style.overflow = 'hidden';
                    this.viewport.style['overflow' + this.axis.toUpperCase()] = 'scroll';
                    this.viewport.style.webkitTransform = 'translateZ(0)';
                    this.viewport.style.webkitOverflowScrolling = 'touch';
                    this.viewport.style.msOverflowScrolling = 'touch';
                    this.viewport.style.overflowScrolling = 'touch';
                    this.refresh();
                    return this;
                },

                enable: function () {
                    return this;
                },

                disable: function () {
                    return this;
                },

                getScrollWidth: function () {
                    return getBoundingClientRect(this.element).width;
                },

                getScrollHeight: function () {
                    return getBoundingClientRect(this.element).height;
                },

                getScrollLeft: function () {
                    return this.viewport.scrollLeft - this.options.xPadding1;
                },

                getScrollTop: function () {
                    return this.viewport.scrollTop - this.options.yPadding1;
                },

                getMaxScrollLeft: function () {
                    return -getMaxScrollOffset(this) - this.options.xPadding1;
                },

                getMaxScrollTop: function () {
                    return -getMaxScrollOffset(this) - this.options.yPadding1;
                },

                getBoundaryOffset: function () {
                    return Math.abs(getBoundaryOffset(this, this['getScroll' + (this.axis === 'y' ? 'Top' : 'Left')]) || 0);
                },

                refresh: function () {
                    if (this.axis === 'y') {
                        this.element.style.marginTop = -this.options.yPadding1 + 'px';
                        this.element.style.marginBottom = -this.options.yPadding2 + 'px';
                    }


                    fireEvent(this, 'contentrefresh');
                    return this;
                },

                offset: function (childEl) {
                    var elRect = getBoundingClientRect(this.element);
                    var childRect = getBoundingClientRect(childEl);
                    if (this.axis === 'y') {
                        var offsetRect = {
                            top: childRect.top - elRect.top - this.options.yPadding1,
                            left: childRect.left - elRect.left,
                            right: elRect.right - childRect.right,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.bottom = offsetRect.top + offsetRect.height;
                    } else {
                        var offsetRect = {
                            top: childRect.top - elRect.top,
                            bottom: elRect.bottom - childRect.bottom,
                            left: childRect.left - elRect.left - this.options.xPadding1,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.right = offsetRect.left + offsetRect.width;
                    }
                    return offsetRect;
                },

                getRect: function (childEl) {
                    var viewRect = getBoundingClientRect(this.viewport);
                    var childRect = getBoundingClientRect(childEl);
                    if (this.axis === 'y') {
                        var offsetRect = {
                            top: childRect.top - viewRect.top,
                            left: childRect.left - viewRect.left,
                            right: viewRect.right - childRect.right,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.bottom = offsetRect.top + offsetRect.height;
                    } else {
                        var offsetRect = {
                            top: childRect.top - viewRect.top,
                            bottom: viewRect.bottom - childRect.bottom,
                            left: childRect.left - viewRect.left,
                            width: childRect.width,
                            height: childRect.height
                        };

                        offsetRect.right = offsetRect.left + offsetRect.width;
                    }
                    return offsetRect;
                },

                isInView: function (childEl) {
                    var viewRect = getBoundingClientRect(this.viewport);
                    var childRect = this.getRect(childEl);
                    if (this.axis === 'y') {
                        return viewRect.top < childRect.bottom && viewRect.bottom > childRect.top;
                    } else {
                        return viewRect.left < childRect.right && viewRect.right > childRect.left;
                    }
                },

                scrollTo: function (offset) {
                    var that = this;
                    var element = this.element;
                    var type = this.axis === 'y' ? 'Top' : 'Left';

                    this.viewport['scroll' + type] = offset;
                    fireEvent(this, 'scrollend');
                    return this;
                },

                scrollToElement: function (childEl) {
                    var offset = this.offset(childEl);
                    offset = offset[this.axis === 'y' ? 'top' : 'left'];
                    return this.scrollTo(offset);
                },

                getViewWidth: function () {
                    return getBoundingClientRect(this.viewport).width;
                },

                getViewHeight: function () {
                    return getBoundingClientRect(this.viewport).height;
                },

                addPulldownHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('pulldownend', function (e) {
                        that.disable();
                        handler.call(that, function () {
                            that.enable();
                        });
                    }, false);

                    return this;
                },

                addPullupHandler: function (handler) {
                    var that = this;

                    this.element.addEventListener('pullupend', function (e) {
                        that.disable();
                        handler.call(that, function () {
                            that.enable();
                        });
                    }, false);

                    return this;
                },

                addScrollstartHandler: function (handler) {
                    this.element.addEventListener('scrollstart', function (e) {
                        handler.call(that, e);
                    }, false);
                    return this;
                },

                addScrollingHandler: function (handler) {
                    this.element.addEventListener('scrolling', function (e) {
                        handler.call(that, e);
                    }, false);
                    return this;
                },

                addScrollendHandler: function (handler) {
                    this.element.addEventListener('scrollend', function (e) {
                        handler.call(that, e);
                    }, false);
                    return this;
                },

                addContentrenfreshHandler: function (handler) {
                    var that = this;
                    this.element.addEventListener('contentrefresh', function (e) {
                        handler.call(that, e);
                    }, false);
                },

                addEventListener: function () {
                    this.element.addEventListener.apply(this.element, arguments);
                },

                removeEventListener: function () {
                    this.element.removeEventListener.apply(this.element, arguments);
                },

                enablePlugin: function (name, options) {
                    var plugin = plugins[name];
                    if (plugin && !this.plugins[name]) {
                        this.plugins[name] = true;
                        options = options || {};
                        plugin.call(this, name, options);
                    }
                    return this;
                }
            }

            for (var k in proto) {
                this[k] = proto[k];
            }
            delete proto;
        }

        var originScroll = lib.scroll;
        var _isWindowsPhone = (navigator.userAgent.toLowerCase().indexOf('windows phone') > -1);
        lib.scroll = function (el, options) {
            if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
                options = arguments[0];
                if (options.scrollElement) {
                    el = options.scrollElement;
                } else if (options.scrollWrap) {
                    el = options.scrollWrap.firstElementChild;
                } else {
                    throw new Error('no scroll element');
                }
            }

            if (!el.parentNode) {
                throw new Error('wrong dom tree');
            }
            if (options && options.direction && ['x', 'y'].indexOf(options.direction) < 0) {
                throw new Error('wrong direction');
            }

            var scroll;
            if (options.direction === 'x' && !_isWindowsPhone) {
                scroll = originScroll(el, options);
            } else {
                if (el.scrollId) {
                    scroll = scrollObjs[el.scrollId];
                } else {
                    scroll = new Scroll(el, options);
                }
            }
            return scroll;
        }

        lib.scroll.plugin = function (name, constructor) {
            if (constructor) {
                name = name.split(',');
                name.forEach(function (n) {
                    plugins[n] = constructor;
                });
            } else {
                return plugins[name];
            }
        }

    })(window, window['lib'] || (window['lib'] = {}));

    /* jshint ignore:end */
    </script>

    <style>/*html, body {display: -webkit-box; -webkit-box-orient: vertical; height: 100%; margin: 0; padding: 0; overflow: auto;}*/
    /*[weapp-root] {width: 16rem; margin: 0 auto; height: 100%;}*/
    body {
        margin: 0;
    }

    [weapp-host] {
        width: 16rem;
        margin: 0 auto;
    }

    ::-webkit-scrollbar {
        background-color: rgba(0, 0, 0, 0);
        width: 0px;
    }

    /* pop window */

    .layer {
        position: absolute;
        z-index: 100;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(127, 127, 127, 0.5);
    }

    .layer > [pop-window] {
        position: absolute;
        right: 0;
        left: 0;
        bottom: 0;
    }

    /* layout */

    /*
[container] {outline: 3px solid green;}
[atom] {background-color: #f0f0f0;}
*/

    /* layout: display */

    [container],
    [atom],
    [rich] {
        display: -webkit-box;
        overflow: hidden;
        box-sizing: border-box;
    }

    [atom] > span {
        display: block;
        overflow: hidden;
    }

    [w-layout="linearLayout"],
    [w-layout="linearLayout"] > [scroller] > [content] {
        display: -webkit-box;
        -webkit-box-orient: vertical;
    }

    [w-layout="linearLayout"][w-orientation="horizontal"],
    [w-layout="linearLayout"][w-orientation="horizontal"] > [scroller] > [content] {
        -webkit-box-orient: horizontal;
    }

    /* layout: size */

    [w-layout="linearLayout"] > [scroller] {
        display: block;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    [w-layout="linearLayout"] > [scroller] > [content] {
        min-width: 100%;
        min-height: 100%;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > :not([w-width="-1"]):not([w-width="-2"]):not([w-align]) {
        left: 0;
        right: 0;
    }

    [w-layout="linearLayout"] > [scroller] > [content],
    [w-layout="linearLayout"][w-orientation="vertical"][w-height="-1"],
    [w-layout="linearLayout"][w-orientation="horizontal"][w-width="-1"],
    [w-layout="linearLayout"][w-orientation="vertical"] > [scroller] > [content] > [w-height="-1"],
    [w-layout="linearLayout"][w-orientation="horizontal"] > [scroller] > [content] > [w-width="-1"] {
        -webkit-box-flex: 1;
    }

    [w-layout="absoluteLayout"][w-orientation="vertical"][w-width="-1"] {
        width: 100%;
    }

    [w-layout="absoluteLayout"][w-orientation="horizontal"][w-height="-1"] {
        height: 100%;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-width="-1"] {
        left: 0;
        right: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-height="-1"] {
        top: 0;
        bottom: 0;
    }

    [w-weight="1"] {
        -webkit-box-flex: 1;
        width: 100%;
    }

    [w-weight="2"] {
        -webkit-box-flex: 2;
        width: 200%;
    }

    [w-weight="3"] {
        -webkit-box-flex: 3;
        width: 300%;
    }

    /* layout: absolute + gravity */

    [w-layout="absoluteLayout"] {
        -webkit-box-orient: vertical;
    }

    [w-layout="absoluteLayout"] > [scroller] {
        position: relative;
        width: 100%;
        height: 100%;
        -webkit-box-flex: 1;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [container],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [atom],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [rich] {
        position: absolute;
        top: 0;
        left: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [rich] {
        right: 0;
    }

    [weapp-root][w-layout="absoluteLayout"] > [scroller] > [content] > [w-layout="linearLayout"],
    [weapp-root][w-layout="absoluteLayout"] > [scroller] > [content] > [data-type="list"],
    [weapp-root][w-layout="absoluteLayout"] > [scroller] > [content] > [data-type="grid"] {
        position: relative;
    }

    [weapp-root][w-layout="absoluteLayout"] > [scroller] > [content] > [w-layout="absoluteLayout"] {
        position: fixed;
    }

    [weapp-root] [weapp-root][w-layout="absoluteLayout"] > [scroller] > [content] > [w-layout="absoluteLayout"] {
        position: absolute;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="1"],
    .layer > [w-align="1"] {
        top: 0;
        left: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="2"],
    .layer > [w-align="2"] {
        top: 0;
        left: 50%;
        -webkit-transform: translateX(-50%);
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="3"],
    .layer > [w-align="3"] {
        top: 0;
        left: auto;
        right: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="4"],
    .layer > [w-align="4"] {
        top: 50%;
        -webkit-transform: translateY(-50%);
        left: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="5"],
    .layer > [w-align="5"] {
        top: 50%;
        left: 50%;
        -webkit-transform: translate(-50%, -50%);
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="6"],
    .layer > [w-align="6"] {
        top: 50%;
        -webkit-transform: translateY(-50%);
        left: auto;
        right: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="7"],
    .layer > [w-align="7"] {
        top: auto;
        left: 0;
        bottom: 0;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="8"],
    .layer > [w-align="8"] {
        top: auto;
        bottom: 0;
        left: 50%;
        -webkit-transform: translateX(-50%);
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-align="9"],
    .layer > [w-align="9"] {
        top: auto;
        left: auto;
        right: 0;
        bottom: 0;
    }

    [w-orientation="horizontal"][w-align="2"][w-width="-2"],
    [w-orientation="horizontal"][w-align="5"][w-width="-2"],
    [w-orientation="horizontal"][w-align="8"][w-width="-2"] {
        -webkit-box-pack: center;
    }

    [w-orientation="horizontal"][w-align="3"][w-width="-2"],
    [w-orientation="horizontal"][w-align="6"][w-width="-2"],
    [w-orientation="horizontal"][w-align="9"][w-width="-2"] {
        -webkit-box-pack: end;
    }

    [w-orientation="horizontal"][w-width="-2"] > [scroller] {
        width: auto;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > :not([w-width])[w-align="2"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > :not([w-width])[w-align="5"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > :not([w-width])[w-align="8"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-width="-1"][w-align="2"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-width="-1"][w-align="5"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-width="-1"][w-align="8"] {
        width: 100%;
        right: auto;
    }

    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-height="-1"][w-align="4"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-height="-1"][w-align="5"],
    [w-layout="absoluteLayout"] > [scroller] > [content] > [w-height="-1"][w-align="6"] {
        height: 100%;
        bottom: auto;
    }

    .layer > :not([w-width])[w-align="2"],
    .layer > :not([w-width])[w-align="5"],
    .layer > :not([w-width])[w-align="8"],
    .layer > [w-width="-1"][w-align="2"],
    .layer > [w-width="-1"][w-align="5"],
    .layer > [w-width="-1"][w-align="8"] {
        width: 100%;
        right: auto;
    }

    /* layout: align */

    [atom][w-gravity="1"] {
        -webkit-box-align: start;
        -webkit-box-pack: start;
    }

    [atom][w-gravity="2"] {
        -webkit-box-align: start;
        -webkit-box-pack: center;
        margin-left: auto;
        margin-right: auto;
    }

    [atom][w-gravity="3"] {
        -webkit-box-align: start;
        -webkit-box-pack: end;
    }

    [atom][w-gravity="4"] {
        -webkit-box-align: center;
        -webkit-box-pack: start;
    }

    [atom][w-gravity="5"] {
        -webkit-box-align: center;
        -webkit-box-pack: center;
        margin-left: auto;
        margin-right: auto;
    }

    [atom][w-gravity="6"] {
        -webkit-box-align: center;
        -webkit-box-pack: end;
    }

    [atom][w-gravity="7"] {
        -webkit-box-align: end;
        -webkit-box-pack: start;
    }

    [atom][w-gravity="8"] {
        -webkit-box-align: end;
        -webkit-box-pack: center;
        margin-left: auto;
        margin-right: auto;
    }

    [atom][w-gravity="9"] {
        -webkit-box-align: end;
        -webkit-box-pack: end;
    }

    [w-orientation="vertical"] > [scroller] > [content] > [atom][w-gravity="2"],
    [w-orientation="vertical"] > [scroller] > [content] > [atom][w-gravity="5"],
    [w-orientation="vertical"] > [scroller] > [content] > [atom][w-gravity="8"] {
        margin-left: auto;
        margin-right: auto;
    }

    [w-orientation="horizontal"] > [scroller] > [content] > [atom][w-gravity="2"],
    [w-orientation="horizontal"] > [scroller] > [content] > [atom][w-gravity="5"],
    [w-orientation="horizontal"] > [scroller] > [content] > [atom][w-gravity="8"] {
        margin-left: 0;
        margin-right: 0;
    }

    /* visibility */

    [w-invisible="true"] {
        visibility: hidden;
    }

    [w-invisible="true"]:not([w-invisible-space="true"]) {
        display: none !important;
    }

    /* container */

    [container],
    [atom] {
        width: auto;
        height: auto;
        border-style: solid;
        border-width: 0;
        background-repeat: no-repeat;
        background-size: contain;
        background-position: center center;
    }

    [data-type="list"] > [scroller],
    [data-type="grid"] > [scroller] {
        display: block;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    /* container: grid */

    [data-type="grid"] > [scroller] > [content] > [row] {
        display: -webkit-box;
        -webkit-box-orient: horizontal;
    }

    [data-type="grid"] > [scroller] > [content] > [row] > span {
        display: block;
        width: 100%;
    }

    [data-type="grid"][w-grid-column="2"] > [scroller] > [content] > [row] > span {
        width: 50%;
    }

    [data-type="grid"][w-grid-column="3"] > [scroller] > [content] > [row] > span {
        width: 33.33333333333333%;
    }

    [data-type="grid"][w-grid-column="4"] > [scroller] > [content] > [row] > span {
        width: 25%;
    }

    [data-type="grid"][w-grid-column="5"] > [scroller] > [content] > [row] > span {
        width: 20%;
    }

    [data-type="grid"][w-grid-column="6"] > [scroller] > [content] > [row] > span {
        width: 16.666666666666664%;
    }

    /* atom */

    [atom] > span {
        line-height: 1.2;
        text-overflow: ellipsis;
        word-break: break-all;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    [atom][w-line-type="1"] > span {
        text-decoration: overline;
    }

    [atom][w-line-type="2"] > span {
        text-decoration: line-through;
    }

    [atom][w-line-type="3"] > span {
        text-decoration: underline;
    }

    [atom][w-font-style="2"] > span {
        font-style: italic;
    }

    /* atom: label */

    [atom][data-type="label"] > span {
        -webkit-line-clamp: 1;
    }

    [atom][data-type="label"][w-width="-2"] > span {
        -webkit-line-clamp: 20;
        white-space: nowrap;
    }

    /* atom: image */

    [atom][data-type="image"] > span {
        width: 100%;
        height: 100%;
    }

    [atom][data-type="image"] > span > img {
        display: block;
        width: 100%;
        height: 100%;
        -webkit-box-flex: 1;
    }

    [atom][data-type="image"][w-width="-2"] > span > img {
        width: auto;
    }

    [atom][data-type="image"][w-height="-2"] > span > img {
        height: auto;
    }

    [atom][data-type="image"][w-is-circle] > span > img {
        border-radius: 100%;
    }

    /* atom: dashed line */

    [data-type='dashedLine'] {
        border-style: dashed;
        font-size: 0;
        line-height: 0;
        border-width: 0;
    }

    /* rich: tab */

    [data-type="tab"] {
        box-sizing: border-box;
        -webkit-box-orient: vertical;
    }

    [data-type="tabHeader"] {
        display: -webkit-box;
    }

    [data-type="tabHeader"] > span {
        text-align: center;
        display: block;
        -webkit-box-flex: 1;
        height: 100%;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center center;
    }

    [data-type="tabHeader"] > span:after {
        content: '';
        display: inline-block;
        width: 0;
        height: 100%;
        vertical-align: middle;
        overflow: hidden;
    }

    /* rich: banner, slider */

    [data-type="banner"] {
        height: 8.4rem !important;
    }

    [data-type="banner"] .slider-outer,
    [data-type="slider"] .slider-outer {
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: relative;
    }

    [data-type="banner"] .slider-panel,
    [data-type="slider"] .slider-panel {
        display: -webkit-box;
    }

    [data-type="banner"] .slider-img,
    [data-type="slider"] .slider-img {
        width: 100%;
        height: 100%;
    }

    [data-type="banner"] .slider-trigger,
    [data-type="slider"] .slider-trigger {
        position: absolute;
        height: 1rem;
        width: 100%;
        bottom: 0;
        text-align: center;
    }

    [data-type="banner"][w-is-point-hide] .slider-trigger,
    [data-type="slider"][w-is-point-hide] .slider-trigger {
        display: none;
    }

    [data-type="banner"] .slider-trigger span,
    [data-type="slider"] .slider-trigger span {
        display: inline-block;
        width: 0.5rem;
        height: 0.5rem;
        overflow: hidden;
        background-position: 0 -0.5rem;
        background-size: 0.5rem 1rem;
        margin: auto 0.1rem;
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAglJREFUeNrkVjFPwkAUbtVWFAdDwoCwMMhglMXE1QmjdPIn8Bf4CfwAEjc2E2YTpyYGF1wdGQnEBcJANA6makus3zMPvTb0WpuaaHzJ12vvvvfx7t3dO1TXdZUkbUlJ2BIXXPF8nari1wZQB46BA+67Ba6AJvD0ybz8SpvqyeGX4CFwDhQDArkDasCNX3DRlE+BrkRM4bEuc6U5zADtb6SszT6BgnXOXVSb5zlQ0IixsIZMcCeGYFEm+BxDcFkmeBdDcCATNGMImjLBM88JCLcn9gkUnPIJiGo19pGelAvgKCSfNHbC3EjV5hooAw0uCIpQHBo8drXIUf1/BfavXQHiaqmqhiYFrAIadzvAK/CCxXQirzLENtGshwRjwfcxdMoQowq8DlNarVZ6MBhkbNvOEeid+miMOMwNjnAeWblcXjJNM1MoFLRFoY1GI8cwjIder/fmj/RTkHOWpV/v9/vZfD6/IpvveDyelUqlqWVZHzVgnlNxymv0aDab6TAxMuIQV/T1C+r0qFQqqahbRODqi6aco4aSr2laJEHHcRRd1yd4hYw7SWJju7Jt48xXMKoauDPR1y9o06PT6US++QSu/fPbhjssIlSr1XtykIkRh8Usz7mmCEXwn58tRLqFY7aN47aL/n3CcDjcoz4aIw5x/f6JF4fAO8VXvnQh+YTnb5WvX1Wx3wUYAAfBA4JyEMeFAAAAAElFTkSuQmCC");
    }

    [data-type="banner"] .slider-trigger .act-slider,
    [data-type="slider"] .slider-trigger .act-slider {
        background-position: 0 0;
    }

    /* placeholder */

    .placeholder {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
    }

    /* toast */

    .c-float-modePop {
        text-align: center;
    }

    .c-float-modePop .warnMsg {
        color: #fff;
    }

    .c-float-modePop button {
        padding: 0.3rem 0.45rem 0.3rem 0.45rem;
        color: #949494;
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #404040), color-stop(100%, #2e2e2e));
        border: none;
        -webkit-border-radius: 0.1rem;
    }

    .c-float-shade {
        width: 100%;
        display: block;
        position: absolute;
        z-index: 99;
        background-color: #000;
        opacity: 0.5;
        top: 0;
        left: 0;
    }

    .c-float-shade.hide {
        display: none;
    }

    .c-float-popWrap {
        width: 11rem;
        border-radius: 0.1rem;
        z-index: 9999;
        position: absolute;
        overflow: hidden;
    }

    .c-float-popWrap .c-float-modePop {
        background-color: rgba(51, 51, 51, 0.9);
        border-radius: 0.1rem;
        padding: 0.75rem;
    }

    .c-float-popWrap .c-float-modePop .warnMsg {
        padding: 0;
        font-size: 0.7rem;
    }

    .c-float-popWrap .c-float-modePop .content {
        margin-top: 0.5rem;
    }

    .c-float-popWrap .c-float-modePop .doBtn {
        width: 9.5rem;
        margin-top: 0.5rem;
    }

    .c-float-popWrap .c-float-modePop button {
        width: 4rem;
        height: 1.5rem;
        line-height: 1.5rem;
        color: #444;
        font-size: 0.7rem;
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #eeeeee), color-stop(100%, #999999));
        border: none;
        -webkit-border-radius: 0.1rem;
        padding: 0;
        margin: 0.5rem 0.25rem 0;
    }

    .c-float-popWrap.hide {
        display: none;
        -webkit-box-shadow: none;
    }

    .c-float-popWrap.show {
        display: block;
        -webkit-box-shadow: 0 0 0.1rem 0.1rem rgba(0, 0, 0, 0.3);
    }

    .c-float-popWrap.msgMode .c-float-modePop .content,
    .c-float-popWrap.msgMode .c-float-modePop .doBtn {
        display: none;
    }

    .c-float-popWrap.alertMode .c-float-modePop .content {
        display: none;
    }

    .c-float-popWrap.alertMode .c-float-modePop .doBtn .cancel {
        display: none;
    }

    .c-float-popWrap.confirmMode .c-float-modePop .content,
    .c-float-popWrap.confirmMode .c-float-modePop .doBtn {
        display: block;
    }
    </style>

    <script>/**
     * @fileOverview 常用工具方法集合
     */




    var IMG_HOLDER = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==';
    var DEFAULT_IMG_CONFIG = {
        'q': ['q50', 'q30'], //图片质量[非弱网，弱网]
        'enableLazyload': true, //是否开启懒加载功能，默认true
        'dataSrc': 'dataimg'
    };

    var imgConfig = mixin({}, DEFAULT_IMG_CONFIG);

    if (window.WEAPP_IMG_CONFIG) {
        imgConfig = mixin(imgConfig, window.WEAPP_IMG_CONFIG);
    }

    var isWinPhone = navigator.userAgent.match(/windows phone/i) != null;

    //适配 桌面浏览器 , navigator.plugins.length > 0 
    //适配 surface UWP客户端 , UA: windows phone , devicePixelRatio:1.5
    if (navigator.plugins.length > 0 || isWinPhone && window.devicePixelRatio < 2) {
        imgConfig.baseDpr = 1;
    }

    console.log(imgConfig);

    window.fireLazying = false;
    window.imgHelper = new lib.img(imgConfig);

    lib.mtop.config.AntiCreep = true;

    /**
     * query selector all and return array
     *
     * @param  {string} selector
     * @return {Array}
     */
    function $(selector) {
        return Array.prototype.slice.call(document.querySelectorAll(selector));
    }

    function mixin(a, b) {
        var j = JSON.parse(JSON.stringify(a));
        for (var x in b) {
            j[x] = b[x];
        }
        return j;
    }

    /**
     * `foo-bar` to `fooBar`
     *
     * @param  {string} propName
     * @return {string}
     */
    function propToAttr(propName) {
        return 'w-' + propName.replace(/[A-Z]/g, function (ch) {
                    return '-' + ch.toLowerCase();
                });
    }

    /**
     * 处理返回数据中的style绑定
     * 将定义中的"#A0000000"八位颜色值转换成rgba
     */
    function parseColor(value) {
        value = value || '';

        if (value.length !== 9) {
            return value;
        }

        var r = value.slice(3, 5);
        var g = value.slice(5, 7);
        var b = value.slice(7, 9);
        var a = value.slice(1, 3);

        r = parseInt(r, 16);
        g = parseInt(g, 16);
        b = parseInt(b, 16);
        a = ('0X' + a) / 0XFF;

        var rgba = 'rgba(' + [r, g, b, a].join(',') + ')';

        return rgba;
    }

    /**
     * REM单位换算 px -> rem
     */
    function px2Rem(px) {
        return px / 40;
    }

    /**
     * REM单位换算 px -> px
     */
    function px2FontSize(px) {
        return (dpr || 1) * px;
    }

    /**
     * 支持两种设置属性的方式
     *
     * @example
     * setProp(obj, 'a', 1)
     * setProp(obj, 'b', 2)
     *
     * @example
     * setProp(obj, {a: 1, b: 2})
     */
    function setProp(obj, key, value) {
        var src;

        if (!obj) {
            obj = {};
        }

        if (arguments.length > 2) {
            obj[key] = value;
            src = {};
            src[key] = value;
            return src;
        }
        else if (typeof arguments[1] === 'object') {
            src = arguments[1];
            for (key in src) {
                value = src[key];
                obj[key] = value;
            }
            return src;
        }

        return {};
    }

    /**
     * Object.defineProperty的快捷方式
     * 默认enumerable为true
     *
     * @example
     * defineProp(obj, 'a',
     *   function () {return this.v;},
     *   function (v) {this.v = v;}
     * )
     *
     * @example
     * defineProp(obj, 'a', {
 *   get: function () {return this.v;},
 *   set: function (v) {this.v = v;}
 * })
     *
     * @param  {object} obj
     * @param  {string} key
     * @param  {Function} getter
     * @param  {Function} setter
     * @return {object}
     */
    function defineProp(obj, key, getter, setter) {
        return Object.defineProperty(obj, key, {
            get: getter, set: setter, enumerable: true, configurable: true
        });
    }

    /**
     * parse data by a certain path
     *
     * @example
     * parsePath({a: 1}, 'a')
     * // 1
     *
     * @example
     * parsePath([{a: 1}, {b: 2}], '[?].a', 1)
     * // undefined
     *
     * @example
     * parsePath([{a: 1}, {b: 2}], '[?].b', 1)
     * // 2
     *
     * @example
     * parsePath({a:[{a: 1}, {b: 2}]}, 'a[?].b', 1)
     * // 2
     *
     * @example
     * parsePath({a:[{a: 1}, {b: 2}]}, 'a.[?].b', 1)
     * // 2
     *
     * @param  {object} data
     * @param  {string} path
     * @param  {number} index
     * @return {any}
     */
    function parsePath(data, path, index) {
        var keyList = [];
        var isArray = (typeof index === 'number');
        var result;

        if (!path) {
            return data;
        }

        path.split('.').forEach(function (key) {
            var match = key.match(/^\[(.+)\]$/);
            if (match) {
                keyList.push(match[1]);
            }
            else {
                match = key.match(/^(.+)\[(.+)\]$/);
                if (match) {
                    keyList.push(match[1]);
                    keyList.push(match[2]);
                }
                else if (key === '_size_') {
                    keyList.push('length');
                }
                else {
                    keyList.push(key);
                }
            }
        });

        result = data;
        keyList.forEach(function (key) {
            if (key === '?' && isArray) {
                key = index;
            }
            if (result) {
                result = result && result[key];
            }
        });

        return result;
    }

    /**
     * 对 mtop 请求的二次封装，过程中会判断登录状态
     *
     * @param  {object}   request {api, apiVersion, param}
     * @param  {Function} done
     */
    function mtopRequest(request, done) {

        function success(result) {
            if (!fireLazying && imgHelper) {
                fireLazying = true;
                setTimeout(function () {
                    fireLazying = false;
                    if (imgHelper) {
                        imgHelper.fireLazyload();
                    }
                }, 500);
            }

            done(null, result.data);

        }

        function failure(result) {
            var err = '网络错误';
            if (result && result.ret && result.ret[0]) {
                err = result.ret[0];
                if (err.indexOf('NOT_LOGIN') !== -1 && !GLOBAL_CONFIG.ISPC) {
                    lib.login.goLogin();
                    return;
                }
            }

            done(null, result.data);
        }

        if (typeof done !== 'function') {
            done = function () {
            };
        }

        /* debug start */
        // switch (request.api) {
        //   case 'mtop.geb.view.getPageView':
        //     success(VIEW_MOCK);
        //   case 'mtop.taobao.geb.shopinfo.queryshopinfo':
        //     success(SHOP_MOCK);
        //   case 'mtop.shop.bigpromotion.bookingItem.query':
        //     success(ITEM_MOCK);
        //   default:
        //     return;
        //     break;
        // }
        /* debug end*/

        lib.mtop.request({
            api: request.api,
            v: request.apiVersion || '2.0',
            data: request.param || {}
        }, success, failure);
    }
    </script>
    <script>var formatter = {};

    formatter.abbr = function (val) {
        if (Number(val) >= 10000) {
            return parseFloat(val / 10000).toFixed(2) + '万';
        }
        return val;
    };

    formatter.since = function (val) {
        var t = new Date(Number(val));
        if ((Object.prototype.toString.call(t) !== '[object Date]') || (t.toString() === 'Invalid Date')) {
            return '';
        }
        var month = t.getMonth() + 1;
        var date = t.getDate();
        var hour = t.getHours();
        var minute = t.getMinutes();
        return month + '月' + date + '日 ' + hour + ':' + minute;
    };

    formatter.near = function (val) {
        var t = Number(val);
        var n = new Date().getTime();
        var h;
        var diff = t - n;
        if (diff > 86400000) {
            // 超过一天
            var d = Math.floor(diff / 86400000);
            h = Math.floor((diff - (d * 86400000)) / 3600000);
            if (h !== 0) {
                return d + '天' + h + '小时';
            } else {
                return d + '天';
            }
        } else {
            // 少于一天
            h = Math.floor(diff / 3600000);
            var m = Math.floor((diff - (h * 3600000)) / 60000);
            if (m !== 0) {
                return h + '小时' + m + '分钟';
            } else {
                return h + '小时';
            }
        }
    };
    </script>
    <script>var domStructure = {};

    domStructure.bindAtom = function (proto) {
        setProp(proto, {
            setDom: domStructure.atomDom
        });
    };

    domStructure.bindContainer = function (proto) {
        setProp(proto, {
            setDom: domStructure.containerDom,
            clearDom: domStructure.containerDomClear,
            setData: domStructure.setData,
            appendChild: domStructure.appendChild,
            setHeader: domStructure.setHeader,
            setFooter: domStructure.setFooter,
            initScroller: domStructure.initScroller,
            refreshScroller: domStructure.refreshScroller,
            checkEmptyMsg: domStructure.checkEmptyMsg,
            showEmptyMsg: domStructure.showEmptyMsg,
            hideEmptyMsg: domStructure.hideEmptyMsg,
            reloadPage: domStructure.reloadPage,
            loadNextPage: domStructure.loadNextPage
        });
    };

    domStructure.bindSlider = function (proto) {
        setProp(proto, {
            setDom: domStructure.sliderDom,
            clearDom: domStructure.containerDomClear,
            setData: domStructure.setData,
            appendChild: domStructure.appendSlide,
            initSlider: domStructure.initSlider
        });
    };


    domStructure.atomDom = function () {
        var root = document.createElement('div');
        var content = document.createElement('span');

        root.appendChild(content);

        this.root = root;
        this.root.setAttribute('data-type', this.type);
        this.root.setAttribute('atom', '');

        this.content = content;
    };


    domStructure.containerDom = function () {
        var root = document.createElement('div');
        var scroller = document.createElement('div');
        var content = document.createElement('div');

        scroller.appendChild(content);
        root.appendChild(scroller);

        this.root = root;
        this.root.setAttribute('data-type', this.type);
        this.root.setAttribute('container', '');

        this.scroller = scroller;
        this.scroller.setAttribute('scroller', '');

        this.content = content;
        this.content.setAttribute('content', '');
    };

    domStructure.setData = function () {
        var changes = this.setProp.apply(this.data, arguments);
        return changes;
    };

    domStructure.containerDomClear = function () {
        this.content.innerHTML = '';
        this.childViewIds = [];
    };

    domStructure.initScroller = function (direction) {
        var Scroll = lib.scroll;
        var self = this;

        this.scrollerInstance = new Scroll({
            scrollElement: this.content,
            direction: direction
        });

        this.scrollerInstance.init();
        this.style._scrolled = true;

        this.scrollerInstance.addScrollendHandler(function (e) {
            imgHelper.fireLazyload();
        });

        this.content.addEventListener('pulldownend', function (e) {
            // if (self.view.needDownRefresh && !self.pageLoading) {
            //   self.pageLoading = true;
            //   self.reloadPage();
            // }
        });
        this.content.addEventListener('pullupend', function (e) {
            // if (self.view.needNextPage && !self.pageLoading) {
            //   self.pageLoading = true;
            //   self.loadNextPage();
            // }
        });

        setTimeout(function () {
            var realScroller = this.content;
            while (realScroller && realScroller !== document.body) {
                if (getComputedStyle(realScroller.parentNode).overflowY === 'scroll') {
                    if (realScroller.scrollHeight > realScroller.parentNode.scrollHeight) {
                        break;
                    }
                }
                realScroller = realScroller.parentNode;
            }

            function onscroll(e) {
                var maxScrollY = realScroller.scrollHeight - realScroller.parentNode.clientHeight;
                if (realScroller.scrollTop > maxScrollY - 10) {
                    if (self.view.needNextPage && !self.pageLoading) {
                        self.pageLoading = true;
                        self.loadNextPage();
                    }
                }
            }

            if (realScroller === document.body) {
                document.addEventListener('scroll', onscroll.bind(this));
            }
            else {
                realScroller.addEventListener('scroll', onscroll.bind(this));
            }

        }.bind(this), 1000);
    };

    domStructure.reloadPage = function () {
        console.log('page loading');

        var self = this;
        var page = PageView.get(this.pageId);
        var data = this.view.dataBinding;
        var param = {};
        var request = {};

        Object.keys(data.param).forEach(function (key) {
            param[key] = data.param[key];
        });

        param.direction = -1;
        param.pageSize = parseInt(data.pageSize, 10) || 10;
        param.curPage = 1;
        param.timestamp = this.lastTimestamp;
        param.id = this.lastId;

        request = {
            api: data.apiName,
            apiVersion: data.apiVersion,
            param: param,
            needLogin: data.needLogin,
            name: data.apiAlias || data.apiName
        };

        page.parseMtop(self, request, function (name, result) {
            var content = self.content;

            Array.prototype.slice.call(content.children).forEach(function (node) {
                if (!node.hasAttribute('header') && !node.hasAttribute('footer')) {
                    content.removeChild(node);
                }
            });
            self.childViewIds = [];

            page.setCell(self, self.view);
            self.pageLoading = false;
            self.curPage = (self.curPage || 1) + 1;
            console.log('page loaded');
        });
    };

    domStructure.loadNextPage = function () {
        console.log('page loading');

        var self = this;
        var page = PageView.get(this.pageId);
        var data = this.view.dataBinding;
        var param = {};
        var request = {};

        Object.keys(data.param).forEach(function (key) {
            param[key] = data.param[key];
        });

        param.direction = 1;
        param.pageSize = parseInt(data.pageSize, 10) || 10;
        param.curPage = (this.curPage || 1) + 1;
        param.timestamp = this.lastTimestamp;
        param.id = this.lastId;

        request = {
            api: data.apiName,
            apiVersion: data.apiVersion,
            param: param,
            needLogin: data.needLogin,
            name: data.apiAlias || data.apiName,
            append: true
        };

        page.parseMtop(self, request, function (name, result, oldLength) {
            page.setCell(self, self.view, oldLength);
            self.pageLoading = false;
            self.curPage = (self.curPage || 1) + 1;
            console.log('page loaded');
        });
    };

    domStructure.checkEmptyMsg = function () {
        var content = this.content;
        var hasChild;

        Array.prototype.forEach.call(content.children, function (node) {
            if (node.hasAttribute('header') || node.hasAttribute('footer')) {
                return;
            }
            hasChild = true;
        });
        if (hasChild) {
            this.hideEmptyMsg();
        }
        else {
            this.showEmptyMsg();
        }
    };

    domStructure.showEmptyMsg = function () {
        var emptyMsg = this.view.emptyMsg;
        var img, label, container;

        if (emptyMsg && !this.emptyDom) {
            img = document.createElement('img');
            img.src = '//gw.alicdn.com/tps/i4/T1yktqFT4eXXcsSpY4-200-200.png';
            img.style.width = '5rem';
            img.style.height = '5rem';
            img.style.margin = '0 auto 0.5rem';
            img.style.display = 'block';

            label = document.createElement('div');
            label.style.textAlign = 'center';
            label.textContent = emptyMsg;
            label.style.fontSize = '0.7rem';

            container = document.createElement('div');
            container.style.position = 'absolute';
            container.style.top = '50%';
            container.style.width = '100%';
            container.style.webkitTransform = 'translateY(-50%)';

            container.appendChild(img);
            container.appendChild(label);

            this.content.style.height = window.innerHeight + 'px';
            this.content.appendChild(container);
            this.emptyDom = container;
        }
    };

    domStructure.hideEmptyMsg = function () {
        if (this.emptyDom) {
            this.root.removeChild(this.emptyDom);
            delete this.content.style.height;
            delete this.emptyDom;
        }
    };

    domStructure.refreshScroller = function () {
        var self = this;
        clearTimeout(this.scrollerRefreshTimer);

        this.scrollerRefreshTimer = setTimeout(function () {
            var scrollerInstance = self.scrollerInstance;
            if (scrollerInstance) {
                scrollerInstance.refresh();
            }
        }, 300);
    };

    domStructure.appendChild = function () {
        var self = this;
        var footerRoot = this.footer ? this.footer.root : null;
        var childWElements = Array.prototype.slice.call(arguments);
        childWElements.forEach(function (wElement) {
            self.content.insertBefore(wElement.root, footerRoot);
            wElement.parentViewId = self.viewId;
            self.childViewIds.push(wElement.viewId);
            wElement.reflow();
        });
    };

    domStructure.setHeader = function (header) {
        if (this.header) {
            this.header.parentViewId = null;
            this.headerViewId = null;
            this.content.removeChild(this.header.root);
        }
        header.root.setAttribute('header', '');
        header.parentViewId = this.viewId;
        this.headerViewId = header.viewId;
        this.content.insertBefore(header.root, this.content.firstChild);
        this.header = header;
        header.reflow();
    };

    domStructure.setFooter = function (footer) {
        if (this.footer) {
            this.footer.parentViewId = null;
            this.footerViewId = null;
            this.content.removeChild(this.footer.root);
        }
        footer.root.setAttribute('footer', '');
        footer.parentViewId = this.viewId;
        this.footerViewId = footer.viewId;
        this.content.appendChild(footer.root);
        this.footer = footer;
        footer.reflow();
    };


    domStructure.sliderDom = function () {
        var self = this;
        var root = document.createElement('div');

        var sliderOuter = document.createElement('div'); // slider包裹层
        sliderOuter.className = 'slider-outer';

        var sliderTrigger = document.createElement('div'); // slider小红点
        sliderTrigger.className = 'slider-trigger';

        var content = document.createElement('div'); // slider项容器
        content.className = 'slider-panel'; // lib.slider依赖

        sliderOuter.appendChild(content);
        sliderOuter.appendChild(sliderTrigger);

        root.appendChild(sliderOuter);

        this.root = root;
        this.root.setAttribute('data-type', this.type);
        this.root.setAttribute('rich', '');

        this.content = content;
        this.content.setAttribute('data-type', 'cells');
    };

    domStructure.appendSlide = function () {
        var self = this;
        var childWElements = Array.prototype.slice.call(arguments);
        childWElements.forEach(function (wElement) {
            self.content.appendChild(wElement.root);
            wElement.parentViewId = self.viewId;
            self.childViewIds.push(wElement.viewId);
        });
        setTimeout(function () {
            self.initSlider();
        }, 100);
    };

    domStructure.initSlider = function () {
        var root = this.root;
        var settings;
        var defaultWidth;

        if (GLOBAL_CONFIG.ISPC) {
            defaultWidth = 320;
        }
        else {
            defaultWidth = 320 * rem / 20; // 适配相关
        }

        [].forEach.call(this.content.children, function (item) {
            if (item.getAttribute('w-width') === '-1') {
                item.removeAttribute('w-width');
                item.style.width = defaultWidth + 'px'; // 适配相关
            }
        });

        if (this.sliderInstance) {
            return;
        }

        settings = {
            visible: 1,
            step: defaultWidth,
            margin: 0,
            trigger: '.slider-trigger',
            lazy: 'dataimg',
            activeTriggerCls: 'act-slider',
            play: !!this.data.autoScrollEnabled,
            loop: !!this.data.autoScrollEnabled
        };
        if (GLOBAL_CONFIG.ISPC) {
            settings.play = false;
            settings.loop = false;
        }

        this.sliderInstance = new lib.Slider(root, settings);
    };
    </script>
    <script>var styler = {};


    styler.width = function () {
        var element = this.root;
        var style = this.style;
        var box = this.box;

        defineProp(style, 'width',
                function () {
                    return this._width;
                },
                function (v) {
                    var width = parseInt(v, 10);
                    if (width >= 0) {
                        element.style.width = px2Rem(width) + 'rem';
                        this._width = width;
                    }
                    else {
                        element.setAttribute('w-width', v);
                        element.style.width = '';
                        this._width = v;
                    }
                    box.changed = true;
                }
        );
    };

    styler.height = function () {
        var element = this.root;
        var style = this.style;
        var box = this.box;

        defineProp(style, 'height',
                function () {
                    return this._height;
                },
                function (v) {
                    var fontSize = this.fontSize;
                    var height = parseInt(v, 10);
                    if (height >= 0) {
                        if (fontSize > 0 && (fontSize + 2 > height)) {
                            height = fontSize + 2;
                        }
                        element.style.height = px2Rem(height) + 'rem';
                        this._height = height;
                    }
                    else {
                        element.setAttribute('w-height', v);
                        element.style.height = '';
                        this._height = v;
                    }
                    box.changed = true;
                }
        );
    };

    styler.backgroundColor = function () {
        var element = this.root;
        var style = this.style;

        defineProp(style, 'backgroundColor',
                function () {
                    return this._backgroundColor;
                },
                function (v) {
                    v = parseColor(v);
                    if (!this._backgroundImage) {
                        element.style.backgroundColor = v ? v : '';
                    }
                    this._backgroundColor = v;
                }
        );
    };

    styler.backgroundImage = function () {
        var element = this.root;
        var style = this.style;

        defineProp(style, 'backgroundImage',
                function () {
                    return this._backgroundImage;
                },
                function (v) {
                    element.style.backgroundImage = v ? 'url(' + v + ')' : 'none';
                    this._backgroundImage = v;
                }
        );
    };

    styler.scroll = function () {
        var self = this;
        var element = this.root;
        var scroller = this.scroller;
        var content = this.content;
        var style = this.style;

        var attrName = propToAttr('scroll');
        var privateName = '_' + 'scroll';

        defineProp(style, 'scroll',
                function () {
                    return this[privateName];
                },
                function (v) {
                    var isVertical;
                    var isHorizontal;

                    if (!self.needScroller || this._scrolled) {
                        return;
                    }

                    isVertical = parseInt(v, 10) === 1;
                    isHorizontal = parseInt(v, 10) === 2;

                    this[privateName] = v;
                    element.setAttribute(attrName, v);

                    if (isVertical) {
                        self.initScroller('y');
                    }
                    else if (isHorizontal) {
                        self.initScroller('x');
                    }
                }
        );
    };

    styler.fontSize = function () {
        var element = this.root;
        var style = this.style;

        defineProp(style, 'fontSize',
                function () {
                    return this._fontSize;
                },
                function (v) {
                    var height = this.height;
                    element.style.fontSize = px2Rem(v) + 'rem';
                    if (height >= 0 && (parseInt(v) + 2) > height) {
                        this.height = parseInt(v) + 2;
                    }
                    this._fontSize = v;
                }
        );
    };

    styler.fontWeight = function () {
        var element = this.root;
        var style = this.style;

        defineProp(style, 'fontWeight',
                function () {
                    return this._fontWeight;
                },
                function (v) {
                    element.style.fontWeight = (v > 400) ? 'bold' : '';
                    this._fontWeight = v;
                }
        );
    };

    styler.textColor = function () {
        var element = this.root;
        var style = this.style;

        defineProp(style, 'textColor',
                function () {
                    return this._textColor;
                },
                function (v) {
                    v = parseColor(v);
                    element.style.color = v;
                    this._textColor = v;
                }
        );
    };

    styler.lines = function () {
        var self = this;
        var element = this.content;
        var LINE_HEIGHT = 1.2;

        this.setStyleProp('lines',
                function () {
                    return this._lines;
                },
                function (v) {
                    var lines = parseInt(v, 10) || 1;

                    if (lines > 0 && lines < 20) {
                        element.style.webkitLineClamp = lines;
                        element.style.height = lines * LINE_HEIGHT + 'em';
                    }
                    else {
                        element.style.webkitLineClamp = 20;
                        element.style.height = '';
                    }
                    this._lines = v;
                }
        );
    };

    styler.textShadowColor = function () {
        var self = this;
        var element = this.content;

        this.setStyleProp('textShadowColor',
                function () {
                    return this._textShadowColor;
                },
                function (v) {
                    v = parseColor(v);
                    this._textShadowColor = v;
                    element.style.textShadow = px2Rem(this._textShadowOffsetX || 0) + 'rem ' +
                            px2Rem(this._textShadowOffsetY || 0) + 'rem ' +
                            (this._textShadowColor || 'transparent');
                }
        );
    };

    styler.textShadowOffsetX = function () {
        var self = this;
        var element = this.content;

        this.setStyleProp('textShadowOffsetX',
                function () {
                    return this._textShadowOffsetX;
                },
                function (v) {
                    this._textShadowOffsetX = parseInt(v, 10);
                    element.style.textShadow = px2Rem(this._textShadowOffsetX || 0) + 'rem ' +
                            px2Rem(this._textShadowOffsetY || 0) + 'rem ' +
                            (this._textShadowColor || 'transparent');
                }
        );
    };

    styler.textShadowOffsetY = function () {
        var self = this;
        var element = this.content;

        this.setStyleProp('textShadowOffsetY',
                function () {
                    return this._textShadowOffsetY;
                },
                function (v) {
                    this._textShadowOffsetY = parseInt(v, 10);
                    element.style.textShadow = px2Rem(this._textShadowOffsetX || 0) + 'rem ' +
                            px2Rem(this._textShadowOffsetY || 0) + 'rem ' +
                            (this._textShadowColor || 'transparent');
                }
        );
    };

    styler.dashColor = function () {
        var root = this.root;
        this.setStyleProp('dashColor',
                function () {
                    return this._dashColor;
                },
                function (v) {
                    v = parseColor(v);
                    root.style.borderColor = v;
                    this._dashColor = v;
                }
        );
    };

    styler.dashGap = function () {
        var root = this.root;
        this.setStyleProp('dashGap',
                function () {
                    return this._dashGap;
                },
                function (v) {
                    // 前端只支持1为dashed，其他为solid
                    v = parseInt(v, 10) || 0;
                    root.style.borderStyle = (v === 0 ? 'solid' : 'dashed');
                    this._dashGap = v;
                }
        );
    };

    styler.dashThickness = function () {
        var self = this;
        var root = this.root;
        this.setStyleProp('dashThickness',
                function () {
                    return this._dashThickness;
                },
                function (v) {
                    setTimeout(function () {
                        var propName = (self.style.orientation === 'horizontal') ? 'borderRightWidth' : 'borderTopWidth';
                        root.style[propName] = px2Rem(v || 1) + 'rem';
                    }, 13);
                    this._dashThickness = v;
                }
        );
    };

    </script>
    <script>var actionMap = {
        openURL: openURL,
        sendRequest: sendRequest,
        changeData: changeData,
        changeStyle: changeStyle,
        refreshView: refreshView,
        refresh: refresh,
        openPopWindow: openPopWindow,
        dismissPopWindow: dismissPopWindow,
        phoneCall: phoneCall,
        toast: toast,
        userTrack: userTrack,
        share: share
    };
    /**
     * [share description]
     * @param  {[type]} params {imageUrl, description, shareUrl, shareUrlParams ,shareFrom}
     *
     * 唤起分享组件
     */
    function share(params, callback, element, page) {

        Object.keys(params).forEach(function (key) {
            if ((params[key] || '').toString().match(/^\$/)) {
                page.parseData(element, params[key], function (value) {
                    params[key] = value;
                });
            }
        });

        if (window.WindVane) {
            var shareParams = {
                // 分享内容的标题
                title: params.description,
                // 要分享的内容
                text: params.description,
                // 要分享的图片地址
                image: params.imageUrl,
                // 要分享的 URL
                url: params.shareUrl
            };
            window.WindVane.call('TBSharedModule', 'showSharedMenu', shareParams, callback, callback);
        }

    }
    /**
     * [openURL description]
     * @param  {[type]} params {title, url, param, nativeParam}
     */
    function openURL(params, callback, element, page) {

        page.parseData(element, params.url, function (url) {

            /**
             * 解析所有参数中的变量
             */
            function parseParam(param) {
                Object.keys(param).forEach(function (key) {
                    if ((param[key] || '').toString().match(/^\$/)) {
                        page.parseData(element, param[key], function (value) {
                            param[key] = value;
                        });
                    }
                });
            }

            var query = [];
            var anchor, search;

            if (!url) {
                callback();
                return;
            }

            anchor = document.createElement('a');
            anchor.href = url;

            if (params.param) {
                params = JSON.parse(JSON.stringify(params.param));
                parseParam(params);

                Object.keys(params).forEach(function (param) {
                    var val = params[param];
                    if (val) {
                        query.push(param + '=' + encodeURI(val));
                    }
                });

                query = query.join('&');

                search = anchor.search;
                if (search && search.slice(-1) != '&') {
                    search = search + '&';
                }
                anchor.search = search + query;
            }

            // 特殊处理逻辑，告诉服务端已经编码过了
            if (url.search('weapp/view') > 0) {
                anchor.href = encodeURI(anchor.href);
                anchor.search = anchor.search + '&weapp_encode=1';
            }

            url = anchor.href;

            var env = lib.env;
            var WindVane = lib.WindVane;

            console.log('openURL', url);

            // hook for parsing external url rules which was discussed and added by @游侠
            if (typeof G_msp_urlHandle === 'function') {
                url = G_msp_urlHandle(url);
            }

            if (env.taobaoApp && env.taobaoApp.appname == 'TB' && env.taobaoApp.version.gte('4.0.1') && env.os.isIOS && WindVane) {
                WindVane.call('Base', 'openWindow', {url: url}, function (e) {
                }, function (e) {
                    location.href = url;
                });
            } else {
                location.href = url;
            }

            callback(url);
        });
    }
    /**
     * [sendRequest description]
     * @param  {[type]} params {apiName, needLogin, param, postAction ,apiVersion}
     *
     * 跟开发确认协议内容发生更改，不出出现postAction
     */
    function sendRequest(params, callback, element, page) {

        // 配置 mtop 请求路径
        if (location.hostname.indexOf('daily.taobao.net') != -1) {
            lib.mtop.config.mainDomain = 'taobao.net';
            lib.mtop.config.subDomain = 'daily';
        }

        if (params.needLogin == 'true' && !lib.login.isLogin() && !GLOBAL_CONFIG.ISPC) {//装修后台不需要判断登陆
            lib.login.goLogin();
            return;
        } else {
            params = JSON.parse(JSON.stringify(params));
            page.clearMtop(params.apiName);
            page.clearMtop(params.apiAlias);
            page.setRequest(element, params, callback);
        }

    }

    /**
     * [changeData description]
     * @param  {[type]} params {key: value}
     */
    function changeData(params, callback, element, page) {
        var data = page.data;

        Object.keys(params).forEach(function (p) {
            var v = params[p];
            var op = v.charAt(0);
            var dataType = 'String';
            p = p.slice(1);
            p = p.replace(/\{(.+)\}/, '$1');
            if (op === '+' || op === '-') {
                dataType = 'Number';
                op = op + '=';
                // 有"+", "-"操作时, 需要去掉+-前缀
                v = v.slice(1);
            } else {
                op = '=';
            }
            var exp = 'this.' + p;
            /* jshint ignore:start */
            var finalExp;
            if (dataType === 'Number') {
                finalExp = exp + '=Number(' + exp + ');' + exp + op + 'Number(v);';
            }
            else {
                finalExp = exp + '=v';
            }

            var fn = new Function('v', finalExp);
            /* jshint ignore:end */
            fn.call(data, v);
        });

        callback();
    }
    /**
     * [changeStyle description]
     * @param  {[type]} params {viewId, styleBinding}
     */
    function changeStyle(params, callback) {
        if (!params.viewId || !params.styleBinding) {
            return;
        }

        var styleBinding = params.styleBinding;
        var view = WElement.get(params.viewId);
        // view.setStyle(styleBinding);
        Object.keys(styleBinding).forEach(function (key) {
            view.view.styleBinding[key] = styleBinding[key];
        });

        callback();
    }

    /**
     * [refreshView description]
     * @param  {[type]} params {viewId}
     */
    function refreshView(params, callback, element, page) {
        element = WElement.get(params.viewId) || element;
        page.refreshView(element);
        callback();
    }
    /**
     * [refresh description]
     * @param  {[type]} params {viewId}
     */
    function refresh(params, callback, element, page) {
        element = WElement.get(params.viewId) || element;
        page.refreshView(element, true);
        callback();
    }

    /**
     * [openPopWindow description]
     */
    function openPopWindow(params, callback, element, page) {
        var view = params.view;

        if (page.element && page.layer &&
                page.layer.parentNode === page.element) {
            page.element.root.removeChild(page.layer);
        }

        delete page.layer;
        delete page.popWindow;

        // create a pop window
        var popWindow = page.parseView(view);
        popWindow.root.setAttribute('pop-window', '');

        // create a layer
        var layer = document.createElement('div');
        layer.className = 'layer';

        // append pop window
        layer.appendChild(popWindow.root);
        page.element.root.appendChild(layer);

        layer.addEventListener('click', function (e) {
            if (e.target === this) {
                dismissPopWindow({viewId: popWindow.viewId}, function () {
                }, element, page);
            }
        });

        // save layer, pop window
        page.layer = layer;
        page.popWindow = popWindow;

        callback();
    }
    /**
     * [dismissPopWindow description]
     */
    function dismissPopWindow(params, callback, element, page) {
        var viewId = params.viewId;
        var popWindow = WElement.get(viewId);

        if (!page.element || !page.layer || !popWindow || !popWindow.root ||
                popWindow.root.parentNode !== page.layer ||
                page.layer.parentNode !== page.element.root) {
            return;
        }

        page.element.root.removeChild(page.layer);

        delete page.layer;
        delete page.popWindow;

        callback();
    }

    /**
     * [phoneCall description]
     * @param  {[type]} params {number}
     */
    function phoneCall(params, callback, element, page) {

        page.parseData(element, params.phoneNumber, function (num) {
            var a = document.createElement('a');
            a.href = 'tel:' + num;
            var evt = document.createEvent('MouseEvents');
            evt.initEvent('click', true, false);
            a.dispatchEvent(evt);

            callback();
        });
    }
    /**
     * [toast description]
     * @param  {[type]} params {text}
     */
    function toast(params, callback, element, page) {
        page.parseData(element, params.text || '', function (value) {
            var pop = lib.notification.simple(value, 1600);
            pop.show();
            callback();
        });
    }

    function userTrack(params, callback, element, page) {
        var utParam = params.utParam;

        function rebuildParam(obj) {
            var spm = obj.wp_app + '.' + obj.wp_pk + '.' + obj.wp_m + (obj.wp_p ? '.' + obj.wp_p : '');
            params.spm = spm;
            delete obj.wp_app;
            delete obj.wp_pk;
            delete obj.wp_m;
            delete obj.wp_p;
            for (var key in obj) {
                params[key] = obj[key];
            }
            delete params.utParam;
        }

        if (!!utParam) {
            //正常情况下utParam里面绑定的值应该已经被拉取到了数据池中
            Object.keys(utParam).forEach(function (key) {
                page.parseData(element, utParam[key], function (value) {
                    utParam[key] = value;
                });
            });
            rebuildParam(utParam);
        }
        lib.aplus({
            apname: 'weapp_x_x', //线上就这样的 
            apdata: params
        });
    }


    </script>
    <script>/**
     * 条件解析器(可递归)
     *
     * 条件描述分为: left/leftCondition, right/rightCondition, type
     * type 为运算符: ==, !=, >, <, >=, <=, &&, ||
     * 当 left, right 存在时为被运算的两个值
     * 当 leftCondition, rightCondition 存在时为子条件，需要递归
     *
     * @param {PageView} page      所在页面
     * @param {WElement} element   所在元素
     * @param {object}   condition 条件描述
     * @param {Function} handler   回调函数
     */
    function Condition(page, element, condition, handler) {

        if (typeof handler !== 'function') {
            handler = function () {
            };
        }

        this.page = page;
        this.element = element;
        this.condition = condition;
        this.handler = handler;

        this.start();
    }

    /**
     * 开始条件判断
     */
    Condition.prototype.start = function () {
        var self = this;
        var page = this.page;
        var condition = this.condition;
        var element = this.element;

        // 区分left/leftCondition，最终得出并处理左侧的值
        if (condition.leftCondition) {
            new Condition(page, element, condition.leftCondition, function (result) {
                self.calcLeft(result);
            });
        }
        else {
            page.parseData(element, condition.left, function (result) {
                self.calcLeft(result);
            });
        }

        // 区分right/rightCondition，最终得出并处理右侧的值
        if (condition.rightCondition) {
            new Condition(page, element, condition.rightCondition, function (result) {
                self.calcRight(result);
            });
        }
        else {
            page.parseData(element, condition.right, function (result) {
                self.calcRight(result);
            });
        }
    };

    /**
     * 处理左侧最终的值
     * 如果两侧都已经有值，则进行最终判断
     */
    Condition.prototype.calcLeft = function (result) {
        this.hasLeft = true;
        this.left = result;
        this.calc();
    };

    /**
     * 处理右侧最终的值
     * 如果两侧都已经有值，则进行最终判断
     */
    Condition.prototype.calcRight = function (result) {
        this.hasRight = true;
        this.right = result;
        this.calc();
    };

    /**
     * 进行最终判断，并触发回调函数
     */
    Condition.prototype.calc = function () {

        /**
         * 格式化结果
         * 对一些特殊的返回值进行转换
         */
        function format(value) {
            if (typeof value === 'string') {
                switch (value) {
                    case 'null':
                        return null;
                    case 'false':
                        return false;
                    case 'true':
                        return true;
                    case '':
                        return null;
                }
            }
            return value;
        }

        var left = format(this.left);
        var right = format(this.right);
        var handler = this.handler;
        var type = this.condition.type;
        var result = false;

        if (!this.hasLeft || !this.hasRight) {
            return;
        }

        switch (type) {
            case '==':
                result = left == right;
                break;
            case '!=':
                result = left != right;
                break;
            case '>':
                result = left > right;
                break;
            case '<':
                result = left < right;
                break;
            case '>=':
                result = left >= right;
                break;
            case '<=':
                result = left <= right;
                break;
            case '&&':
                result = left && right;
                break;
            case '||':
                result = left || right;
                break;
            default:
                result = false;
        }

        // console.log(JSON.stringify(this.condition));
        // console.log('calc', typeof left, left, type, typeof right, right, result);
        handler(result);
    };


    /**
     * 系列条件列表判断
     * 为连续多个条件创建解析器
     * 找出第一个符合的条件并将其回调
     *
     * @param {PageView} page       所在页面
     * @param {WElement} element    所在元素
     * @param {array}    conditions 条件描述列表
     * @param {Function} handler    回调函数
     */
    function Conditions(page, element, conditions, handler) {

        if (typeof handler !== 'function') {
            handler = function () {
            };
        }

        this.page = page;
        this.element = element;
        this.conditions = conditions;
        this.handler = handler;

        this.next();
    }

    /**
     * 处理第一个条件，为该条件创建条件解析器
     * 判断executionType
     * 若不为1：
     * 如果条件成立则回调该条件对象，否则处理下一个条件
     * 若为1：
     * 不管成不成立，回调该对象并处理下一条件
     */
    Conditions.prototype.next = function () {
        var self = this;
        var handler = this.handler;

        var condition = this.conditions.shift();
        if (!condition) {
            return;
        }

        new Condition(this.page, this.element, condition, function (result) {
            if (result) {
                handler(condition);
                if (condition.executionType == 1) {//可能存在数字1或者字符串1
                    self.next();
                }
            } else {
                self.next();
            }
        });
    };
    </script>

    <script>/**
     * @fileOverview 元素解析器，所有类型的元素都是继承自该原型
     */


    /**
     * 创建元素，会自动执行init方法
     */
    function WElement() {
        this.init.apply(this, arguments);
    }


    /// WElement.static

    /**
     * 所有创建的元素的映射表，以viewId为键
     */
    WElement.keymap = {};

    /**
     * 根据viewId查询元素
     */
    WElement.get = function (viewId) {
        return WElement.keymap[viewId];
    };

    /**
     * 随机生成新的viewId
     */
    WElement.keygen = function () {
        // return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
        return 'w-' + WElement.nextId++;
    };

    WElement.nextId = 1;


    /// WElement#

    /**
     * 元素默认类型是view
     */
    WElement.prototype.type = 'view';

    /**
     * 初始化
     *
     * 处理流程包括：
     * 设置viewId、子viewId列表、DOM、样式、数据、盒模型信息、事件等
     *
     * @param {string} id     viewId
     * @param {object} style  初始化样式描述对象
     * @param {object} data   初始化数据描述对象
     * @param {object} events 事件描述对象
     */
    WElement.prototype.init = function (id, style, data, events, view) {

        // abstract constructor has no parameters by default
        if (arguments.length === 0) {
            return;
        }

        this.viewId = id || WElement.keygen();
        WElement.keymap[this.viewId] = this;
        this.view = view;

        this.parentViewId = null;
        this.childViewIds = [];

        this.style = {};
        this.box = {};
        this.data = {};
        this.events = [];

        this.setDefault();

        this.setDom();
        this.bindStyle();
        this.bindSpecialStyle();
        this.setStyle(style);
        this.setData(data);
        this.setEvents(events);

        this.root.setAttribute('w-id', this.viewId);
    };


    /// WElement#init()

    /**
     * 完成一些默认设置，可扩展
     */
    WElement.prototype.setDefault = function () {
    };

    /**
     * 设置DOM
     */
    WElement.prototype.setDom = function () {
        var root = document.createElement('div');
        var content = document.createElement('span');
        root.appendChild(content);

        this.root = root;
        this.content = content;
        this.root.setAttribute('data-type', this.type);
    };

    /**
     * 绑定样式
     * 方便不同类型的元素继承这些样式
     */
    WElement.prototype.bindStyle = function () {
        var self = this;

        ['invisible', 'invisibleSpace', 'align', 'gravity', 'weight'].
                forEach(function (name) {
                    self.setStyleAttr(name);
                });

        ['margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom',
            'padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'].
                forEach(function (name) {
                    self.bindStylePropPx(name);
                });

        this.mixStyler('width', 'height', 'backgroundColor', 'backgroundImage');
    };

    /**
     * 绑定该元素的特殊样式
     * 方便不同类型的元素派生自己的样式
     */
    WElement.prototype.bindSpecialStyle = function () {
    };

    /**
     * 设置样式
     */
    WElement.prototype.setStyle = function () {
        var argv = Array.prototype.slice.call(arguments);
        argv.unshift(this.style);
        setProp.apply(null, argv);
        if (this.box.changed) {
            this.box.changed = false;
            this.reflow();
        }
    };

    /**
     * 设置数据(内容)
     * 这里的内容不是指子元素，而是不可分解的文字、图片等信息
     */
    WElement.prototype.setData = function () {
        var changes = this.setProp.apply(this.data, arguments);
        var prefix, suffix, value;

        if (changes.value || changes.prefix || changes.suffix || changes.formatType) {
            var data = this.data;
            var val = data.formatType ? this.format(data) : data.value;

            prefix = this.data.prefix || '';
            suffix = this.data.suffix || '';

            value = val ? (prefix + val + suffix) : '';

            if (value.match(/^ {2,}/)) {
                value = value.replace(/ /g, '\xA0');
            }

            this.value = value;
            this.content.innerText = value;

            this.reflow();
        }
    };

    /**
     * 设置事件
     * 事件的触发会调用外部绑定的fire方法，参见PageView的代码
     */
    WElement.prototype.setEvents = function (events) {
        var self = this;
        var type;

        function bind(evt) {
            var type = evt;
            var actions = evt.actions;
            if (actions && actions.length) {
                self.root.addEventListener('click', function (e) {
                    if (typeof self.fire === 'function') {
                        self.fire(actions);
                    }
                });
            }
        }

        if (!events || !events.forEach) {
            return;
        }

        this.events = events;

        events.forEach(function (evt) {
            if (evt.type === 'click') {
                bind(evt);
            }
        });
    };


    /// WElement#bindStyle()
    /// WElement#bindSpecialStyle()

    /**
     * 用于样式绑定
     * 把该样式和DOM的[data-*]特性绑定起来
     */
    WElement.prototype.setStyleAttr = function (name) {
        var element = this.root;
        var style = this.style;

        var attrName = propToAttr(name);
        var privateName = '_' + name;

        defineProp(style, name,
                function () {
                    return this[privateName];
                },
                function (v) {
                    this[privateName] = v;
                    element.setAttribute(attrName, v);
                }
        );
    };

    /**
     * 用于样式绑定
     * 把该样式和一对固定的getter/setter绑定起来
     */
    WElement.prototype.setStyleProp = function (name, getter, setter) {
        var element = this.root;
        var style = this.style;

        defineProp(style, name,
                function () {
                    return getter.call(this);
                },
                function (v) {
                    setter.call(this, v);
                }
        );
    };

    /**
     * 用于样式绑定
     * 把该样式和DOM的style属性绑定起来
     */
    WElement.prototype.bindStyleProp = function (name) {
        var element = this.root;
        var style = this.style;

        var privateName = '_' + name;

        defineProp(style, name,
                function () {
                    return this[privateName];
                },
                function (v) {
                    element.style[name] = v;
                    this[privateName] = v;
                }
        );
    };

    /**
     * 用于样式绑定
     * 把该样式和DOM的style属性的像素值绑定起来
     */
    WElement.prototype.bindStylePropPx = function (name) {
        var element = this.root;
        var style = this.style;
        var box = this.box;

        var privateName = '_' + name;

        defineProp(style, name,
                function () {
                    return this[privateName];
                },
                function (v) {
                    var value = parseInt(v, 10);
                    if (value >= 0) {
                        element.style[name] = px2Rem(value) + 'rem';
                    }
                    this[privateName] = v;
                    box.changed = true;
                }
        );
    };

    /**
     * 从styler混入样式定义
     */
    WElement.prototype.mixStyler = function () {
        var self = this;
        var nameList = Array.prototype.slice.call(arguments);
        nameList.forEach(function (name) {
            if (typeof styler[name] === 'function') {
                styler[name].call(self);
            }
        });
    };


    /// WElement#setData

    /**
     * 用于setData
     * 处理特殊数据的格式化
     */
    WElement.prototype.format = function (data) {
        var value = data.value;
        var type = data.formatType;
        var handler = formatter[type];

        if (typeof handler === 'function') {
            return handler(value);
        }
        else {
            return value;
        }
    };


    /// box models

    /* debug start */
    // window.reflowCount = 0;
    // window.resizeCount = 0;
    /* debug end */

    var watcher;
    var reflowing = false;

    function watchReflow() {
        // 清理掉上次监听的定时器
        if (watcher) {
            clearTimeout(watcher);
        }

        // 设置reflowing为false，是为了停止已经再进行的reflowing
        reflowing = false;

        watcher = setTimeout(function () {
            if (reflowing) return;
            reflowing = true;

            var root = GLOBAL_CONFIG.PAGE_ROOT ?
                    GLOBAL_CONFIG.PAGE_ROOT.children[2] :
                    document.querySelector('[weapp-host]').firstElementChild;
            var rootElement = WElement.get(root.getAttribute('w-id'));

            function reflow(parentElement, callback) {
                if (!reflowing) return; // 可停止还未reflow的元素

                var childElements = parentElement.childViewIds.map(function (id) {
                    return WElement.get(id);
                });

                if (parentElement.headerViewId) {
                    childElements.unshift(WElement.get(parentElement.headerViewId));
                }
                if (parentElement.footerViewId) {
                    childElements.push(WElement.get(parentElement.footerViewId));
                }

                var childLength = childElements.length;
                var childCompleted = 0;

                if (childLength === 0) {
                    // 如果没有子元素，则直接完成父元素的reflow，并回调
                    if (parentElement.needResize) {
                        parentElement.resize();
                        parentElement.needResize = false;
                    }
                    parentElement.needReflow = false;
                    callback();
                } else {
                    childElements.forEach(function (childElement) {
                        // 递归遍历所有子元素
                        reflow(childElement, function () {
                            childCompleted++; // 子元素完成，标记为+1
                            if (childElement.refreshScroller) {
                                // 子元素的reflow完成了，就可以refreshScroll了
                                childElement.refreshScroller();
                            }

                            // 所有子元素都完成了reflow
                            if (childCompleted === childLength) {
                                // 对需要resize的父元素进行resize
                                if (parentElement.needResize) {
                                    parentElement.resize();
                                    parentElement.needResize = false;
                                }
                                parentElement.needReflow = false;
                                // 完成父元素的reflow，并回调
                                callback();
                            }
                        });
                    });
                }
            }

            // 从根节点深度递归，完成后，设置reflowing标记为false。
            if (!rootElement) {
                reflowing = false;
                return;
            }
            reflow(rootElement, function () {
                reflowing = false;
            });
        }, 200);
    }

    /**
     * 元素reflow
     *
     * 通常会在元素样式、数据或内部结构发生变化的时候被触发
     * 对于绝对布局且尺寸为-2的容器来说，需要手动计算盒模型信息
     *
     * 子element的某些属性变化以后，可能影响父元素的属性
     * 找到父元素尺寸写死或非-2绝对布局时递归结束
     */
    WElement.prototype.reflow = function () {
        var self = this;

        var parent = WElement.get(this.parentViewId);
        if (parent && !!parent.needReflow) {
            if (parent.style.layout === 'absoluteLayout') {
                parent.needResize = true;
            }
//    return;
        }

        var box = this.box = this.getBox();
        var parentNeedReflow = parent && (
                        box.unknownWidth || box.unknownHeight || box.knownWidth || box.knownHeight
                );

        if (parentNeedReflow) {
            /* debug start */
            // window.reflowCount++;
            /* debug end */
            parent.needReflow = true;

            if (parent.style.layout === 'absoluteLayout') {
                parent.needResize = true;
            }
            parent.reflow();
            watchReflow(); // 每次都对reflow的动作进行监听
        }
    };

    /**
     * 用于reflow
     * 如果该元素是-2绝对布局，则将宽高设置为手动计算出的盒模型信息
     */
    WElement.prototype.resize = function () {
        /* debug start */
        // window.resizeCount++;
        /* debug end */

        var self = this;
        var box = self.getBox();

        if (this.view && this.view.editProperty && this.view.editProperty.addableModules) {
            return;
        }

        var maxWidth = 0;
        var maxHeight = 0;
        var marginX = 0;
        var marginY = 0;
        var paddingX = 0;
        var paddingY = 0;

        var parent;

        if (box.unknownWidth || box.unknownHeight) {
            self.childViewIds.forEach(function (viewId) {
                var child = WElement.get(viewId);
                var clientRect = child.root.getBoundingClientRect();
                var right = (clientRect.width / rem * 40) +
                        (parseInt(child.style.marginLeft || child.style.margin) || 0) +
                        (parseInt(child.style.marginRight || child.style.margin) || 0);
                var bottom = (clientRect.height / rem * 40) +
                        (parseInt(child.style.marginTop || child.style.margin) || 0) +
                        (parseInt(child.style.marginBottom || child.style.margin) || 0);
                maxWidth = Math.max(maxWidth, right);
                maxHeight = Math.max(maxHeight, bottom);
            });
        }

        if (box.unknownWidth && maxWidth > 0) {
            if (this.style.padding) {
                paddingX = this.style.padding;
            }
            if (this.style.paddingLeft || this.style.paddingRight) {
                paddingX = (this.style.paddingLeft || 0) + (this.style.paddingRight || 0);
            }
            this.style.width = maxWidth + paddingX;
        }

        if (box.unknownHeight && maxHeight > 0) {
            if (this.style.padding) {
                paddingY = this.style.padding;
            }
            if (this.style.paddingTop || this.style.paddingBottom) {
                paddingY = (this.style.paddingTop || 0) + (this.style.paddingBottom || 0);
            }
            this.style.height = maxHeight + paddingY;
        }

        if (self.root.parentElement.id === 'page_root') {
            return;
        }

        if (box.solidWidth) {
            parent = WElement.get(this.parentViewId);
            if (parent) {
                maxWidth = parent.root.getBoundingClientRect().width / rem * 40;
            }
            if (this.style.margin) {
                marginX = this.style.margin;
            }
            if (this.style.marginLeft || this.style.marginRight) {
                marginX = (this.style.marginLeft || 0) + (this.style.marginRight || 0);
            }
            this.style.width = maxWidth - marginX;
        }

        if (box.solidHeight) {
            parent = WElement.get(this.parentViewId);
            if (parent) {
                maxHeight = parent.root.getBoundingClientRect().height / rem * 40;
            }
            if (this.style.margin) {
                marginY = this.style.margin;
            }
            if (this.style.marginTop || this.style.marginBottom) {
                marginY = (this.style.marginTop || 0) + (this.style.marginBottom || 0);
            }
            this.style.height = maxHeight - marginY;
        }
    };

    /**
     * 用于reflow和resize
     * 返回该元素的盒模型信息
     *
     * knownWidth, knownHeight, unknownWidth, unknownHeight
     * allWidth, allHeight, solidWidth, solidHeight
     * padding, margin, width, height
     */
    WElement.prototype.getBox = function () {
        var box = {};

        var marginLeft = Number(this.style.marginLeft || this.style.margin || 0);
        var marginRight = Number(this.style.marginRight || this.style.margin || 0);
        var marginTop = Number(this.style.marginTop || this.style.margin || 0);
        var marginBottom = Number(this.style.marginBottom || this.style.margin || 0);

        var width = parseInt(this.style.width);
        var height = parseInt(this.style.height);

        box.knownWidth = width >= 0;
        box.knownHeight = height >= 0;
        box.solidWidth = isNaN(width) || width === -1;
        box.solidHeight = height === -1;
        box.unknownWidth = width === -2;
        box.unknownHeight = isNaN(height) || height === -2;

        box.allWidth = box.knownWidth ? (marginLeft + width + marginRight) : null;
        box.allHeight = box.knownHeight ? (marginTop + height + marginBottom) : null;

        return box;
    };

    /**
     * @deprecated
     *
     * 不会再被调用
     * 更新外层可滚动内容的尺寸
     */
    WElement.prototype.resetContainer = function () {
        var containerList = [];
        var element = this;

        while (element) {
            if (element.refreshScroller) {
                containerList.push(element);
            }
            element = WElement.get(element.parentViewId);
        }

        containerList.forEach(function (container) {
            container.refreshScroller();
        });
    };


    /// extension

    /**
     * 克隆一个一模一样的DOM
     * 预留给各种外部操作和分析使用，比如拖拽时生成浮层显示被拖拽的元素
     */
    WElement.prototype.cloneNode = function () {
        return this.root.cloneNode(true);
    };

    /**
     * 为该元素设置一个占位符
     * 预留给各种外部操作和分析使用
     *
     * @param {Element} element 占位元素
     */
    WElement.prototype.setPlaceholder = function (element) {
        if (element) {
            var placeholder = document.createElement('div');
            placeholder.appendChild(element);
            placeholder.className = 'placeholder';
            this.placeholder = placeholder;
            this.root.appendChild(placeholder);
        }
        else {
            this.root.removeChild(this.placeholder);
            this.placeholder = null;
        }
    };


    /// deprecated

    /**
     * @deprecated
     *
     * set property or properties
     *
     * @example
     * obj.setProp('keyX', 'valueN')
     *
     * @example
     * obj.setProp({keyX: 'valueN', ...})
     *
     * @param {object} dest
     * @param {string} key
     * @param {any}    value
     */
    WElement.prototype.setProp = function (key, value) {
        var src;

        if (arguments.length > 1) {
            if (this[key] !== value) {
                src = {};
                this[key] = value;
                src[key] = value;
                return src;
            }
        }
        else if (typeof arguments[0] === 'object') {
            src = arguments[0];
            for (key in src) {
                value = src[key];
                if (this[key] == value) {
                    delete src[key];
                } else {
                    this[key] = value;
                }
            }
            return src;
        }

        return {};
    };

    /**
     * @deprecated
     */
    WElement.prototype.applyStyle = function () {
        var element = this.root;

        var fontSize = parseInt(element.getAttribute('w-font-size'), 10);
        if (fontSize > 0) {
            element.style.fontSize = px2Rem(fontSize) + 'rem';
            element.removeAttribute('w-font-size');
        }

        var width = parseInt(element.getAttribute('w-width'), 10);
        if (width > 0) {
            element.style.width = px2Rem(width) + 'rem';
            element.removeAttribute('w-width');
        }

        var height = parseInt(element.getAttribute('w-height'), 10);
        if (height > 0) {
            if (this.fontSize > 0 && (height < this.fontSize + 2)) {
                height = this.fontSize + 2;
            }
            element.style.height = px2Rem(height) + 'rem';
            element.removeAttribute('w-height');
        }

        ['margin', 'padding',
            'marginLeft', 'paddingLeft',
            'marginRight', 'paddingRight',
            'marginTop', 'paddingTop',
            'marginBottom', 'paddingBottom', 'borderWidth'].
                forEach(function (styleName) {
                    var attrName = propToAttr(styleName);
                    var value = parseInt(element.getAttribute(attrName), 10);
                    if (value) {
                        element.style[styleName] = px2Rem(value) + 'rem';
                        element.removeAttribute(attrName);
                    }
                });

        var fontWeight = element.getAttribute('w-font-weight');
        element.style.fontWeight = fontWeight > 400 ? 'bold' : '';

        var textColor = element.getAttribute('w-text-color');
        element.style.color = textColor ? textColor : '';

        var borderColor = element.getAttribute('w-border-color');
        element.style.borderColor = borderColor ? borderColor : '';

        var backgroundColor = element.getAttribute('w-background-color');
        element.style.background = backgroundColor ? backgroundColor : '';

        var backgroundImage = element.getAttribute('w-background-image');
        element.style.background = backgroundImage ? 'url(' + backgroundImage + ')' : '';
    };
    </script>

    <script>
        function ContainerWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        ContainerWElement.prototype = new WElement();

        ContainerWElement.prototype.type = 'container';

        ContainerWElement.prototype.init = function (id, style, data, events, view) {

            // abstract constructor has no parameters by default
            if (arguments.length === 0) {
                return;
            }

            style = style || {};

            if (style.layout !== 'absoluteLayout') {
                this.needScroller = true;
            }
            if (!style.orientation) {
                style.orientation = 'vertical';
            }

            WElement.prototype.init.call(this, id, style, data, events, view);

            this.setStyle({orientation: this.style.orientation});
        };

        /// #init()

        /// #setDom()

        domStructure.bindContainer(ContainerWElement.prototype);


        /// #bindStyle

        ContainerWElement.prototype.bindSpecialStyle = function () {
            var self = this;

            ['layout', 'orientation'].
                    forEach(function (name) {
                        self.setStyleAttr(name);
                    });

            this.bindStylePropPx('borderWidth');
            this.bindStyleProp('borderColor');
            this.mixStyler('scroll');
        };

    </script>
    <script>
        function ListWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        ListWElement.prototype = new WElement();

        ListWElement.prototype.type = 'list';

        ListWElement.prototype.init = function (id, style, data, events, view) {

            // abstract constructor has no parameters by default
            if (arguments.length === 0) {
                return;
            }

            style = style || {};

            WElement.prototype.init.call(this, id, style, data, events, view);

            this.needScroller = !view.unScroll;
            this.style.scroll = 1;
        };

        /// #setDom()

        domStructure.bindContainer(ListWElement.prototype);

        /// #bindStyle

        ListWElement.prototype.bindSpecialStyle = function () {
            var self = this;

            this.bindStylePropPx('borderWidth');
            this.bindStyleProp('borderColor');
            this.mixStyler('scroll');
        };

    </script>
    <script>
        function GridWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        GridWElement.prototype = new WElement();

        GridWElement.prototype.type = 'grid';

        GridWElement.prototype.init = function (id, style, data, events, view) {

            // abstract constructor has no parameters by default
            if (arguments.length === 0) {
                return;
            }

            style = style || {};

            WElement.prototype.init.call(this, id, style, data, events, view);

            this.needScroller = !view.unScroll;
            this.style.scroll = 1;
        };

        /// #setDom()

        domStructure.bindContainer(GridWElement.prototype);

        GridWElement.prototype.appendChild = function () {
            var self = this;
            var footerRoot = this.footer ? this.footer.root : null;
            var childWElements = Array.prototype.slice.call(arguments);
            var column = parseInt(this.style.gridColumn, 10) || 1;

            childWElements.forEach(function (wElement) {
                var innerContent = document.createElement('span');
                var lastRow = self.lastRow;

                if (self.childViewIds.length % column === 0) {
                    lastRow = document.createElement('div');
                    lastRow.setAttribute('row', '');
                    self.lastRow = lastRow;
                    self.content.insertBefore(lastRow, footerRoot);
                }

                lastRow.appendChild(innerContent);
                innerContent.appendChild(wElement.root);

                wElement.parentViewId = self.viewId;
                self.childViewIds.push(wElement.viewId);
            });

            this.reflow();
        };

        /// #bindStyle

        GridWElement.prototype.bindSpecialStyle = function () {
            var self = this;

            ['gridColumn'].
                    forEach(function (name) {
                        self.setStyleAttr(name);
                    });

            this.bindStylePropPx('borderWidth');
            this.bindStyleProp('borderColor');
            this.mixStyler('scroll');
        };

    </script>

    <script>
        function AtomWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        AtomWElement.prototype = new WElement();

        AtomWElement.prototype.type = 'atom';

        /// #setDom()

        domStructure.bindAtom(AtomWElement.prototype);
    </script>
    <script>
        function ImageWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        ImageWElement.prototype = new AtomWElement();

        ImageWElement.prototype.type = 'image';

        /// #setDom()

        ImageWElement.prototype.setDom = function () {
            var root = document.createElement('div');
            var content = document.createElement('span');
            var img = document.createElement('img');
            var self = this;

            img.src = IMG_HOLDER;

            img.addEventListener('load', function () {
                self.reflow();
            });
            img.addEventListener('error', function () {
                self.reflow();
            });

            content.appendChild(img);
            root.appendChild(content);

            this.root = root;
            this.root.setAttribute('data-type', this.type);
            this.root.setAttribute('atom', '');

            this.content = img;
            img.className = 'lib-img';
        };

        /// #setData()

        ImageWElement.prototype.setData = function () {
            var changes = this.setProp.apply(this.data, arguments);

            /**
             * 由于 `[dataimg]` 是在 `setTimeout` 之后进行的，所以错过了 `fireLazyload()` 的时机
             * 这里加入一个机制，如果多次连续 (100ms) 执行上述 `setTimeout` 操作，会在最后一次操作之后补充触发一次 `fireLazyload()`
             */
            function lazyFireLazyload() {
                clearTimeout(window.lazyLazyLoader);
                window.lazyLazyLoader = setTimeout(function () {
                    if (imgHelper) {
                        imgHelper.fireLazyload();
                    }
                }, 100);
            }

            if (changes.url) {
                setTimeout(function () {
                    var rect = this.content.getClientRects()[0];

                    var param = {};

                    var bestWidth;
                    var bestHeight;
                    var bestSize;

                    if (imgConfig.isOriginal) {
                        param.isOriginal = true;
                    }
                    else {
                        var dpr = window.devicePixelRatio > 1 ? window.devicePixelRatio : 1;
                        bestWidth = rect && rect.width || ((this.style.width > 0) ? this.style.width : 200);
                        bestHeight = rect && rect.height || ((this.style.height > 0) ? this.style.height : 200);
                        bestSize = (bestWidth * dpr).toFixed(0) + 'x' + (bestHeight * dpr).toFixed(0);
                        param.size = bestSize;
                    }

                    var src = imgHelper.getNewUrl(changes.url, param);

                    if (GLOBAL_CONFIG.ISPC) {
                        // 后台不做懒加载
                        this.content.setAttribute('src', src);
                    } else {
                        this.content.setAttribute('data-size', bestSize);
                        this.content.setAttribute('dataimg', src);
                    }

                    this.reflow();
                    lazyFireLazyload();
                }.bind(this), 20);
            }
        };

        /// #bindStyle

        ImageWElement.prototype.bindSpecialStyle = function () {
            this.bindStylePropPx('borderWidth');
            this.bindStyleProp('borderColor');

            this.setStyleAttr('isCircle');
        };
    </script>
    <script>
        function LabelWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        LabelWElement.prototype = new AtomWElement();

        LabelWElement.prototype.type = 'label';

        /// #setDom()

        domStructure.bindAtom(LabelWElement.prototype);

        /// #bindStyle

        LabelWElement.prototype.bindSpecialStyle = function () {
            var self = this;

            this.bindStylePropPx('borderWidth');
            this.bindStyleProp('borderColor');

            this.setStyleAttr('lineType');
            this.bindStylePropPx('maxWidth');

            this.mixStyler('fontSize', 'fontWeight', 'textColor', 'lines',
                    'textShadowColor', 'textShadowOffsetX', 'textShadowOffsetY');
        };
    </script>
    <script>
        function ButtonWElement() {
            this.init.apply(this, arguments);
        }

        /// #

        ButtonWElement.prototype = new AtomWElement();

        ButtonWElement.prototype.type = 'button';

        /// #setDom()

        domStructure.bindAtom(ButtonWElement.prototype);

        /// #bindStyle

        ButtonWElement.prototype.bindSpecialStyle = function () {
            var self = this;

            this.mixStyler('fontSize', 'fontWeight', 'textColor');
        };
    </script>
    <script>/**
     * Created by wensu on 14-10-22.
     */

    function DashedLineWElement() {
        this.init.apply(this, arguments);
    }

    /// #

    DashedLineWElement.prototype = new AtomWElement();

    DashedLineWElement.prototype.type = 'dashedLine';

    /// #setDom()

    DashedLineWElement.prototype.setDom = function () {
        var self = this;
        var root = document.createElement('div');

        this.root = root;
        this.content = root;
        this.root.setAttribute('data-type', this.type);
        this.root.setAttribute('rich', '');

        setTimeout(function () {
            self.style.dashThickness = self.style.dashThickness;
        }, 13);
    };

    /// #bindStyle

    DashedLineWElement.prototype.bindSpecialStyle = function () {
        var self = this;

        ['orientation'].
                forEach(function (name) {
                    self.setStyleAttr(name);
                });

        this.mixStyler('dashColor', 'dashGap', 'dashThickness');
    };

    </script>

    <script>/**
     * Created by wensu on 14-10-15.
     */

    function TabWElement() {
        this.init.apply(this, arguments);
    }

    TabWElement.prototype = new ContainerWElement();

    TabWElement.prototype.type = 'tab';

    TabWElement.prototype.setDom = function () {
        var root = document.createElement('div');
        var content = document.createElement('div');
        root.appendChild(content);

        this.root = root;
        this.content = content;
        this.root.setAttribute('data-type', this.type);
        this.root.setAttribute('rich', '');
        this.content.setAttribute('data-style-layout', 'default');
    };

    TabWElement.prototype.appendChild = function () {
        ContainerWElement.prototype.appendChild.apply(this, arguments);
        this.updateChildView();
    };

    TabWElement.prototype.setHeader = function (header) {
        var _this = this;

        if (!(header instanceof TabHeaderWElement)) return;
        this.headerView = header;

        this.root.insertBefore(header.root, this.content);
        this.updateChildView();

        header.content.addEventListener('click', function (e) {
            var tar = e.target;
            if (typeof tar.tabIndex === 'number') {
                header.style.selectedIndex = tar.tabIndex;
                _this.showChildView(tar.tabIndex);
            }
        });

    };

    TabWElement.prototype.updateChildView = function () {
        var index;
        var header = this.headerView;

        if (!header) {
            return;
        }

        index = header.style.selectedIndex || 0;
        header.style.selectedIndex = index;
        this.showChildView(index);
    };

    TabWElement.prototype.showChildView = function (index) {
        var content = this.content;

        if (!this.headerView) return;

        index = parseInt(index, 10);

        [].forEach.call(content.children, function (child, i) {
            child.style.display = (index === i) ? '' : 'none';
        });

        setTimeout(function () {
            if (imgHelper) {
                imgHelper.fireLazyload();
            }
        }, 10);
    };
    </script>
    <script>/**
     * Created by wensu on 14-10-15.
     */

    function TabHeaderWElement() {
        this.init.apply(this, arguments);
    }

    TabHeaderWElement.prototype = new AtomWElement();

    TabHeaderWElement.prototype.type = 'tabHeader';

    TabHeaderWElement.prototype.setDom = function () {
        var root = document.createElement('div');

        this.root = root;
        this.content = root;
        this.root.setAttribute('data-type', this.type);
    };

    TabHeaderWElement.prototype.bindSpecialStyle = function () {
        this.setStyleAttr('fontStyle');
        this.setStyleShowTab();
        this.setStyleSelected();
        this.setStyleSelectIndex();
        this.mixStyler('fontSize', 'textColor', 'fontWeight');
    };

    TabHeaderWElement.prototype.setData = function (data) {
        var _this = this;
        if (!data || !Array.isArray(data.array)) {
            return;
        }
        data.array.forEach(function (item, index) {
            var span = document.createElement('span');
            span.textContent = item.title;
            span.tabIndex = index;
            _this.content.appendChild(span);
        });
    };

    TabHeaderWElement.prototype.SELECT_PROP_LIST = ['backgroundImage', 'backgroundColor', 'selectedFontSize', 'selectedTextColor', 'selectedBackgroundImage', 'selectedBackgroundColor'];

    TabHeaderWElement.prototype.setStyleSelectIndex = function () {
        var _this = this;
        var root = this.root;
        var selectPropList = this.SELECT_PROP_LIST;

        this.setStyleProp('selectedIndex',
                function () {
                    return this._selectedIndex;
                },
                function (v) {
                    var btnList = root.querySelectorAll('span');
                    var newCurrentBtn = btnList[v];

                    this._selectedIndex = v;

                    if (_this.currentBtn) {
                        _this.currentBtn.className = '';
                        _this.currentBtn.style.cssText = '';
                    }

                    if (newCurrentBtn) {
                        newCurrentBtn.className = 'active';
                    }

                    _this.currentBtn = newCurrentBtn;

                    selectPropList.forEach(function (name) {
                        if (_this.style[name]) {
                            _this.style[name] = _this.style[name];
                        }
                    });
                }
        );
    };

    TabHeaderWElement.prototype.setStyleShowTab = function () {
        var root = this.root;

        this.setStyleProp('isShowTab',
                function () {
                    return this._isShowTab;
                },
                function (v) {
                    root.style.display = (v === 'false') ? 'none' : '';
                    this._isShowTab = v;
                }
        );
    };

    TabHeaderWElement.prototype.setStyleSelected = function () {
        var _this = this;
        var root = this.root;

        this.setStyleProp('selectedFontSize',
                function () {
                    return this._selectedFontSize;
                },
                function (v) {
                    this._selectedFontSize = v;
                    if (_this.currentBtn) {
                        _this.currentBtn.style.fontSize = px2Rem(v) + 'rem';
                    }
                }
        );

        this.setStyleProp('selectedTextColor',
                function () {
                    return this._selectedTextColor;
                },
                function (v) {
                    this._selectedTextColor = v;
                    if (_this.currentBtn) {
                        _this.currentBtn.style.color = v;
                    }
                }
        );

        this.setStyleProp('backgroundImage',
                function () {
                    return this._backgroundImage;
                },
                function (v) {
                    this._backgroundImage = v;
                    if (_this.content.children.length > 0) {
                        [].forEach.call(_this.content.children, function (span) {
                            if (span !== _this.currentBtn) {
                                span.style.backgroundImage = 'url(' + v + ')';
                            }
                        });
                    }
                }
        );

        this.setStyleProp('backgroundColor',
                function () {
                    return this._backgroundColor;
                },
                function (v) {
                    this._backgroundColor = v;
                    if (_this.content.children.length > 0) {
                        [].forEach.call(_this.content.children, function (span) {
                            if (span !== _this.currentBtn) {
                                span.style.backgroundColor = v;
                            }
                        });
                    }
                }
        );

        this.setStyleProp('selectedBackgroundImage',
                function () {
                    return this._selectedBackgroundImage;
                },
                function (v) {
                    this._selectedBackgroundImage = v;
                    if (_this.currentBtn) {
                        _this.currentBtn.style.backgroundImage = 'url(' + v + ')';
                    }
                }
        );

        this.setStyleProp('selectedBackgroundColor',
                function () {
                    return this._selectedBackgroundColor;
                },
                function (v) {
                    this._selectedBackgroundColor = v;
                    if (_this.currentBtn) {
                        _this.currentBtn.style.BackgroundColor = v;
                    }
                }
        );
    };</script>
    <script>/**
     * Created by wensu on 14-10-15.
     */

    function SliderWElement() {
        this.init.apply(this, arguments);
    }

    /// #

    SliderWElement.prototype = new ContainerWElement();

    SliderWElement.prototype.type = 'slider';

    /// #setDom()

    domStructure.bindSlider(SliderWElement.prototype);

    /// #setData()

    SliderWElement.prototype.setData = function () {
        var changes = this.setProp.apply(this.data, arguments);
    };

    /// #bindStyle

    SliderWElement.prototype.bindSpecialStyle = function () {
        var self = this;

        ['isPointHide'].
                forEach(function (name) {
                    self.setStyleAttr(name);
                });

        this.bindStylePropPx('borderWidth');
        this.bindStyleProp('borderColor');
    };

    </script>
    <script>/**
     * Created by wensu on 14-10-15.
     */

    function BannerWElement() {
        this.init.apply(this, arguments);
    }

    /// #

    BannerWElement.prototype = new ContainerWElement();

    BannerWElement.prototype.type = 'banner';

    /// #setDom()

    domStructure.bindSlider(BannerWElement.prototype);

    BannerWElement.prototype.appendData = function (item) {
        var self = this;
        var subView = new ImageWElement(null,
                {width: 640, height: 336},
                {url: item.image}
        );

        this.appendChild(subView);

        if (!GLOBAL_CONFIG.ISPC) {
            subView.root.addEventListener('click', function (e) {
                if (typeof self.fire === 'function') {
                    self.fire([{
                        param: {
                            url: item.url
                        },
                        type: 'openURL'
                    }]);
                }
            });
        }
        setTimeout(function () {
            self.initSlider();
        }, 100);
    };

    /// #setData()

    BannerWElement.prototype.setData = function () {
        var changes = this.setProp.apply(this.data, arguments);
        var self = this;

        if (changes.hasOwnProperty('bannerArray')) {
            setTimeout(function () {
                self.children = changes.bannerArray;
                self.children.forEach(function (item) {
                    self.appendData(item);
                });
            }, 13);
        }
    };

    /// #bindStyle

    BannerWElement.prototype.bindSpecialStyle = function () {
        var self = this;

        ['isPointHide'].
                forEach(function (name) {
                    self.setStyleAttr(name);
                });

        this.bindStylePropPx('borderWidth');
        this.bindStyleProp('borderColor');
    };

    </script>

    <script> /**
     * @fileOverview 页面解析器：处理协议的最外层入口
     */


    /**
     * 页面对象
     * 创建时，页面会解析 json 对象中的 title, data, view 等数据
     * 并根据 view 的结构生成各种元素
     *
     * @param {object} json
     */
    function PageView(json) {
        var data;

        if (typeof GLOBAL_CONFIG === 'undefined') {
            GLOBAL_CONFIG = {};
        }

        this.pageId = PageView.keygen();
        PageView.keymap[this.pageId] = this;

        this.title = json.title || '';

        if (GLOBAL_CONFIG.ISPC && GLOBAL_CONFIG.DATA) {
            data = mixin(GLOBAL_CONFIG.DATA, GLOBAL_CONFIG.APIDATA);
            data = mixin(data, GLOBAL_CONFIG.EDITDATA);
        }
        else {
            data = json.data || {};
        }

        this.data = data;
        this.view = json.view || {};

        this.mtop = {};

        this.element = this.parseView(this.view);

        if (this.element && this.element.root) {
            this.element.root.setAttribute('weapp-root', '');

            // if (this.element.style.margin ||
            //     this.element.style.marginLeft ||
            //     this.element.style.marginRight) {
            //   this.element.root.style.width = 'auto';
            // }
        }
    }


    /**
     * 元素类型映射表，可以使用的元素都出现在这里
     */
    PageView.typeMap = {
        'view': WElement,

        'container': ContainerWElement,
        'list': ListWElement,
        'grid': GridWElement,

        'label': LabelWElement,
        'button': ButtonWElement,
        'image': ImageWElement,
        'dashedLine': DashedLineWElement,

        'simpleTabView': TabWElement,
        'simpleTabViewHeader': TabHeaderWElement,
        'sliderView': SliderWElement,
        'banner': BannerWElement
    };

    /**
     * 所有创建的页面的映射表，以pageId为键
     */
    PageView.keymap = {};

    /**
     * 根据pageId查询页面
     */
    PageView.get = function (pageId) {
        return PageView.keymap[pageId];
    };

    /**
     * 随机生成新的pageId
     */
    PageView.keygen = function () {
        return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
    };


    /**
     * 解析单个 view
     *
     * 待处理的字段：
     * type, index
     * styleBinding, dataBinding
     * condition, conditions
     * events
     * subViews, headerView, footerView, cell, foreach
     *
     * @param {object} view
     * @param {number} index 在生成列表中的对象时，会多一个参数，表示该对象是列表中的第几个
     */
    PageView.prototype.parseView = function (view, index) {

        var style = view.styleBinding || {};
        var data = view.dataBinding || {};
        var separatedStyle = this.separateBinding(style);
        var separatedData = this.separateBinding(data);
        var events = view.events;
        var type = view.type;
        var Constructor = PageView.typeMap[type];
        var element;

        if (typeof Constructor !== 'function') {
            return;
        }

        // 这里的events会直接传入element对象
        // 事件的触发机制是在element中根据events绑定相应的事件，然后触发fire函数
        // fire函数会在下面的this.handleEvents(element, view)中进行设置
        element = new Constructor(view.viewId,
                separatedStyle.staticBinding,
                separatedData.staticBinding, events, view);

        var root = element.root;

        if (GLOBAL_CONFIG.ISPC) {
            if (view && view.editProperty) {
                if (view.editProperty.defaultImage) {
                    root.setAttribute('data-default-image', view.editProperty.defaultImage);
                }
                if (view.editProperty.moduleid) {
                    root.setAttribute('data-module-id', view.editProperty.moduleid);
                }
            }
            //带上原信息方便调试
            root.viewModel = {};
            root.viewModel.originView = JSON.parse(JSON.stringify(view));
            root.viewModel.apiAlias = data;
            root.viewModel.pro = element;
            //带有editProperty的元素需要标记（每个模块的最外层）
            if (view.editProperty) {
                if (view.editProperty.addableModules) {
                    //容器元素，可添加多少值
                    root.setAttribute('data-addable-modules', view.editProperty.addableModules);
                    root.setAttribute('data-module-name', 'MODULEBOX');
                }
                if (view.editProperty.moduleType) {
                    //元素的最外层
                    root.setAttribute('data-module-name', view.editProperty.moduleType);
                }
            }
        }

        element.index = index;
        element.pageId = this.pageId;

        this.setRequest(element, data);
        this.setStyle(element, separatedStyle.variableBinding);
        this.setData(element, separatedData.variableBinding);
        this.setCondition(element, view);
        this.setChildren(element, view);

        if (!GLOBAL_CONFIG.ISPC) {
            this.handleEvents(element, view);
        }

        return element;
    };

    /**
     * refreshView 重新加载这个元素及其子元素
     * @param {WElement} element 被要求重载的元素
     * @param {Boolean}  isAll   是否刷新动态数据
     */
    PageView.prototype.refreshView = function (element, isAll) {
        var view = element.view;
        var style = view.styleBinding || {};
        var data = view.dataBinding || {};

        if (isAll) {
            if (data.apiName) {
                page.clearMtop(data.apiName);
            }
            if (data.apiAlias) {
                page.clearMtop(data.apiAlias);
            }
        }

        if (element.clearDom) {
            element.clearDom();
        }

        this.setRequest(element, data);

        this.setStyle(element, style);
        this.setData(element, data);

        this.setCondition(element, view);
        this.setChildren(element, view);
    };

    /**
     * 区分styleBinding/dataBinding中的变量和常量
     * 即把$开头的键值对摘出来
     *
     * @param  {object} binding
     * @return {object}         {staticBinding, variableBinding}
     */
    PageView.prototype.separateBinding = function (binding) {
        var staticBinding = {};
        var variableBinding = {};

        Object.keys(binding).forEach(function (name) {
            var value = binding[name];
            if (value && value.toString().match(/^\$/)) {
                variableBinding[name] = value;
            }
            else {
                staticBinding[name] = value;
            }
        });

        return {staticBinding: staticBinding, variableBinding: variableBinding};
    };

    /**
     * 处理view中的mtop请求
     *
     * @param {WElement} element  所在元素
     * @param {object}   data     {api, apiAlias, apiVersion, param, needLogin}
     * @param {Function} callback 回调函数
     */
    PageView.prototype.setRequest = function (element, data, callback) {
        var request;

        if (data.apiName) {
            request = {
                api: data.apiName,
                apiVersion: data.apiVersion,
                param: data.param,
                needLogin: data.needLogin,
                name: data.apiAlias || data.apiName,
                apiAlias: data.apiAlias
            };

            this.parseMtop(element, request, callback);
        }
    };

    /**
     * 处理view中的样式
     *
     * @param {WElement} element 所在元素
     * @param {object}   style   样式描述对象
     * @param {boolean}  varOnly 是否只更新变量，即$开头的值，默认更行全部，用于action:refreshView
     */
    PageView.prototype.setStyle = function (element, style, varOnly) {
        var self = this;

        if (!style) {
            return;
        }
        Object.keys(style).forEach(function (name) {
            if (typeof style[name] === 'string' && style[name].match(/^\$/)) {
                self.parseData(element, style[name], function (value) {
                    element.setStyle(name, value);
                });
            }
            else {
                if (!varOnly) {
                    element.setStyle(name, style[name]);
                }
            }
        });
    };

    /**
     * 处理view中的数据
     *
     * @param {WElement} element 所在元素
     * @param {object}   data    数据描述对象
     * @param {boolean}  varOnly 是否只更新变量，即$开头的值，默认更行全部，用于action:refreshView
     */
    PageView.prototype.setData = function (element, data, varOnly) {
        var self = this;

        if (!data) {
            return;
        }
        Object.keys(data).forEach(function (name) {
            if (typeof data[name] === 'string' && data[name].match(/^\$/)) {
                self.parseData(element, data[name], function (value) {
                    element.setData(name, value);
                });
            }
            else {
                if (!varOnly) {
                    element.setData(name, data[name]);
                }
            }
        });
    };

    /**
     * 处理view中的条件描述
     * 如果条件成立，则更新其附带的样式和数据
     *
     * @param {WElement} element 所在元素
     * @param {object}   view    所在view
     * @param {boolean}  varOnly 是否只更新变量，即$开头的值，默认更行全部，用于action:refreshView
     */
    PageView.prototype.setCondition = function (element, view, varOnly) {
        var self = this;
        var conditions = this.getConditionList(view);

        if (!conditions.length) {
            return;
        }

        new Conditions(this, element, conditions, function (condition) {
            self.setStyle(element, condition.styleBinding, varOnly);
            self.setData(element, condition.dataBinding, varOnly);
        });
    };

    /**
     * 处理view中的子view
     * 包括headerView, footerView, subViews, cell, foreach
     *
     * @param {WElement} element 所在元素
     * @param {object}   view    所在view
     */
    PageView.prototype.setChildren = function (element, view) {
        var self = this;
        var header;
        var footer;

        if (element.setHeader && view.headerView) {
            header = this.parseView(view.headerView, element.index);
            element.setHeader(header);
        }

        if (element.setFooter && view.footerView) {
            footer = this.parseView(view.footerView, element.index);
            element.setFooter(footer);
        }

        if (element.appendChild) {
            if (view.subViews) {
                view.subViews.forEach(function (subView) {
                    var subElement = self.parseView(subView, element.index);
                    if (subElement) {
                        element.appendChild(subElement);
                    }
                });
            }
            else if (view.cell) {
                this.setCell(element, view);
            }
            // 有subViews,也有可能有foreach,先处理subviews,再处理foreach
            if (view.foreach) {
                this.setEach(element, view);
            }
        }
    };

    /**
     * 处理view中的事件
     * 即给element提供一个fire方法，方便element在内部触发事件时调用
     * element的事件绑定已经在元素被创建的时候设置好了
     *
     * @param {WElement} element 所在元素
     * @param {object}   view    所在view
     */
    PageView.prototype.handleEvents = function (element, view) {
        var self = this;
        element.fire = function (actions) {
            if (actions && actions.length) {
                actions.forEach(function (action) {
                    self.handleAction(action, element);
                });
            }
        };
    };

    /**
     * 用于handleEvents
     * 触发事件对应的action
     *
     * @param {object} action
     * @param {WElement} element 所在元素
     */
    PageView.prototype.handleAction = function (action, element) {
        var self = this;
        var callbacks = action.callback || [];

        var callbacksHandler = function () {
            callbacks.forEach(function (callback) {
                self.handleAction(callback, element);
            });
        };

        if (!action.condition) {
            self.doAction(element, action.type, action.param, callbacksHandler);
        } else {
            new Condition(this, element, action.condition, function (result) {
                if (result) {
                    self.doAction(element, action.type, action.param, callbacksHandler);
                }
            });
        }
    };

    /**
     * 用于setChildren
     * 生成foreach的元素
     *
     * @param {WElement} element 所在元素
     * @param {object}   view    所在view
     */
    PageView.prototype.setEach = function (element, view) {
        var self = this;
        var each = view.foreach;
        var start = each.start || 0;
        var end = each.end || -1;
        var step = each.step || 1;

        if (!each.array) {
            return;
        }

        self.parseCellApi(element, each.template, function (api, path, list) {
            var length = list ? list.length : 0;

            if (end < 0 || end > length) {
                end = length;
            }

            if (start > end) {
                return;
            }

            for (var i = start; i < end; i += step) {
                var subElement = self.parseView(each.template, i);
                if (subElement) {
                    element.appendChild(subElement);
                }
            }
        });
    };

    /**
     * 用于setChildren
     * 生成cell的元素
     *
     * @param {WElement} element 所在元素
     * @param {object}   view    所在view
     */
    PageView.prototype.setCell = function (element, view, preserved) {
        var self = this;
        var cell = view.cell;
        this.parseCellApi(element, cell, function (api, path, list) {
            list = list || [];
            var length = list.length || 0;
            var lastItem = list[length - 1];

            element.cellApi = api;
            element.cellPath = path;

            for (var i = (preserved || 0); i < length; i++) {
                var subElement = self.parseView(cell, i);
                if (subElement) {
                    element.appendChild(subElement);
                }
            }

            if (lastItem) {
                element.lastTimestamp = lastItem.timestamp;
                element.lastId = lastItem.id;
            }

            if (typeof element.checkEmptyMsg === 'function') {
                element.checkEmptyMsg();
            }
        });
    };

    /**
     * 用于setChildren -> setEach, setCell
     * 找出最可能的列表对象
     *
     * 解析cell对象中所有形如 "$...[?]..." 的值
     * 含 "${...}" 的还需要先解析请求结果
     * 找出出现频率最高的那一个
     * 作为setEach/setCell的目标数组
     *
     * 这样做是为了尽量找出合理的值同时增强容错性
     *
     * @param {WElement} element 所在元素
     * @param {object}   cell    对应的cell对象
     * @param {Function} handler 回调函数
     */
    PageView.prototype.parseCellApi = function (element, cell, handler) {
        var self = this;
        var strCell = JSON.stringify(cell);
        var valueRegExp = /\"\$.*?(\[\?\])?.*?\"/g;
        var detailRegExp = /\$(?:\{(.+?)\})?(.+?)(\.?)\[\?\]/;
        var matchList = strCell.match(valueRegExp);

        var apiMap = {};
        var pathMap = {};
        var api;
        var path;

        function add(map, key) {
            if (!key) {
                return;
            }
            map[key] = map[key] ? (map[key] + 1) : 1;
        }

        function getMax(map) {
            var maxKey;

            for (var key in map) {
                if (!maxKey || (map[key] > map[maxKey])) {
                    maxKey = key;
                }
            }

            return maxKey;
        }

        matchList.forEach(function (value) {
            var match = value.match(detailRegExp);

            if (match) {
                var api = match[1] || '';
                var path = match[2] || '';
                add(apiMap, api);
                add(pathMap, path);
            }
        });

        api = getMax(apiMap);
        path = getMax(pathMap);

        if (typeof handler !== 'function') {
            handler = function () {
            };
        }

        if (api) {
            this.addMtopListener(element, api, function (data) {
                self.parseData(element, '${' + api + '}' + path, function (list) {
                    handler(api, path, list);
                });
            });
        }
        else {
            self.parseData(element, '$' + path, function (list) {
                handler(api, path, list);
            });
        }
    };

    /**
     * 用于setCondition
     * 根据view.conditions和view.condition生成条件列表
     * 即把单个条件和多个条件的情况统一起来
     *
     * @param  {object} view 所在view
     * @return {array}       condition列表
     */
    PageView.prototype.getConditionList = function (view) {
        var conditions = view.conditions || [];

        if (view.condition) {
            conditions = [view.condition];
        }

        return JSON.parse(JSON.stringify(conditions));
    };

    /**
     * 用于setRequest
     *
     * 首先检查登录状态
     * 然后是否该请求已经成功，如果已成功则直接回调结果
     * 如果尚未请求成功，则发起请求并绑定回调事件
     *
     * this.mtop 会记录等待当前mtop请求的所有回调
     * this.data 会以apiAlias记录mtop请求回的数据，同时也是记录该页面所有数据的地方
     *
     * @param {WElement} element  所在元素
     * @param {object}   request  {api, apiAlias, apiVersion, param, needLogin}
     * @param {Function} callback 回调函数
     */
    PageView.prototype.parseMtop = function (element, request, callback) {
        var self = this;
        var mtop = this.mtop;
        var data = this.data;
        var info;

        /**
         * 触发所有监听该mtop请求的回调
         *
         * @param {string} name   apiAlias
         * @param {any}    result 请求结果
         */
        function fire(name, result, oldLength) {
            info.handlers.forEach(function (handler) {
                handler.call(null, result);
            });
            info.handlers.length = 0;
            callback(name, result, oldLength);
        }

        /**
         * 解析所有参数中的变量
         */
        function parseParam(param) {
            Object.keys(param).forEach(function (key) {
                if ((param[key] || '').toString().match(/^\$/)) {
                    self.parseData(element, param[key], function (value) {
                        if (typeof value === 'undefined' || value === '') {
                            delete param[key];
                        }
                        else {
                            param[key] = value;
                        }
                    });
                }
            });
        }

        request.name = request.name || request.api;

        if (typeof callback !== 'function') {
            callback = function () {
            };
        }

        if (request.needLogin && !lib.login.isLogin() && !GLOBAL_CONFIG.ISPC) {
            lib.login.goLogin();
            return;
        }

        info = mtop[request.name];

        if (!info) {
            info = {handlers: []};
            mtop[request.name] = info;
        }
        if (data.hasOwnProperty(request.name) && !request.append) {
            fire(request.name, data[request.name]);
        }
        else {
            parseParam(request.param);

            mtopRequest(request, function (err, result) {
                if (request.apiAlias && GLOBAL_CONFIG.ISPC && GLOBAL_CONFIG.APIDATA) {
                    GLOBAL_CONFIG.APIDATA[request.apiAlias] = result;
                }
                var oldResult = data[request.name];
                var oldList, newList, oldLength;

                if (request.append && oldResult && element.cellPath) {
                    oldList = parsePath(oldResult, element.cellPath.replace(/^\./, ''));
                    oldLength = oldList.length;

                    newList = parsePath(result, element.cellPath.replace(/^\./, ''));
                    if (newList && newList.forEach) {
                        newList.forEach(function (item) {
                            oldList.push(item);
                        });
                    }

                    result = oldResult;
                }

                data[request.api] = result;
                data[request.name] = result;

                fire(request.name, result, oldLength);
            });
        }
    };

    /**
     * 用于action:sendRequest
     * action中的mtop请求是不能缓存的，所以调用之前会先把之前的请求结果清除掉
     */
    PageView.prototype.clearMtop = function (api) {
        var data = this.data;
        if (data && data.hasOwnProperty(api)) {
            delete data[api];
        }
    };

    /**
     * 用于parseCellApi, parseData
     * 在得到mtop请求结果后触发回调
     *
     * @param {string}   name    等待的apiAlias
     * @param {Function} handler 回调函数
     */
    PageView.prototype.addMtopListener = function (element, name, handler) {
        var mtop = this.mtop;
        var data = this.data;
        var info = mtop[name];

        if (!info) {
            info = {handlers: []};
            mtop[name] = info;
        }

        if (data.hasOwnProperty(name)) {
            if (typeof data[name] === 'string') {
                this.parseData(element, data[name], handler);
            }
            else {
                handler(data[name]);
            }
        }
        else {
            info.handlers.push(handler);
        }
    };

    /**
     * 解析某个变量的值
     * 需要元素信息主要是因为解析 "[?]" 需要 element.index
     *
     * @param {WElement} element 所在元素
     * @param {string}   value   变量名
     * @param {Function} handler 回调函数
     */
    PageView.prototype.parseData = function (element, value, handler) {
        var match, apiName, pathName, oriValue = value;

        if (typeof handler !== 'function') {
            handler = function () {
            };
        }

        value = (value || '').toString();

        if (value.match(/^\$/)) {

            if (value.indexOf('$_component_') >= 0) {
                value = value.replace(/\$_component_\.[a-z]+Index/g, function () {
                    return (element.index + 1);
                });
                handler(value);
                return;
            }

            match = value.match(/^\$\{(.+)\}(.*)/);
            if (match) {
                apiName = match[1];
                pathName = match[2];

                if (pathName[0] === '.') {
                    pathName = pathName.substr(1);
                }
                if (this.data.hasOwnProperty(apiName)) {
                    delete this.mtop[apiName];
                    value = parsePath(this.data[apiName], pathName, element.index);
                    handler(value);
                } else {
                    this.addMtopListener(element, apiName, function (data) {
                        value = parsePath(data, pathName, element.index);
                        handler(value);
                    });
                }
            }
            else {
                pathName = value.substr(1);
                value = parsePath(this.data, pathName, element.index);
                handler(value);
            }
        }
        else {
            handler(value);
        }
    };

    /**
     * 用于handleAction
     * 处理事件引发的行动
     *
     * @param {WElement} element  所在元素
     * @param {string}   type     行动类型
     * @param {object}   params   行动参数
     * @param {Function} callback 行动回调
     */
    PageView.prototype.doAction = function (element, type, params, callback) {
        var handler = actionMap[type];

        if (typeof callback !== 'function') {
            callback = function () {
            };
        }

        if (typeof handler === 'function') {
            handler(params, callback, element, this);
        }
    };

    /**
     * 对外输出标题
     * @param {Function} callback
     */
    PageView.prototype.getTitle = function (callback) {
        this.parseData(this.element, this.title, callback);
    };

    /**
     * 输出数据
     * 输出之前会把mtop的数据过滤掉
     */
    PageView.prototype.importData = function () {
        var data = this.data;
        var mtop = this.mtop;
        var result = {};
        Object.keys(data).forEach(function (key) {
            if (!mtop.hasOwnProperty(key)) {
                result[key] = data[key];
            }
        });
        return result;
    };
    </script>

</head>
<body style="font-size: 12px;">
<script type="text/javascript" src="./text-1_files/saved_resource" async="" defer=""></script>
<script type="text/javascript" id="aplus-sufei" src="./text-1_files/index.js.下载" async="" defer=""></script>
<div weapp-host="">
    <div data-type="container" container="" w-layout="absoluteLayout" w-width="-1" w-height="-1"
         w-orientation="vertical" w-id="w-1" weapp-root="" style="background-color: rgb(238, 238, 238);">
        <div scroller="">
            <div content="">
                <div data-type="container" container="" w-layout="linearLayout" w-scroll="1" w-width="-1" w-height="-1"
                     w-orientation="vertical" w-id="w-2">
                    <div scroller="" style="overflow-x: hidden; overflow-y: scroll; transform: translateZ(0px);">
                        <div content="" style="margin-top: 0px; margin-bottom: 0px;">
                            <div data-type="container" container="" w-layout="linearLayout" w-width="-1" w-height="-2"
                                 w-orientation="vertical" w-id="w-3" style="background-image: none;">
                                <div scroller="">
                                    <div content="">
                                        <div data-type="container" container="" w-layout="linearLayout"
                                             w-orientation="vertical" w-width="-1" w-id="w-4" style="height: 0rem;">
                                            <div scroller="">
                                                <div content="">
                                                    <div data-type="image" atom="" w-width="-1" w-id="w-5"
                                                         style="height: 0rem;"><span><img
                                                            src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                                            class="lib-img"></span></div>
                                                    <div data-type="label" atom="" w-width="-1" w-height="-2" w-id="w-6"
                                                         style="margin-right: 0.5rem; font-size: 0.7rem; color: rgb(95, 100, 110); font-weight: bold; margin-left: 0.5rem;">
                                                        <span style="-webkit-line-clamp: 20;"></span></div>
                                                </div>
                                            </div>
                                        </div>
                                        <div data-type="container" container="" w-layout="linearLayout" w-width="-1"
                                             w-height="-2" w-orientation="vertical" w-id="activity_decorate_area">
                                            <div scroller="">
                                                <div content="">
                                                    <div data-type="container" container="" w-layout="absoluteLayout"
                                                         w-width="-1" w-orientation="vertical" w-id="w-7"
                                                         style="background-color: rgb(255, 255, 255); border-color: rgb(221, 221, 221); padding: 0.4rem; border-width: 0.025rem; margin-bottom: 0.6rem; height: 12.2rem; width: 16rem;">
                                                        <div scroller="">
                                                            <div content="">
                                                                <div data-type="image" atom="" w-id="w-8"
                                                                     style="width: 15.2rem; height: 11.4rem;"><span><img
                                                                        src="./img/纯色.jpg" class=""
                                                                        data-size="513x284"
                                                                        data-src-checked="true"></span></div>
                                                                <div data-type="label" atom="" w-gravity="4" w-align="8"
                                                                     w-id="w-9" w-invisible="true"
                                                                     style="background-color: rgba(0, 0, 0, 0.56); width: 15.2rem; font-size: 0.75rem; padding-left: 0.5rem; color: rgba(255, 255, 255, 0.533); height: 1.85rem;">
                                                                    <span style="-webkit-line-clamp: 1; height: 1.2em;"></span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div data-type="container" container="" w-layout="linearLayout"
                                                         w-orientation="horizontal" w-width="-1" w-id="w-10"
                                                         style="background-color: rgb(255, 255, 255); border-color: rgb(221, 221, 221); padding: 0.4rem; border-width: 0.025rem; margin-bottom: 0.6rem; height: 3.8rem;">
                                                        <div scroller="">
                                                            <div content="">
                                                                <a href="https://s.click.taobao.com/UHexhqw"
                                                                   data-type="image" atom="" w-weight="1" w-align="4"
                                                                   w-id="w-11"
                                                                   style="margin-right: 0.2rem; height: 3rem;width:14rem;">
                                                                    <span><img src="./text-1_files/right.jpg" class=""
                                                                               data-size="249x135"
                                                                               data-src-checked="true"></span></a>
                                                                <a href="https://s.click.taobao.com/UHexhqw"
                                                                   data-type="image" atom="" w-weight="1" w-align="6"
                                                                   w-id="w-12"
                                                                   style="height: 3rem; margin-left: 0.2rem;width:14rem;">
                                                                    <span><img src="./text-1_files/left.jpg" class=""
                                                                               data-size="249x135"
                                                                               data-src-checked="true"></span></a>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>function loadJSON(handler) {

    // 从 location 获取页面参数
    var params = [];
    var page = window.G_msp_path || ''; // 兼容店铺首页

    var search = location.search;

    if (search) {
        search = search.slice(1).split('&');
        search.forEach(function (param) {
            param = param.split('=');

            var k = param[0];
            var v = param[1];

            try {
                v = decodeURIComponent(v);
            } catch (err) {
            }

            if (k === 'page') {
                page = v;
            } else {
                params.push(k + ':' + v);
            }
        });
    }

    if (window.G_msp_userId) {
        params.push('userId:' + window.G_msp_userId);
        // 兼容店铺首页
    }

    if (window.G_msp_shopId) {
        params.push('shop_id:' + window.G_msp_shopId);
    }

    if (!page) {
        console.error('缺少 page 参数!');
        return;
    }

    /* debug start */
    // handler(PAGE_MOCK);
    // return;
    /* debug end */

    lib.mtop.request({
        api: "mtop.geb.view.getPageView",
        v: "2.0",
        data: {
            page: page,
            clientVersion: '10000',
            params: params.join(';')
        }
    }, function (json) {
        // 延迟执行回调，可以提早触发load event
        setTimeout(handler, 100, json);
    });
}

loadJSON(function (json) {
    var data = json.data;

    /*
     H5页面打点逻辑 
     Author: 空石 
     @2016.2.23 
     后端: 若云
     参考: https://k3.alibaba-inc.com/issue/7835279?stat=1.5.2&toPage=1&projectId=40654893,http://site.alibaba.net/aplus/aplus_technical_manual/aplus/cdn.html
     */
    setTimeout(function () {
        if (data.data && data.data.shopAplusValue && window.goldlog) {
            window.goldlog.launch({
                'atp_isdpp': data.data.shopAplusValue
            });
        }
    }, 500);

    function setTitle(title) {
        title = title || '手机淘宝';
        try {
            title = decodeURI(title);
        } catch (e) {
        }
        document.title = title;
        if (lib.env.taobaoApp && lib.env.taobaoApp.appname == 'TB' && lib.windvane) {
            lib.windvane.call('WebAppInterface', 'setCustomPageTitle', {title: title});
        }
    }

    var page = new PageView(data);
    var title = data.title || '';

    if (title.toString().indexOf('$') === 0) {
        title = page.parseData(page.element, title, setTitle);
    }
    else {
        setTitle(title);
    }

    var host = document.querySelector('[weapp-host]');
    host.innerHTML = '';
    host.appendChild(page.element.root);

    if (window.imgHelper) {
        window.imgHelper.fireLazyload();
    }
});
</script>


</body>
</html>